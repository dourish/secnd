;;;
;;; SECND - A FORTH FOR 65C02
;;;
;;; Since "FORTH" is actually an abbreviation of "FOURTH", "SECND"
;;; is an abbreviation of "SECOND", it being my second FORTH
;;; implementation. The last one was over 30 years ago, but let's
;;; not worry about that now. This time, I'm sticking closer to
;;; standards, albeit outdated ones; the starting point for this
;;; is FigFORTH although it has become gradually ANSified along the
;;; way.
;;;
;;; I'm building this for my single-board 65C02 computer, the Mite.
;;; It can run in ROM or RAM; for now, the memory map is built
;;; for a RAM-resident configuration.
;;;
;;; More of this code than you would expect was written in the
;;; United Club at LAX Terminal 7. Other places have included
;;; the State Library of New South Wales, a hotel room in Estonia,
;;; and an AirBNB at Joshua Tree.
;;;
;;; SECND is covered by the Creative Commons CC-BY-4.0 license.
;;; Code can be shared and adapted but authorship must be acknowledged.
;;;
;;; Paul Dourish, December 2017
;;;
;;; Version history:
;;; v01  first basic version of interpreter up and running
;;; v02  adding R-stack operators, variables, arrays, allot
;;; v03  first steps for compiler, basic lists, strings, loops, conditionals
;;; v04  rounding out vocabulary, linking more internal operations to
;;;      external words, adding nest checking
;;; v05  recursion, double-length arithmetic, pair operations, signed
;;;      arithmetic
;;; v06  cleaning up and debugging, various new words, more internal
;;;      elements available to Forth, performance improvements
;;; v07  SD card integration, block/buffer implementation, editor
;;; v08  string routines, cleanup, interpreter work, create/does>
;;; v09  ROMmable version, reconfigured text input, expanded FAT16 code,
;;;      disk manager, expanded file code
;;;

#ifdef ROM
  * = $C000
USERBASE=$0800
#else
  * = $0300
USERBASE=$3D00
#endif

;;;
;;; Variables/space setup
;;;

SCRATCH    = $0010  ; through to $001F (adopted from monitor)
PRINTVEC   = $0042  ; and 0043 (borrowed from monitor)

;;; MEMORY MAP
;;;
;;; 0000 through 004F is reserved for the monitor (reusing SCRATCH)
;;;  (It turns out, though, that it is mostly reuseable. Leaving
;;;  SCRATCH, which is shared, $003x is needed for xmodem, but
;;;  $000x, $002x, and $004x are all free for use here.)
;;;  temporarily using $004x for file table data
;;; 0050 through 007F is available for variables (below)
;;; 0080 through 00FF is operand stack
;;; 0100 through 01FF is the hardware stack as usual
;;; 0200 through 02FF is the return stack (more space than needed)
;;; 0300 through 3BFF is the interpreter and compiler code (this file)
;;; 3C00 through 633F is user dictionary space
;;; 6340 through 63DF is temporary string space (for S")
;;; 63E0 through 7BFF is I/O block space
;;; 7C00 through 7DFF is low-level SD I/O buffer space (512 byte block)
;;; 7E00 through 7EBF is the PAD (string assembly area)
;;; 7EC0 through 7EFF is temporary string processing space (WORD)
;;; 7F00 through 7FFF is the input buffer (TIB)

;;; 
;;; KEY SYSTEM VARIABLES
;;;
;;; BASE is variable holding the current numeric base
;;; IPTR is the input pointer (next character to be interpreted)
;;; IP is the instruction pointer
;;; DT (dictionary top) pointer to start (actually, end) of dictionary
;;; RP is return stack pointer
;;; XT holds execution token of currently executing word
;;; CODEVEC holds the location of the code for the next instruction
;;; DP holds pointer to the next available dictionary space
;;; DPTR is an internal variable for traversing the dictionary
;;; STATE is the system status flags (e.g. compilation flag)
;;; CWORD holds a pointer to the word currently being compiled
;;; SOURCE indicates where input is coming from (0 for terminal)
;;; INPUT points to the input buffer
;;; WORD points to the temporary string processing space
;;; INBUFF points to the current non-terminal input area
;;; 
;;;
BASE=$000A          ; and 000B (store two bytes but we only use lower)
USEBLKS=$000D       ; one byte only, block count of USING file
; leave $000E and $000F clear...
IPTR=$0020          ; and 0021 (input pointer)
; hold 0030-003F for XMODEM code
NEXTSECTOR=$0040    ; through $0043 -- next sector to be read in stream
FILESIZE=$0044      ; through $0047 -- size of file in stream
READSIZE=$0048      ; through $004B -- how much data still to read
IP=$0050            ; and 0051
RP=$0052            ; and 0053 (return stack pointer)
DT=$0054            ; and 0055 (ptr to top of dictionary)
; reserve 0056, 0057 (we need 0057 to store a JMP instruction)
XT=$0058            ; and 0059
STATE=$005A         ; and 005B (compiler flag)
DPTR=$005C          ; and 005D (used for searching the dictionary)
DP=$005E            ; and 005F (dictionary pointer i.e. HERE)
; $0060 is free
CWORD=$0061         ; and 0062 (word currently being compiled)
PADPTR=$0063        ; and 0064 (pointer to text area)
SOURCE=$0065        ; current input location
INBUFF=$0066        ; and 0067
CURSEC=$0068        ; through $006B (caches sector stored at LBLOCK)
USEBASE=$006C       ; through $006F (base sector address for block file)
USE=$0070           ; and 0071
PREV=$0072          ; and 0073
USENAME=$0074       ; through 007F
RBASE=$0200         ; base for R-stack
RESERVED=$6340      ; high water mark for user data
TEMPSTR=$6340       ; temporary string storage (for S")
FIRST=$63E0         ; start of space for blocks/disk buffers
LBLOCK=$7C00        ; address of lower I/O data page
HBLOCK=$7D00        ; address of upper I/O data page
IOSENTINEL=$7E00    ; and 7E01 MUST BE PAGE ALIGNED SEE DODIR
PAD=$7E02           ; PAD (string assembly area)
WORD=$7EC0          ; temporary space for parsing words (max 63 chars)
INPUT=$7F00         ; input space

XRECV=$C65C         ; address of XMODEM subroutine from monitor
DUMP=$C4F5          ; address of DUMP subroutine from monitor

MBR=$0200           ; cache SD card master boot record in unused stack space
MBR_NFATS=$0210     ; address of FAT count within cache
MBR_LABEL=$022B     ; address of label within cache

;;; FLAGS AND CONSTANTS
;;;
COMPILE=%00000001   ; status flags
SPI_CMD=64

IMM=%00100000       ; flag for IMMEDIATE word (ie executed in compile mode)
CPO=%01000000       ; flag for COMPILE-ONLY word (give error in interpreter)

;;; The flags below are left on the stack by the compiler to signal
;;; what sort of clean-up operation is needed at the end of a loop.
;;; They also ensure that nesting is correct.
IFELSEFLAG=$FF      ; left by IF and ELSE
LEAVEFLAG=$FE       ; left by LEAVE
DOFLAG=$FD          ; left by DO
BEGINFLAG=$FC       ; left by BEGIN
WHILEFLAG=$FB       ; left by WHILE

BLOCKSIZE=1024
NBUFFERS=6
BUFFERSIZE=BLOCKSIZE+4
BUFFERSPACE=BUFFERSIZE*NBUFFERS
LIMIT=FIRST+BUFFERSPACE

;;; DECL.A65 has declarations for the VIA and ACIA registers
#include "../mitemon/decl.a65"


  jmp coldstart     ; jump past code defined in stack routines

#ifdef ROM
  ;; jump table for use by RAM-resident programs
  jmp puta
  jmp readchar
  jmp printvecstr
  jmp sdloadtomem
  jmp sdsavegen
  jmp newfilesub
  jmp finddirword
  jmp printstacksub
  jmp sdsavebuf
#endif


;;; STACK.A65 has definitions for basic stack operations
#include "../mitemon/stack.a65"


;;;
;;; *** DICTIONARY
;;;
;;; Each entry in the dictionary comprises:
;;; - one byte that is both tags (three upper bits) and word length
;;;   five lower bits)
;;; - the characters making up the word definition name
;;; - pointer to next entry
;;; - the "code word" (address of code handling this instruction, which
;;;   will often be DOLIST for compiled words)
;;; - the parameter space (often the list of addresses for executing
;;;   this word, and often ending with EXIT)
;;;

d0entry
  .byte 4
  .byte "exit"
d0link
  .word $0000
exitcode
d0code
  .word exit

d1entry
  .byte 1
  .byte "+"
d1link
  .word d0entry
d1code
  .word doplus

d2entry
  .byte 1
  .byte "*"
d2link
  .word d1entry
d2code
  .word dotimes

d3entry
  .byte 7
  .byte "0branch"
d3link
  .word d2entry
zerobracode
d3code
  .word dozerobra

d4entry
  .byte 4
  .byte "true"
d4link
  .word d3entry
d4code
  .word dotrue

d5entry
  .byte 3
  .byte "lit"
d5link
  .word d4entry
dolitcode
d5code
  .word dolit

d6entry
  .byte 1
  .byte "."
d6link
  .word d5entry
d6code
  .word doprint16

d7entry
  .byte 2
  .byte "<>"
d7link
  .word d6entry
d7code
  .word donotequal

d8entry
  .byte 6
  .byte "branch"
d8link
  .word d7entry
branchcode
d8code
  .word dobranch

d9entry
  .byte 3
  .byte "dup"
d9link
  .word d8entry
d9code
  .word dodup

d10entry
  .byte 4
  .byte "swap"
d10link
  .word d9entry
d10code
  .word doswap

d11entry
  .byte 4
  .byte "drop"
d11link
  .word d10entry
d11code
  .word dodrop

d12entry
  .byte 1
  .byte "/"
d12link
  .word d11entry
d12code
  .word dodiv

d13entry
  .byte 3
  .byte "mod"
d13link
  .word d12entry
d13code
  .word domod

d14entry
  .byte 1
  .byte "="
d14link
  .word d13entry
d14code
  .word doequal

d15entry
  .byte 5
  .byte "depth"
d15link
  .word d14entry
d15code
  .word dodepth

d16entry
  .byte 1
  .byte ">"
d16link
  .word d15entry
d16code
  .word dogreater

d17entry
  .byte 1
  .byte "<"
d17link
  .word d16entry
d17code
  .word doless

d18entry
  .byte 2
  .byte "cr"
d18link
  .word d17entry
crcode
d18code
  .word docr

d19entry
  .byte 4
  .byte "emit"
d19link
  .word d18entry
d19code
  .word doemit

d20entry
  .byte 4
  .byte "over"
d20link
  .word d19entry
d20code
  .word doover

d21entry
  .byte 3
  .byte "rot"
d21link
  .word d20entry
d21code
  .word dorot

d22entry
  .byte 5
  .byte "false"
d22link
  .word d21entry
d22code
  .word dofalse

d23entry
  .byte 1
  .byte "@"
d23link
  .word d22entry
d23code
  .word dofetch

d24entry
  .byte 2
  .byte "c@"
d24link
  .word d23entry
d24code
  .word docfetch

d25entry
  .byte 1
  .byte "!"
d25link
  .word d24entry
dostorecode
d25code
  .word dostore

d26entry
  .byte 2
  .byte "c!"
d26link
  .word d25entry
d26code
  .word docstore

d27entry
  .byte 5
  .byte "cells"
d27link
  .word d26entry
d27code
  .word docells

d28entry
  .byte 8
  .byte "variable"
d28link
  .word d27entry
d28code
  .word dovariable

d29entry
  .byte 1
  .byte "-"
d29link
  .word d28entry
minuscode
d29code
  .word dominus

d30entry
  .byte 4
  .byte "here"
d30link
  .word d29entry
herecode
d30code
  .word dohere

d31entry
  .byte 5
  .byte "allot"
d31link
  .word d30entry
d31code
  .word doallot

d32entry
  .byte 3
  .byte "bye"
d32link
  .word d31entry
d32code
  .word dobye

d33entry
  .byte 1
  .byte ":"
d33link
  .word d32entry
d33code
  .word docolon

d34entry
  .byte %00100001   ; set the immediate bit plus count of 1
  .byte ";"
d34link
  .word d33entry
d34code
  .word dosemic

d35entry
  .byte 2
  .byte ">r"
d35link
  .word d34entry
d35code
  .word dotor

d36entry
  .byte 2
  .byte "r>"
d36link
  .word d35entry
d36code
  .word dofromr

d37entry
  .byte 2
  .byte "r@"
d37link
  .word d36entry
d37code
  .word dorcopy

d38entry
  .byte 1
  .byte "i"
d38link
  .word d37entry
d38code
  .word dorcopy

d39entry
  .byte IMM+2
  .byte $2e, $22    ; dot, quote (.")
d39link
  .word d38entry
dotquotecode
d39code
  .word dodotqu

d40entry
  .byte CPO+IMM+2
  .byte "if"
d40link
  .word d39entry
d40code
  .word doif

d41entry
  .byte CPO+IMM+4
  .byte "then"
d41link
  .word d40entry
d41code
  .word dothen

d42entry
  .byte CPO+IMM+5
  .byte "begin"
d42link
  .word d41entry
d42code
  .word dobegin

d43entry
  .byte CPO+IMM+5
  .byte "until"
d43link
  .word d42entry
d43code
  .word dountil  

d44entry
  .byte CPO+IMM+4
  .byte "else"
d44link
  .word d43entry
d44code
  .word doelse

d45entry
  .byte 5
  .byte "words"
d45link
  .word d44entry
d45code
  .word dowords

d46entry
  .byte CPO+IMM+2
  .byte "do"
d46link
  .word d45entry
d46code
  .word dodo

d47entry
  .byte 4
  .byte "(do)"
d47link
  .word d46entry
parendocode
d47code
  .word doparendo

d48entry
  .byte CPO+IMM+4
  .byte "loop"
d48link
  .word d47entry
d48code
  .word doloop

d49entry
  .byte 6
  .byte "(loop)"
d49link
  .word d48entry
parenloopcode
d49code
  .word doparenloop

d50entry
  .byte CPO+IMM+5
  .byte "+loop"
d50link
  .word d49entry
d50code
  .word doplusloop

d51entry
  .byte 7
  .byte "(+loop)"
d51link
  .word d50entry
parplusloopcode
d51code
  .word doparplusloop

d52entry
  .byte 1
  .byte "j"
d52link
  .word d51entry
d52code
  .word doj

d53entry
  .byte 1
  .byte "k"
d53link
  .word d52entry
d53code
  .word dok

d54entry
  .byte 3
  .byte "max"
d54link
  .word d53entry
d54code
  .word domax

d55entry
  .byte 3
  .byte "min"
d55link
  .word d54entry
d55code
  .word domin

d56entry
  .byte 3
  .byte "key"
d56link
  .word d55entry
d56code
  .word dokey

d57entry
  .byte 3
  .byte "and"
d57link
  .word d56entry
d57code
  .word doand

d58entry
  .byte 2
  .byte "or"
d58link
  .word d57entry
d58code
  .word door

d59entry
  .byte 3
  .byte "xor"
d59link
  .word d58entry
d59code
  .word doxor

d60entry
  .byte 2
  .byte "0="
d60link
  .word d59entry
eqlzerocode
d60code
  .word doeqlzero

d61entry
  .byte 2
  .byte "1+"
d61link
  .word d60entry
d61code
  .word do1plus

d62entry
  .byte 2
  .byte "1-"
d62link
  .word d61entry
d62code
  .word do1minus

d63entry
  .byte 2
  .byte "2+"
d63link
  .word d62entry
d63code
  .word do2plus

d64entry
  .byte 2
  .byte "2-"
d64link
  .word d63entry
d64code
  .word do2minus

d65entry
  .byte IMM+5
  .byte "leave"
d65link
  .word d64entry
d65code
  .word doleave

d66entry
  .byte 7
  .byte "(leave)"
d66link
  .word d65entry
parenleavecode
d66code
  .word doparenleave

d67entry
  .byte 6
  .byte "invert"
d67link
  .word d66entry
d67code
  .word doinvert

d68entry
  .byte IMM+5
  .byte "while"
d68link
  .word d67entry
d68code
  .word dowhile

d69entry
  .byte CPO+IMM+6
  .byte "repeat"
d69link
  .word d68entry
d69code
  .word dorepeat

d70entry
  .byte CPO+IMM+7
  .byte "recurse"
d70link
  .word d69entry
d70code
  .word dorecurse

d71entry
  .byte IMM+1
  .byte $5c         ; backslash
d71link
  .word d70entry
d71code
  .word dobackslsh

d72entry
  .byte 8
  .byte "constant"
d72link
  .word d71entry
d72code
  .word doconstant

d73entry
  .byte IMM+2
  .byte $73, $22    ; "s", quote (.")
d73link
  .word d72entry
d73code
  .word dosquote

d74entry
  .byte 8
  .byte "sliteral"
d74link
  .word d73entry
sliteralcode
d74code
  .word dostrlit

d75entry
  .byte 4
  .byte "type"
d75link
  .word d74entry
d75code
  .word dotype

d76entry
  .byte 3
  .byte "s>d"
d76link
  .word d75entry
d76code
  .word dosgltodbl

d77entry
  .byte 2
  .byte "d+"
d77link
  .word d76entry
d77code
  .word doadd32

d78entry
  .byte 2
  .byte "d-"
d78link
  .word d77entry
d78code
  .word dosub32

d79entry
  .byte 2
  .byte "m+
d79link
  .word d78entry
d79code
  .word doaddmix

d80entry
  .byte 2
  .byte "d="
d80link
  .word d79entry
d80code
  .word doeql32

d81entry
  .byte 3
  .byte "d0="
d81link
  .word d80entry
d81code
  .word dozero32

d82entry
  .byte 2
  .byte "m*"
d82link
  .word d81entry
d82code
  .word domultmix

d83entry
  .byte 2
  .byte "d."
d83link
  .word d82entry
d83code
  .word doprint32

d84entry
  .byte 5
  .byte "2swap"
d84link
  .word d83entry
d84code
  .word do2swap

d85entry
  .byte 4
  .byte "2dup"
d85link
  .word d84entry
d85code
  .word do2dup

d86entry
  .byte 5
  .byte "2over"
d86link
  .word d85entry
d86code
  .word do2over

d87entry
  .byte 5
  .byte "2drop"
d87 link
  .word d86entry
d87code
  .word do2drop

d88entry
  .byte 6
  .byte "lshift"
d88link
  .word d87entry
d88code
  .word dolshift

d89entry
  .byte 6
  .byte "rshift"
d89link
  .word d88entry
d89code
  .word dorshift

d90entry
  .byte 2
  .byte "*/"
d90link
  .word d89entry
d90code
  .word dostardiv

d91entry
  .byte 3
  .byte "abs"
d91link
  .word d90entry
d91code
  .word doabs

d92entry
  .byte 6
  .byte "negate"
d92link
  .word d91entry
d92code
  .word donegate

d93entry
  .byte 4
  .byte "pick"
d93link
  .word d92entry
d93code
  .word dopick

d94entry
  .byte 4
  .byte "?dup"
d94link
  .word d93entry
d94code
  .word doquerydup

d95entry
  .byte 2
  .byte "+!"
d95link
  .word d94entry
d95code
  .word doplusstore

d96entry
  .byte 2
  .byte ".s"
d96link
  .word d95entry
d96code
  .word dodots

d97entry
  .byte IMM+1
  .byte "("
d97link
  .word d96entry
d97code
  .word docomment

d98entry
  .byte 4
  .byte "/mod"
d98link
  .word d97entry
d98code
  .word dodivmod

d99entry
  .byte 6
  .byte "forget"
d99link
  .word d98entry
d99code
  .word doforget

d100entry
  .byte IMM+1
  .byte $27         ; tick
d100link
  .word d99entry
d100code
  .word dotick

d101entry
  .byte 9
  .byte "immediate"
d101link
  .word d100entry
d101code
  .word doimmed

d102entry
  .byte 7
  .byte "dnegate"
d102link
  .word d101entry
d102code
  .word donegate32

d103entry
  .byte 4
  .byte "fill"
d103link
  .word d102entry
dofillcode
d103code
  .word dofill

d104entry
  .byte 1
  .byte "0"
d104link
  .word d103entry
d104code
  .word doloadconst
d104param
  .word $0000

d105entry
  .byte 2
  .byte "u."
d105link
  .word d104entry
d105code
  .word douprint16

d106entry
  .byte 2
  .byte ".r"
d106link
  .word d105entry
d106code
  .word dorprint16

d107entry
  .byte 3
  .byte "d0<"
d107link
  .word d106entry
d107code
  .word dolesszero32

d108entry
  .byte 4
  .byte "dabs"
d108link
  .word d107entry
d108code
  .word doabs32

d109entry
  .byte 2
  .byte "d<"
d109link
  .word d108entry
d109code
  .word doless32

d110entry
  .byte 4
  .byte "dmax"
d110link
  .word d109entry
d110code
  .word dodmax

d111entry
  .byte 4
  .byte "dmin"
d111link
  .word d110entry
d111code
  .word dodmin

d112entry
  .byte 3
  .byte "d.r"
d112link
  .word d111entry
d112code
  .word dorprint32

d113entry
  .byte 5
  .byte "abort"
d113link
  .word d112entry
d113code
  .word abort

d114entry
  .byte 5
  .byte "value"
d114link
  .word d113entry
d114code
  .word dovalue

d115entry
  .byte 6
  .byte "delete"
d115link
  .word d114entry
d115code
  .word dodelete

d116entry
  .byte 4
  .byte "key?"
d116link
  .word d115entry
d116code
  .word dokeyqu

d117entry
  .byte 3
  .byte "nip"
d117link
  .word d116entry
d117code
  .word donip

d118entry
  .byte 4
  .byte "tuck"
d118link
  .word d117entry
d118code
  .word dotuck

;d119entry
;  .byte 4
;  .byte "dump"
;d119link
;  .word d118entry
;dumpcode
;d119code
;  .word dodump

d120entry
  .byte 5
  .byte "count"
d120link
  .word d118entry
d120code
  .word docount

d121entry
  .byte 5
  .byte "mount"
d121link
  .word d120entry
d121code
  .word domount

d122entry
  .byte 3
  .byte "u.r"
d122link
  .word d121entry
d122code
  .word dorprint16u

;d123entry
;  .byte 4
;  .byte "fat!"
;d123link
;  .word d122entry
;d123code
;  .word dofatset

;d124entry
;  .byte 7
;  .byte "freefat"
;d124link
;  .word d123entry
;d124code
;  .word dofreefat

;d125entry
;  .byte 7
;  .byte "freedir"
;d125link
;  .word d124entry
;d125code
;  .word dofreedir

d126entry
  .byte 7
  .byte "newfile"
d126link
  .word d122entry
d126code
  .word donewfile

d127entry
  .byte 6
  .byte "rename"
d127link
  .word d126entry
d127code
  .word dorename

;d128entry
;  .byte 7
;  .byte "cltofat"
;d128link
;  .word d127entry
;d128code
;  .word docltofat

d129entry
  .byte 9
  .byte "loadblock"
d129link
  .word d127entry
loadblockcode
d129code
  .word doloadblock

d130entry
  .byte 5
  .byte "ident"
d130link
  .word d129entry
d130code
  .word doident

d131entry
  .byte 3
  .byte "dir"
d131link
  .word d130entry
d131code
  .word dodir

d132entry
  .byte 4
  .byte "show"
d132link
  .word d131entry
d132code
  .word doshow

d133entry
  .byte 4
  .byte "file"
d133link
  .word d132entry
d133code
  .word dofile

;d134entry
;  .byte 5
;  .byte "fload"
;d134link
;  .word d132entry
;d134code
;dofloadcode
;  .word dofload

d135entry
  .byte 7
  .byte "include"
d135link
  .word d133entry
d135code
  .word doinclude

d136entry
  .byte 9
  .byte "saveblock"
d136link
  .word d135entry
d136code
  .word dosaveblock

d137entry
  .byte 5
  .byte "using"
d137link
  .word d136entry
d137code
  .word dousing

d138entry
  .byte 5
  .byte "block"
d138link
  .word d137entry
d138code
  .word doblock

d139entry
  .byte 6
  .byte "buffer"
d139link
  .word d138entry
d139code
  .word dobuffer

d140entry
  .byte 6
  .byte "update"
d140link
  .word d139entry
d140code
  .word doupdate

d141entry
  .byte 4
  .byte "prev"
d141link
  .word d140entry
d141code
  .word doloadconst
  .word PREV

d142entry
  .byte 5
  .byte "flush"
d142link
  .word d141entry
d142code
  .word doflush

d143entry
  .byte 5
  .byte "first"
d143link
  .word d142entry
d143code
  .word doloadconst
  .word FIRST

d144entry
  .byte 4
  .byte "edit"
d144link
  .word d143entry
d144code
  .word doedit

d145entry
  .byte 4
  .byte "list"
d145link
  .word d144entry
d145code
  .word dolistword

d146entry
  .byte 4
  .byte "load"
d146link
  .word d145entry
d146code
  .word doload

d147entry
  .byte 3
  .byte "use"
d147link
  .word d146entry
d147code
  .word doloadconst
  .word USE

d148entry
  .byte 3
  .byte "sp@"
d148link
  .word d147entry
d148code
  .word dospat

;d149entry
;  .byte 2
;  .byte ";s"
;d149link
;  .word d148entry
;d149code
;  .word dosemics

d150entry
  .byte 9
  .byte "-trailing"
d150link
  .word d148entry
d150code
  .word dodashtrail

d151entry
  .byte 7
  .byte "/string"
d151link
  .word d150entry
d151code
  .word doslashstr

d152entry
  .byte 7
  .byte "compare"
d152link
  .word d151entry
d152code
  .word docompare

d153entry
  .byte 4
  .byte "move"
d153link
  .word d152entry
d153code
  .word domove

d154entry
  .byte 5
  .byte "cmove"
d154link
  .word d153entry
d154code
  .word domoveup

d155entry
  .byte 6
  .byte "cmove>"
d155link
  .word d154entry
d155code
  .word domovedown

d156entry
  .byte 6
  .byte "accept"
d156link
  .word d155entry
d156code
  .word doaccept

d157entry
  .byte 5
  .byte "iobuf"
d157link
  .word d156entry
d157code
  .word doloadconst
  .word LBLOCK

d158entry
  .byte 12
  .byte "save-buffers"
d158link
  .word d157entry
d158code
  .word dosavebufs

;d159entry
;  .byte 4
;  .byte "base"
;d159link
;  .word d158entry
;d159code
;  .word doloadconst
;  .word USERBASE

d160entry
  .byte 3
  .byte "ud."
d160link
  .word d158entry
d160code
  .word doprint32u

d161entry
  .byte 3
  .byte "um*"
d161link
  .word d160entry
d161code
  .word doumstar

d162entry
  .byte 6
  .byte "um/mod"
d162link
  .word d161entry
d162code
  .word doumdivmod

d163entry
  .byte 6
  .byte "sm/rem"
d163link
  .word d162entry
d163code
  .word dosmdivrem

d164entry
  .byte 6
  .byte "create"
d164link
  .word d163entry
d164code
  .word docreate

d165entry
  .byte 1
  .byte ","
d165link
  .word d164entry
commacode
d165code
  .word docomma

d166entry
  .byte 7
  .byte "execute"
d166link
  .word d165entry
d166code
  .word doexecute

d167entry
  .byte 6
  .byte "unused"
d167link
  .word d166entry
d167code
  .word dounused

d168entry
  .byte 3
  .byte "hex"
d168link
  .word d167entry
d168code
  .word dohex

d169entry
  .byte 7
  .byte "decimal"
d169link
  .word d168entry
d169code
  .word dodecimal

d170entry
  .byte 4
  .byte "base"
d170link
  .word d169entry
d170code
  .word doloadconst
  .word BASE

d171entry
  .byte 4
  .byte "char"
d171link
  .word d170entry
d171code
  .word dochar

d172entry
  .byte IMM+6
  .byte "[char]"
d172link
  .word d171entry
d172code
  .word dobrchar

d173entry
  .byte CPO+IMM+5
  .byte "does>"
d173link
  .word d172entry
d173code
  .word dodoes

d174entry
  .byte 6
  .byte "(does)"
d174link
  .word d173entry
dodoesrtcode
d174code
  .word dodoesrt

d175entry
  .byte 6
  .byte "dodoes"
d175link
  .word d174entry
dododoescode
d175code
  .word dododoes

d176entry
  .byte 2
  .byte "2/"
d176link
  .word d175entry
d176code
  .word dotwodiv

d177entry
  .byte 2
  .byte "2*"
d177link
  .word d176entry
d177code
  .word dotwotimes

d178entry
  .byte 5
  .byte "*/mod"
d178link
  .word d177entry
d178code
  .word dostardivmod

d179entry
  .byte 6
  .byte "using?"
d179link
  .word d178entry
d179code
  .word dousingq

d180entry
  .byte IMM+6
  .byte "abort", $22 ; abort"
d180link
  .word d179entry
d180code
  .word doabortq

d181entry
  .byte 8
  .byte "(abort", $22, $29 ; (abort")
d181link
  .word d180entry
doabortqcode
d181code
  .word doabortqrt

d182entry
  .byte 6
  .byte "latest"
d182link
  .word d181entry
d182code
  .word dolatest

d183entry
  .byte 5
  .byte "state"
d183link
  .word d182entry
d183code
  .word doloadconst
  .word STATE

d184entry
  .byte 8
  .byte "cliteral"
d184link
  .word d183entry
cliteralcode
d184code
  .word docliteral

d185entry
  .byte IMM+2
  .byte "c", $22    ; for c"
d185link
  .word d184entry
d185code
  .word docquote

d186entry
  .byte 4
  .byte "find"
d186link
  .word d185entry
d186code
  .word dofind

d187entry
  .byte IMM+8
  .byte "postpone"
d187link
  .word d186entry
d187code
  .word dopostpone

d188entry
  .byte 6
  .byte "sdsave"
d188link
  .word d187entry
d188code
  .word dosdsave

dlimitentry
  .byte 5
  .byte "limit"
  .word d188entry
dlimitcode
  .word doloadconst
  .word LIMIT

dtoentry
  .byte IMM+2
  .byte "to"
  .word dlimitentry
dtocode
  .word doto

dleftbrentry
  .byte IMM+1
  .byte "["
  .word dtoentry
dleftbrcode
  .word doleftbr

drightbrentry
  .byte IMM+1
  .byte "]"
  .word dleftbrentry
drightbrcode
  .word dorightbr

dliteralentry
  .byte CPO+IMM+7
  .byte "literal"
  .word drightbrentry
  .word doliteral

deraseentry
  .byte 5
  .byte "erase"
  .word dliteralentry
  .word dolist
  .word dolitcode
  .word 0
  .word dofillcode
  .word exitcode

dtop
dbrtickentry
  .byte IMM+3
  .byte "[']"
  .word deraseentry
  .word dotick      ; tick is compiler-aware


;d101entry
;  .byte %00100011   ; IMM plus count of three
;  .byte "?do"
;d101llink
;  d100entry
;d101code
;  .word doqdo
;
;dtop
;d102entry
;  .byte 5
;  .byte "(?do)"
;d102link
;  .word d101entry
;parenqdocode
;d102code
;  .word doparenqdo

;; TOP OF DICTIONARY




;;;
;;; The words below are my experiment on calling things and getting
;;; back to the interpreter. Dummy is the word we'll enter in order to
;;; execute something; the point of it is to make sure that after we've
;;; executed what we want, we run "doquitword", which should take us
;;; back into the interpreter loop
;;;
;;; Once I have the interpreter loop running in a more standard way,
;;; this won't be needed.
;;;


doquitword
  .byte 0
doquitlink
  .word $0000
doquitcode
  .word interploop

;;; This needs to be in RAM, so for the ROM version we have to
;;; set it up.
setupdummy
#ifdef ROM
dummy=$0000         ; not using first few bytes BUG move this later!
dummycode=$0003
dummyparam=$0005
dummyexit=$0007
  stz dummy
  stz dummy+1
  stz dummy+2
  lda #<dolist
  sta dummy+3
  lda #>dolist
  sta dummy+4
  stz dummy+5
  stz dummy+6
  lda #<doquitcode
  sta dummy+7
  lda #>doquitcode
  sta dummy+8
#endif
  rts

#ifndef ROM
dummy
  .byte 0
dummylink
  .word $0000
dummycode
  .word dolist      ; won't actually run this, start with NEXT instead
dummyparam
  .word $0000       ; will write in the actual code link word here
dummyexit
  .word doquitcode
#endif



;;;
;;; *** COLD START
;;;
;;; Initialization and configuration. This version is running
;;; from RAM, so there's no need to initialize the ACIA. Set up
;;; the stack and the major variables.
;;;
coldstart

#ifdef ROM
;  ldx #255
;  txs               ; initialize the hardware stack
;  cld               ; clear decimal mode

  ;; configure the ACIA
  lda #%00001011    ; no parity, no echo, no interrupt
  sta ACIA_COMMAND
  lda #%00011111    ; 1 stop bit, 8 data bits, 19200 baud
  sta ACIA_CONTROL
#endif

  ;; initialize the 6522 for the SD routines
  jsr setup6522

  ;; initialize stack...
  jsr initstack

#ifdef DISKMAN
  jmp startdiskman
#endif

midway
  ;; initialize variables...

  ;; IP is the Forth instruction pointer
  stz IP
  stz IP+1

  lda #$6c          ; indirect jump instruction
  sta XT-1          ; to make NEXT work

  stz STATE         ; make sure compiler is off

  ;; Initialize the return stack. I'm just putting that on page 2, 
  ;; growing downwards, until I have a better idea; I should probably
  ;; combine with some other area because a whole page is much
  ;; more space than needed
  lda #$FF
  sta RP
  lda #>RBASE
  sta RP+1

  ;; Initialize DT to the last entry on the dictionary (below)
  lda #<dtop
  sta DT
  lda #>dtop
  sta DT+1  

  ;; Initialize DP to the first available dictionary space (USERBASE)
  lda #<USERBASE
  sta DP
  lda #>USERBASE
  sta DP+1

  ;; initialize BASE to 10
  lda #10
  sta BASE
  stz BASE+1

  ;; initialize pointers and memory for BLOCK code
  stz PREV
  stz PREV+1
  lda #<FIRST
  sta USE
  lda #>FIRST
  sta USE+1
  jsr zerobuffers

  ;; mark USEBASE as invalid
  lda #$ff
  sta USEBASE+3

  ;; initialize the dummy word we use for execution
  jsr setupdummy

  ;; print a greeting
  ldy #0
.(
next_char
  lda greeting,y
  beq done
  jsr puta
  iny
  jmp next_char
done
.)

  ;; print the number of free bytes
  jsr unusedsub
  jsr print16u
  ldy #0
.(
next_char
  lda bytesfree,y
  beq done
  jsr puta
  iny
  jmp next_char
done
.)

  ;; jump to warm start address, which finishes the job and
  ;; starts the interpreter
  jmp warmstart




;;;
;;; *** INNER INTERPRETER
;;;
;;; The three routines below -- NEXT, DOLIST, and EXIT -- are the core
;;; of the inner interpreter, which executes stored words.
;;;
;;; NEXT moves from one instruction to the next inside a defined word.
;;; This code is included at the end of each assembly language routine
;;; (or rather, we jump to it).
;;;
;;; DOLIST begins the execution of a compiled word. It stores the IP
;;; on the return stack, resets the IP to the new word, and then calls
;;; NEXT to start on it.
;;;
;;; EXIT is compiled in as the last address of each compiled word. It
;;; undoes what DOLIST has done, and moves back to the earlier execution
;;; context.
;;;
;;; Note that none of these are subroutines -- everything is connected
;;; as direct jumps (actually, indirect jumps!) with the RSTACK used
;;; to keep track of what's going on.


;;; DOLIST is the executing code for a colon-defined word. Also
;;; known as ENTER in some implementations.
dolist
  ;; first, push the current instruction pointer onto the
  ;; return stack (subroutine unrolled)
  lda IP+1
  sta (RP)
  dec RP
  lda IP
  sta (RP)
  dec RP

  ;; next, grab the first address in the parameter block for this
  ;; colon-defined word. We know that XT points to the code word.
  ;; so we grab that address and then add one cell (two bytes)
  ;; store this in IP.
  clc
  lda XT
  adc #$2
  sta IP
  lda XT+1
  adc #0
  sta IP+1

  ;; IP now points to the next instruction we want to execute, in
  ;; this word. Proceed to execute it.
  ;jmp next         ; commented out because we can just fall through

;;; ** PUT NOTHING HERE... depending on fall-through from DOLIST to NEXT!

;;; NEXT executes the next word. Before it does the jump, it increments
;;; IP so that IP always designates the next word to be executed.
next
  ldy #1            ; IP points to the location storing the next
  lda (IP)          ; word we need to execute. fetch that location,
  sta XT            ; and store it in XT.
  lda (IP),y
  sta XT+1

  ;; increment IP by two bytes (one cell) and then move on.
  ;; we need to do a doubly-indirect jump through XT. by having
  ;; the instruction before XT be the instruction for an indirect
  ;; jump, we achieve that effect. XT-1 was set to $6C in the
  ;; cold start routine. the addition and jump are combined to save
  ;; a cycle in most cases.
  
  clc
  lda IP
  adc #2
  sta IP
  bcs addupper      ; no carry is the more common case
  jmp XT-1          ; two JMP instructions saves us a branch
addupper
  inc IP+1
  clc               ; ensure carry always clear when entering word
  jmp XT-1


;;; EXIT is the routine that is called at the end of each colon-defined
;;; word (it's compiled in as the last address to be called). It undoes
;;; DOLIST... it removes an address from the return stack, puts it back
;;; as the instruction pointer, and calls next.
exit
  ;; formerly jsr rpull, now unrolled.
  inc RP            ; take value off return stack and put it in IP
  lda (RP)
  sta IP
  inc RP
  lda (RP)          ; and place it in the instruction pointer
  sta IP+1
null
  jmp next          ; go execute the next instruction




;;;
;;; *** PRIMITIVES
;;;
;;; Individual routines for each instruction. Most of these are
;;; regular words, whose run-time behaviour is specified here and
;;; at compile-time are simply written in as addresses to the code
;;; words in the dictionary. Some have separate compile-time and
;;; run-time components (e.g. DO and (DO)).
;;;

doplus
  jsr add16
  jmp next

dominus
  jsr sub16
  jmp next

dotimes
  jsr multmixsub
  ;; that produces a 32-bit value, so ignore the upper bytes and
  ;; just copy lower bytes over them
  lda 1,x
  sta 3,x
  lda 2,x
  sta 4,x
  jmp drop1cell

;;; This routine is shared between /, MOD, and /MOD. All three use
;;; SM/REM to do the division, but SM/REM requires the dividend to
;;; be a double-value. This massages the input so that it's correct
;;; before doing the division.
divmodsub
.(
  dex               ; make space on the stack
  dex
  lda 3,x           ; copy 16-bit value into the new top of stack
  sta 1,x
  lda 4,x
  sta 2,x

  lda 5,x           ; now convert next-to-top to 32 bits. start
  sta 3,x           ; by copying the two bytes we have into the
  lda 6,x           ; new lower positions
  sta 4,x

  bit 4,x           ; test the sign bit and sign-extend into the
  bpl dozero        ; upper two bytes.
  lda #$ff          ; negative, so fill with ones.
  sta 5,x
  sta 6,x
  bra continue
dozero
  stz 5,x           ; positive, so fill with zeros
  stz 6,x
continue
  jsr smdivmodsub   ; actual division happens here
  rts
.)    

dodiv
  jsr divmodsub
  lda 1,x
  sta 3,x
  lda 2,x
  sta 4,x
  jmp drop1cell

domod
  jsr divmodsub
  jmp drop1cell

dodivmod
  jsr divmodsub
  jmp next

dotwotimes
.(
  asl stackbase+1,x ; shift the word left
  rol stackbase+2,x
  jmp next
.)

dotwodiv
  lda stackbase+2,x
  cmp #128          ; sets carry to top bit, for sign extension
  ror stackbase+2,x
  ror stackbase+1,x
  jmp next  

doprint16
  jsr print16s
  jmp next

douprint16
  jsr print16u
  jmp next

dorprint16
  jsr swap16        ; pull number to be printed to the top
  jsr rprint16s
  jmp next

dorprint16u
  jsr swap16
  jsr rprint16u
  jmp next

doprint32
  jsr print32s
  jmp next

doprint32u
  jsr print32u
  jmp next

dorprint32
  ;; top cell is the field width. next two cells down are the
  ;; double-length number. Do a custom rotation.
  lda stackbase+2,x ; push top cell onto hardware stack, MSB first
  pha
  lda stackbase+1,x
  pha
  lda stackbase+3,x ; move double-word from +3 through +6 to
  sta stackbase+1,x ; +1 through +4
  lda stackbase+4,x
  sta stackbase+2,x
  lda stackbase+5,x
  sta stackbase+3,x
  lda stackbase+6,x
  sta stackbase+4,x
  pla               ; restore field width from hardware stack
  sta stackbase+5,x ; but tuck it under the double word
  pla
  sta stackbase+6,x
  jsr rprint32s
  jmp next

docr
  jsr crlf
  jmp next

dodup
  jsr dup16
  jmp next

dodrop
drop1cell
  inx
  inx
  jmp next

doswap
  jsr swap16
  jmp next

;;; Implements PICK. When given a parameter over, say, 64, this is
;;; likely to go very wrong.
dopick
  jsr pop16         ; pop value off the stack
  asl stackaccess   ; multiply by two to convert to bytes
  rol stackaccess+1
  clc
  lda stackaccess   ; add that to stackbase
  adc #<stackbase
  sta stackaccess
  lda stackaccess+1
  adc #>stackbase
  sta stackaccess+1
;  clc  carry guaranteed clear here now
  txa               ; now add X + 1
  inc
  adc stackaccess
  sta stackaccess
.(
  bcc skip
  inc stackaccess+1
skip
.)

  dex
  dex
  ldy #0
  lda (stackaccess),y
  sta stackbase+1,x
  iny
  lda (stackaccess),y
  sta stackbase+2,x

  jmp next 


doquerydup
.(
  lda stackbase+1,x
  ora stackbase+2,x
  beq done
  jsr dup16
done
  jmp next
.)

dorshift
.(
  ldy stackbase+1,x ; max is 32 by standard, so need only one byte
  inx
  inx
loop
  lsr stackbase+2,x ; going right, so start with MSB
  ror stackbase+1,x
  dey
  bne loop
.)
  jmp next

dolshift
.(
  ldy stackbase+1,x ; max is 32 by standard, so need just one byte
  inx
  inx
loop
  asl stackbase+1,x ; going left, so start with LSB
  rol stackbase+2,x
  dey
  bne loop
.)
  jmp next

doequal
.(
  lda stackbase+1,x
  cmp stackbase+3,x
  bne notequal
  lda stackbase+2,x
  cmp stackbase+4,x
  bne notequal
equal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp settrue
notequal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp setfalse
.)


donotequal
.(
  lda stackbase+1,x
  cmp stackbase+3,x
  bne notequal
  lda stackbase+2,x
  cmp stackbase+4,x
  bne notequal
equal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp setfalse
notequal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp settrue
.)


;;; No 16-bit comparisons, so for signed arithmetic, we basically
;;; have to do a subtraction and then test for overflow. this
;;; routine is borrowed from fig6502 and I'm still not sure what
;;; the EOR is for, if anything.
dogreater
.(
  sec
  lda stackbase+1,x
  sbc stackbase+3,x
  lda stackbase+2,x
  sbc stackbase+4,x
  bvc there
  eor #$80
there
  bpl here
  inx
  inx
  jmp settrue
here
  inx
  inx
  jmp setfalse
.)


;;; See dogreater above.
doless
.(
  sec
  lda stackbase+3,x
  sbc stackbase+1,x
  lda stackbase+4,x
  sbc stackbase+2,x
  bvc there
  eor #$80
there
  bpl here
  inx
  inx
  jmp settrue
here
  inx
  inx
  jmp setfalse
.)


dodepth
  stx SCRATCH
  lda #$ff
  sec
  sbc SCRATCH
  clc
  lsr               ; shift right to divide by two
  stz stackbase,x
  dex
  sta stackbase,x
  dex
  jmp next

doemit
  lda stackbase+1,x
  jsr puta
  jmp drop1cell

;;; Implements OVER. We do everything inline here rather than using
;;; push and poop.
doover
  dex
  dex
  lda stackbase+5,x
  sta stackbase+1,x
  lda stackbase+6,x
  sta stackbase+2,x
  jmp next

;;; Implements ROT. We do everything inline here rather than using
;;; push and pop.
dorot
  dex               ; make some new space on the stack temporarily
  dex
  lda stackbase+7,x ; first, copy the item from three down on the stack
  sta stackbase+1,x ; into the new space
  lda stackbase+8,x ; so, 7/8 -> 1/2
  sta stackbase+2,x

  lda stackbase+5,x ; now move everything back
  sta stackbase+7,x ; first, 5/6 -> 7/8
  lda stackbase+6,x
  sta stackbase+8,x
  lda stackbase+3,x ; then 3/4 -> 5/6
  sta stackbase+5,x
  lda stackbase+4,x
  sta stackbase+6,x
  lda stackbase+1,x ; then 1/2 -> 3/4
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x

  jmp drop1cell
;  inx               ; clean up
;  inx
;  jmp next


;;; DOLIT is the run-time code for literal values. Read the contents of
;;; the next parameter as a value to be pushed onto the stack.
;;; We enter with IP indicating the literal value; we increment IP
;;; by two bytes (one cell) so that skips to the next instruction to be
;;; executed. Since this is a very frequently executed routine, 
;;; the push is unrolled rather than doing a jsr push16.
;;; 
;;; (wouldn't "(literal)" be a more consistent name for this?)
dolit
  dex               ; make space on the stack
  dex
  lda (IP)          ; load the value at the instruction pointer
  sta stackbase+1,x
  ldy #1            ; and MSB
  lda (IP),y
  sta stackbase+2,x

incIPby2
.(
  clc
  lda IP            ; increment IP to next cell (which stores the value)
  adc #2
  sta IP
  bcc continue
  inc IP+1
continue
.)

  jmp next
  

;;; dostrlit is the run-time behaviour for S" (ie, string literal).
;;; However, strings are stored as counted-strings but will be processed
;;; as string-plus-count so we need to convert (basically by adding
;;; one to the strong address)
dostrlit
  jsr cslitsub    ; loads c-string address onto the stack
  ;; leaves stackaccess pointing to the base address

  ;; load the string length and push onto stack
  dex
  dex
  lda (stackaccess) ; length byte
  sta stackbase+1,x
  stz stackbase+2,x ; always zero because strlen < 256

  ;; increment string base address by 1 to skip length byte
.(
;  clc  carry definitely clear after clitsub
  lda stackbase+3,x
  adc #1
  sta stackbase+3,x
  bcc skip
  inc stackbase+4,x
skip
.)

  jmp next         ; done

;;; load a counted-string literal
docliteral
  jsr cslitsub
  jmp next

;;; subroutine doing most of the work for cliteral and sliteral.
;;; literal strings are always stored as counted strings. this
;;; puts a literal string on the stack from IP, which is what
;;; cliteral needs; sliteral will then take the count and turn
;;; it into a new stack value
cslitsub
  ;; push address via stackaccess because we're going to use
  ;; that later
  lda IP           ; IP points to the address of counted string
  sta stackaccess  ; before store in stackaccess
  lda IP+1
  sta stackaccess+1
  jsr push16       ; add to the data stack
  
  lda (IP)         ; load the count
  inc              ; add one to get number of bytes to skip
  clc              ; bump IP past the string constant
  adc IP
  sta IP
.(
  bcc skip
  inc IP+1
skip
.)
;  lda IP+1
;  adc #0
;  sta IP+1

  rts


;;; dovaddr is the internal code for variables... look up the current
;;; XT and use it to find the address reserved for the variable, and
;;; push that. (Similarly this should perhaps be called "(VARIABLE)").
dovaddr
  dex               ; make space on the stack
  dex
;  clc   carry guaranteed clear
  lda XT            ; find the param space, two bytes after the XT
  adc #2
  sta stackbase+1,x ; and store it on top of the stack
  lda XT+1          ; same for MSB
  adc #0
  sta stackbase+2,x
  jmp next

;;; As above, but for constants, so we don't load the address,
;;; but the value.
doloadconst
  dex               ; make some space on the stack
  dex
  ldy #2            ; looking at (XT)+2 (param space)
  lda (XT),y        ; load LSB
  sta stackbase+1,x ; straight onto the stack
  iny
  lda (XT),y        ; MSB
  sta stackbase+2,x
  jmp next          ; done
  


;;; dofetch is the code for "@". Pull an address off the stack and
;;; look up the 16-bit data stored at that address
dofetch
  lda stackbase+1,x ; don't actually pop the address, just grab it
  sta stackaccess
  lda stackbase+2,x
  sta stackaccess+1
  ldy #1
  lda (stackaccess)  ; load MSB and store on stack
  sta stackbase+1,x  ; store back on the stack
  lda (stackaccess),y  ; then LSB
  sta stackbase+2,x
  jmp next

;;; docfetch implements c@ -- same as dofetch but loads just one byte
docfetch
  lda stackbase+1,x ; don't actually pop the address, just grab it
  sta stackaccess
  lda stackbase+2,x
  sta stackaccess+1
  lda (stackaccess) ; grab single byte at the address
  sta stackbase+1,x ; and store in LSB
  stz stackbase+2,x ; set MSB to zero
  jmp next


;;; dostore is the code for "!". Pull an address of the stack as in
;;; dofetch; but store the address pointed to by the next stack
;;; location in it.
dostore
  jsr pop16         ; put address into stackaccess
  ldy #1
  lda stackbase+1,x  ; load LSB off stack and
  sta (stackaccess)    ; store at location we popped
  lda stackbase+2,x    ; then for MSB
  sta (stackaccess),y  ; with y=1
;  inx               ; drop the value from the stack
;  inx
;  jmp next
  jmp drop1cell

;;; doplusstore is the code for +!
doplusstore
  jsr pop16         ; put address into stackaccess
;  clc  carry guaranteed clear
  ldy #1
  lda stackbase+1,x  ; load LSB off stack and
  adc (stackaccess)
  sta (stackaccess)    ; store at location we popped
  lda stackbase+2,x    ; then for MSB
  adc (stackaccess),y
  sta (stackaccess),y  ; with y=1
;  inx               ; drop the value from the stack
;  inx
;  jmp next
  jmp drop1cell

;;; cstore implements "c!" - like store but just one byte (LSB from stack)
docstore
  jsr pop16         ; put address into stackaccess
  lda stackbase+1,x ; load LSB off stack and
  sta (stackaccess) ; store at location we popped
;  inx               ; drop the value from the stack
;  inx
;  jmp next
  jmp drop1cell

;;; Turn an integer count of cells into a count of bytes. Since
;;; my cells are two bytes, that means multiplying item on top of
;;; stack by two (shift left).
docells
  asl stackbase+1,x
  rol stackbase+2,x
  jmp next


;;; variable reads the next word from input and allocates space
;;; for it in the dictionary as a variable (ie with the "dovaddr"
;;; code).
dovariable
  clc               ; indicates we want create to update DT
  jsr createsub     ; use CREATE to set up new dictionary entry

  ;; set code to dovaddr
  dex
  dex
  lda #<dovaddr
  sta stackbase+1,x
  lda #>dovaddr
  sta stackbase+2,x
  jsr commasub

  ; bump twice more to allow parameter space for storage
incDPby2
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  jmp next


;;; code for VALUE -- a cross between variable and constant
dovalue
  clc               ; indicates we want create to update DT
  jsr createsub     ; use CREATE to set up new dictionary entry

  ;; set code to dovaddr
  dex
  dex
  lda #<doloadconst
  sta stackbase+1,x
  lda #>doloadconst
  sta stackbase+2,x
  jsr commasub      ; compiles code address
  jsr commasub      ; take value off stack, compile it as value of value
  jmp next


;;; create a new entry in the dictionary using the next word given
;;; in the input stream. This relies on createsub to do much of the
;;; manipulation; that code is also shared with dovariable, doconstant,
;;; and docolon. The word returns the next available storage location.
docreate
  clc               ; indicates that create should update DT
  jsr createsub

  dex
  dex
  lda #<dovaddr
  sta stackbase+1,x
  lda #>dovaddr
  sta stackbase+2,x
  jsr commasub

  jmp next


;;; this subroutine adds a new entry to the dictionary. On exit,
;;; DT has been updated to the new entry, and DP points to the next
;;; available byte, which should be for the code field for the entry.
;;; Whatever calls createsub has to finish the job by adding a code
;;; field at DP.
;;;
;;; whether or not DT is updated depends on the carry flag (clear for
;;; yes and set for no).
createsub
  php               ; preserve the carry flag
  jsr readnext      ; get next word from input buffer into WORD
 
  ;; copy word from WORD
  lda WORD          ; first, copy the count
  sta (DP)
  tay               ; store count in Y
.(
copynext            ; now copy the rest of the word, backwards
  lda WORD,y        ; copy Yth letter
  sta (DP),y        ; store it in dictionary space
  dey               ; count down to 0
  bne copynext
.)

  lda (DP)          ; set Y to next available byte offset
  tay
  iny

  ;; set link to location pointed to by DT
  lda DT
  sta (DP),y
  iny
  lda DT+1
  sta (DP),y
  iny

.(
  plp               ; retreive the carry flag
  bcs continue      ; skip to end if carry is set
  ;; set DT to new top entry, the one we've just created here
  lda DP
  sta DT
  lda DP+1
  sta DT+1
continue
.)

.(
  ;; inc DP by Y
  clc
  tya
  adc DP
  sta DP
  bcc done
  inc DP+1
done
.)
  rts


;;; constant reads the next word from input and allocates space
;;; for it in the dictionary as a constant (just like variable
;;; above, except that the code will do something different).
doconstant
  clc               ; signals that create should update DT
  jsr createsub     ; use CREATE to set up new dictionary entry

  dex
  dex
  lda #<doloadconst
  sta stackbase+1,x
  lda #>doloadconst
  sta stackbase+2,x
  jsr commasub      ; compile doconstant
  jsr commasub      ; now compile constant from stack

  jmp next


;;; TO reads a name, resolves it to a VALUE, and updates the value
;;; stored there to the number on the stack
doto
  jsr readnext
  jsr dmatchword

  lda DPTR+1
  bne toproceed
toabort
  lda #$20
  jsr puta
  jsr printword
  jmp abortnotdef

toproceed
  ;; DPTR points at the dictionary entry? find the parameter space
  clc
  lda (DPTR)
  adc DPTR
  sta SCRATCH
  lda DPTR+1
  adc #0
  sta SCRATCH+1

  clc
  lda SCRATCH
  adc #5            ; one byte for length, two for link, two for code
  sta SCRATCH
.(
  bcc skip
  inc SCRATCH+1
skip
.)

  lda STATE
  bit #COMPILE
  beq nocompileto

  ;; compile code to push address onto the stack
  dex
  dex
  lda SCRATCH
  sta stackbase+1,x
  lda SCRATCH+1
  sta stackbase+2,x
  jsr compilelit

  ;; compile in dostore
  dex
  dex
  lda #<dostorecode
  sta stackbase+1,x
  lda #>dostorecode
  sta stackbase+2,x
  jsr commasub
  jmp next

nocompileto
  ldy #1
  lda stackbase+1,x
  sta (SCRATCH)
  lda stackbase+2,x
  sta (SCRATCH),y
  inx
  inx
  jmp next



;;; dohere implements "HERE" and just returns the pointer to the next
;;; available dictionary spot.
dohere
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16
  jmp next


;;; ALLOT takes a number of bytes and bumps DP, which makes that many
;;; bytes available to whatever is at the top of the dictionary. It's
;;; used to allocate array space to variables.
doallot
;  clc   carry always clear on entry
  lda DP
  adc stackbase+1,x
  sta DP
  lda DP+1
  adc stackbase+2,x
  sta DP+1
  jmp drop1cell


;;; Leave the system after printing a termination message. This
;;; just ends with an RTS, which should take us back to the monitor
;;; if we were called that way, or will crash things if we weren't,
;;; which has the same effect!
dobye
  lda #<exitmsg
  sta PRINTVEC
  lda #>exitmsg
  sta PRINTVEC+1
  jsr printvecstr
  rts               ; return to whatever started FORTH

;;; rcopy (for the Forth word "R") -- copy top of R stack onto data stack
;;; this code also implements I (since it's the same thing).
dorcopy
  dex               ; make space on user stack
  dex
  ldy #1
  lda (RP),y        ; LSB of top value on return stack
  sta stackbase+1,x ; add to user stack
  iny
  lda (RP),y        ; and then again for MSB
  sta stackbase+2,x
  jmp next


;;; j copies immediately outer loop value (basically, third item down
;;; on the return stack)
doj
  dex               ; make space on user stack
  dex
  ldy #5            ; get data from bytes 5 and 6 (third value down)
  lda (RP),y        ; LSB of value on return stack
  sta stackbase+1,x ; add to user stack
  iny
  lda (RP),y        ; and then again for MSB
  sta stackbase+2,x
  jmp next


;;; k copies second outer loop value (basically, fifth item down
;;; on the return stack)
dok
  dex               ; make space on user stack
  dex
  ldy #9            ; get data from bytes 9 and 10 (fifth value down)
  lda (RP),y        ; LSB of value on return stack
  sta stackbase+1,x ; add to user stack
  iny
  lda (RP),y        ; and then again for MSB
  sta stackbase+2,x
  jmp next


;; dotor (for the Forth word ">R" -- move from top of stack onto r-stack
;;;
dotor
  ;jsr pop16
  ;jsr rpush
  lda stackbase+2,x
  sta (RP)
  dec RP
  lda stackbase+1,x
  sta (RP)
  dec RP            ; BUG presumes that RP doesn't roll over page boundary
  jmp drop1cell


;; dofromr (for Forth word "R>" -- move from r-stack to top of stack
;;;
dofromr
;  jsr rpull
  dex
  dex
  inc RP
  lda (RP)
  sta stackbase+1,x
  inc RP
  lda (RP)
  sta stackbase+2,x
  jmp next

;;; docolon implements the colon-word... basically, acts like
;;; variable in that it opens up a dictionary word, althogh this
;;; time for a dolist definition. Also, it sets the compile flag.
;;;
;;; NB things will go wrong if we enconter a colon inside a colon
;;; definition or start to process variables or something. We presume
;;; that nothing is going to mess with DP while compilation is in
;;; progress.
;;;
docolon
  ;; first, set the compiler flag
  lda #$FF
  sta STATE

  lda DP            ; cache the address of the word we're now compiling
  sta CWORD         ; we wait until we're done (dosemic) before we update
  lda DP+1          ; the top-of-dictionary pointer
  sta CWORD+1

  ;; use CREATE to add a new entry to the dictionary
  sec               ; signals that create shouldn't update DT
  jsr createsub

  dex
  dex
  lda #<dolist
  sta stackbase+1,x
  lda #>dolist
  sta stackbase+2,x
  jsr commasub       ; compile in the dolist code pointer

  jmp next           ; not sure which of these is right...


;;; do-semi-colon, ie, tidy up when we're finishing compiling a word
;;;
dosemic
  ;; turn off the compiler
  stz STATE

  ;; add call to exit at the end of the entry
  dex
  dex
  lda #<exitcode
  sta stackbase+1,x 
  lda #>exitcode
  sta stackbase+2,x
  jsr commasub

  ;; set DT to new top entry, the word we've just finished compiling
  ;; BUG this may be unnecessary now, handled by CREATE?
  lda CWORD
  sta DT
  lda CWORD+1
  sta DT+1

  jmp next


;;; docomma is the basic compilation mechanism.
docomma
  jsr commasub
  jmp next

;;; add value from the stack to the dictionary at DP and inc DP
commasub
  ldy #1
  lda stackbase+1,x
  sta (DP)
  lda stackbase+2,x
  sta (DP),y

.(
  clc
  lda DP
  adc #2
  sta DP
  bcc done
  inc DP+1
done
.)

  inx
  inx
  rts

;;; Do dot-quote. I'm not entirely happy with my solution for this yet.
;;; This word has three different context-dependent behaviors:
;;; 1. when we are compiling (determined by compiler flag), assemble
;;;    string from the text stream and compile it into the word.
;;; 2. when we are called as part of a regular execution cycle, print
;;;    the word that's compiled in following this instruction.
;;; 3. when we are running in the interpreter, as determined by IP
;;;    pointing to the dummy word, assemble the string that follows
;;;    in the input buffer and print it.
dodotqu
.(
  ;; are we compiling?
  lda STATE
  beq nocompile

  ;; Yes. compile it (case 1)
  ;; first, add in the execution word
  dex
  dex
  lda #<dotquotecode
  sta stackbase+1,x
  lda #>dotquotecode
  sta stackbase+2,x
  jsr commasub

  ;; next, assemble the string on the PAD
  jsr assemblestr

  ;; now we copy it into space where we are comping, pointed to by DP.
  lda PAD           ; first, copy the length
  sta (DP)

.(
  tay               ; now copy the rest of the string (backwards)
charloop
  lda PAD,y
  sta (DP),y
  dey
  bne charloop
.)

  ;; now update DP to account for the string
  clc
  lda PAD           ; that's the length count for the string
  inc               ; add one for the count byte
  adc DP            ; bump DP by that many bytes
  sta DP
  lda DP+1
  adc #$0
  sta DP+1

  jmp next          ; and proceed. we're done.

nocompile
  ;; are we interactive?
  ;; we can tell if IP points to dummyexit
  lda IP
  cmp #<dummyexit
  bne nointerp
  lda IP+1
  cmp #>dummyexit
  bne nointerp

  ;; Yes, so we need the interactive behaviour (case 3)

  ;; first. assemble the string to be printed
  jsr assemblestr

  ;; now print it
  ;; but first, write in a space over the length indicator,
  ;; which we don't need because it's null-terminated
  lda #$20
  sta PAD

  ldy #0
.(
next_char
  lda PAD,y
  beq done
  jsr puta
  iny
  bra next_char
done
.)

  jmp next          ; we're done so proceed to next instruction

nointerp
  ;; Finally, this is the regular behavior (case 2). We're executing
  ;; from a compiled word. So IP points to a counted string. Print
  ;; it, and increment the instruction pointer appropriately.

  lda #$20
  jsr puta

  phx               ; save X, since we're about to use it
  lda (IP)          ; load the string length
  tax               ; transfer to X. X counts down as Y counts up
  ldy #1

  ;; now print X characters 
.(
next_char
  lda (IP),y
  jsr puta
  iny
  dex
  bne next_char
done
.)

  plx               ; restore X

  ;; finally, update the instruction pointer
  ;; Y is the number of characters plus one (because of the last iny)
  ;; so that's actually just the right number to add to the IP.
.(
  tya               ; transfer Y to A and add it to IP
  clc
  adc IP            ; LSB
  sta IP
  bcc continue
  inc IP+1          ; MSB in case of carry
continue
.)
.)

  jmp next          ; continue to the next instruction


;;; This is the compiler behavior for ABORT". It compiles
;;; doabortqrt and then jumps to the shared compile-string
;;; operation
doabortq
  dex
  dex
  lda #<doabortqcode
  sta stackbase+1,x
  lda #>doabortqcode
  sta stackbase+2,x
  jsr commasub
  bra compilestr

;;; When compiled, S" compiles dostrlit and an inline string
;;; constant. When interpreted, it stashes the string in a 
;;; temporary space and leaves a pointer on the stack. Strings
;;; represented at the user level as caddr and u.
dosquote
  lda STATE
  beq interpsq

  dex
  dex
  lda #<sliteralcode
  sta stackbase+1,x
  lda #>sliteralcode
  sta stackbase+2,x
  jsr commasub

  ;; the string compilation is shared with abort" and c"
compilestr

  jsr assemblestr   ; read and assemble string from input

  ;; now we copy it into space where we are comping, pointed to by DP.
  ldy PAD           ; first, copy the length
  sta (DP)

.(
  tay               ; now copy the rest of the string (backwards)
charloop
  lda PAD,y
  sta (DP),y
  dey
  bne charloop
.)

  ;; now update DP to account for the string
  clc
  lda PAD           ; that's the length count for the string
  inc               ; add one for the count byte
  adc DP            ; bump DP by that many bytes
  sta DP
  lda DP+1
  adc #$0
  sta DP+1

  jmp next          ; done

interpsq
  jsr tempcstr      ; assemble counted string and leave addr on stack

  ;; turn the c-string on the stack to an s-string
  ;; first, add a word for the byte count
  dex
  dex
  lda stackbase+3,x
  sta stackaccess
  lda stackbase+4,x
  sta stackaccess+1
  lda (stackaccess)
  sta stackbase+1,x
  stz stackbase+2,x

  ;; now add one to the address (to skip the count byte)
.(
  clc
  lda stackbase+3,x
  adc #1
  sta stackbase+3,x
  bcc skip
  inc stackbase+4,x
skip
.)

  jmp next

;;; like S" but with counted strings. This is easier because we
;;; use counted strings internally.
docquote
  lda STATE
  beq interpcq

  dex
  dex
  lda #<cliteralcode
  sta stackbase+1,x
  lda #>cliteralcode
  sta stackbase+2,x
  jsr commasub
  bra compilestr    ; jump to shared code

interpcq
  jsr tempcstr
  jmp next

;;; this code is shared by the interpreter part of both s" and c".
;;; assembles a counted string in the temporary area and leave the
;;; address on the stack.
tempcstr
  jsr assemblestr   ; assemble string onto PAD
  ldy PAD           ; copy string length
  sty TEMPSTR

.(
charloop            ; copy string contents (backwards from end)
  lda PAD,y
  sta TEMPSTR,y
  dey
  bne charloop
.)

  ;; leave address on the stack, adding one to skip the count byte
  dex
  dex
  lda #<TEMPSTR
  sta stackbase+1,x
  lda #>TEMPSTR
  sta stackbase+2,x

  rts



;;; Read text from the input buffer up until a single quote mark
;;; and assemble it onto the PAD. At the end, we'll have a string
;;; that is both counted and null-terminated. This is used in both
;;; compile mode and run mode of dotquote and in S".
assemblestr

  ;; first, set up the PAD ptr
  lda #<PAD
  sta PADPTR
  lda #>PAD
  sta PADPTR+1

.(
  ;; read the next word into WORD
continue
  jsr readnext

  ;; is it a closing quote? count of 1, char is $22
  lda WORD
  cmp #$01          ; check the string length
  bne assemble
  lda WORD+1        ; we know it's a single-character string
  cmp #$22          ; check the single character
  beq finished

assemble
  ;; concatenate onto the string we're assembling at PAD
  lda #$20          ; space
  sta (PADPTR)
  ldy WORD          ; the character count
.(
nextchar
  lda WORD,y
  sta (PADPTR),y    ; Y is off-by-one but it's okay (leading space)
  dey
  bne nextchar
.)

  ;; update PADPTR
.(
  lda WORD          ; length of this most recent word
  inc               ; plus leading space
  clc
  adc PADPTR
  sta PADPTR        ; update the pointer
  bcc skipmsb
  inc PADPTR+1      ; in case we generated a carry...
skipmsb
.)

  ;; update count
  sec               ; BUG this will stop working if PAD crosses page boundary
  lda PADPTR
  sbc #<PAD
  dec               ; subtract one (don't count the count byte itself)
  sta PAD

  ;; if the word ended with a quote mark, then remove it and
  ;; finish. otherwise, loop
  ldy WORD
  lda WORD,y
  cmp #$22
  bne continue

  sec               ; move PADPTR back by one character
  lda PADPTR        ; to remove the quote mark
  sbc #1
  sta PADPTR
  lda PADPTR+1
  sbc #0
  sta PADPTR+1
  dec PAD           ; decrement count by one
.)
finished
  ;; add a null at the end of the string
  lda #$00
  sta (PADPTR)

  rts


;;; discardcomment reads from the input buffer until it finds
;;; the end-of-comment marker. Somewhat like assemblestr except
;;; that there is no assembly.
discardcomment
.(
continue
  jsr readnext

  ldy WORD          ; get character count
  lda WORD,y        ; get last character
  cmp #$29          ; 0x29 is closing parenthesis
  bne continue

  rts
.)


;;; dotype implements TYPE. Reads a count and a string address from the
;;; stack and prints the number of characters indicated in the count.
dotype
  lda stackbase+1,x
  sta SCRATCH       ; put count in SCRATCH (only one byte)
  inx
  inx
  jsr pop16         ; fetch the string address
  lda SCRATCH
  beq endtype       ; stop now if the count was 0

  ldy #0
typenext
  lda (stackaccess),y
  jsr puta
  iny
  cpy SCRATCH
  bne typenext

endtype
  jmp next


;;; doaccept implements ACCEPT
;;; ( caddr n1 -- n2 )
;;; n1 is the maximum number of characters to read; n2 is the number
;;; actually read
;;; BUG fix this wrt readtermline...
doaccept
.(
  lda stackbase+3,x
  sta SCRATCH
  lda stackbase+4,x
  sta SCRATCH+1
nextchar
  jsr readchar
  cmp #$08
  beq backspace
  cmp #$0D
  beq newline
  sta (SCRATCH)
  jsr puta
;  clc carry always clear here
  lda SCRATCH
  adc #1
  sta SCRATCH
  bcc doneadd
  inc SCRATCH+1
doneadd
  lda SCRATCH       ; if char limit not reached, then
  cmp stackbase+1,x ; branch back to fetch next character
  bne nextchar
  lda SCRATCH+1
  cmp stackbase+2,x
  bne nextchar
  ;; otherwise, hit limit so fall through
newline
  jsr swap16        ; swap parameters
  sec               ; calculate length of string read, and store it
  lda SCRATCH       ; over input length as return value on stack
  sbc stackbase+1,x
  sta stackbase+3,x
  lda SCRATCH+1
  sbc stackbase+4,x
  sta stackbase+2,x
  inx               ; clean up the stack
  inx
  jmp next
backspace
  lda SCRATCH       ; are we still at the start of the string?
  cmp stackbase+3,x
  bne continue
  lda SCRATCH+1
  cmp stackbase+4,x
  beq nextchar      ; if so, ignore the backspace
continue
  lda #$08
  jsr puta
  sec
  lda SCRATCH
  sbc #1
  sta SCRATCH
  lda SCRATCH+1
  sbc #0
  sta SCRATCH+1
  bra nextchar
.)


;;; 0branch is an internal word used for conditionals. Test top of stack,
;;; and if false, add the next parameter (ie instruction offset) to the
;;; IP. When we come in, the IP is pointing to the branch address,
;;; so that is the position from which the offset is to be calculated.
dozerobra
  jsr pop16         ; pull value off the top of the stack
  lda stackaccess   ; test for zero
  ora stackaccess+1
  beq dobranch      ; if it's zero, then jump to branch code

nonzero
  ;; otherwise we will continue with processing, but first,
  ;; increment IP to skip the branch offset.
  jmp incIPby2

;;; dobranch is used by ELSE; does an immediate branch. So, it's just
;;; like 0branch if the top stack value is 0; in fact, 0branch calls
;;; this code in that case.
;;;
;;; I used to use relative addressing for branches, which is the
;;; traditional implementation strategy. Now switching over to use
;;; absolute.
dobranch
  ldy #1  
  lda (IP),y        ; load offset and cache it on the stack
  pha               ; do MSB first because we want to pull
  lda (IP)          ; LSB first
;  pha
;  clc  carry always clear here
;  pla               ; now add the cached offset to the IP
;  adc IP
;  sta IP
;  pla
;  adc IP+1
;  sta IP+1
  sta IP
  pla
  sta IP+1

  jmp next


;;; doif is an immediate word that compiles IF.
;;; compile it into a 0bra, and put the address of the branch word
;;; onto the stack. Pesume that THEN will later come back
;;; and fix up the address
;;;
doif
.(

  dex
  dex
  lda #<zerobracode
  sta stackbase+1,x
  lda #>zerobracode
  sta stackbase+2,x
  jsr commasub      ; compile zerobracode

  ;; put that addr on stack so that ELSE or THEN can find it later
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  ;; add the IFELSEFLAG to the stack
  lda #IFELSEFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

  ;; bump DP by two again (to move to next instruction space)
  ;; this leaves open address in compiled code for branch address
  ;; to be filled in later.
  jmp incDPby2

.)


;;; This is the compiler behavior for THEN. We look on the stack for
;;; address of the branch offset, then calculate the offset and
;;; write it in.
;;;
dothen
.(

  ;; pop the flag from the stack and make sure it's an IFELSEFLAG
  jsr pop16
  lda stackaccess
  cmp #IFELSEFLAG
  beq thenproceed

  jmp abortnest

thenproceed
  ;; take the current DP pointer, and subtract from it the value on
  ;; the stack. The result is the offset that should be stored in
  ;; the word pointed to by the item on the stack. Pop it from the stack.

  jsr pop16         ; pop branch address into stackaccess

;  sec               ; calculate offset
;  lda DP
;  sbc stackaccess
;  sta SCRATCH
;  lda DP+1
;  sbc stackaccess+1
;  sta SCRATCH+1

;  lda SCRATCH       ; write it into the branch instruction
  lda DP
  sta (stackaccess)
  ldy #1
;  lda SCRATCH+1
  lda DP+1
  sta (stackaccess),y
  bra done

done
  jmp next          ; done. proceed to next instruction.
.)


;;; doelse is the compiler behavior for ELSE. Like THEN, it updates
;;; the prior branch address that's been left on the stack. Like IF,
;;; it compiles in a branch (not 0branch this time) and leaves an address
;;; on the stack for THEN to fill in.
;;;
doelse
.(

  ;; First, pop the flag off the stack and ensure it's the IFELSEFLAG.
  jsr pop16
  lda stackaccess
  cmp #IFELSEFLAG
  beq elseproceed
  jmp abortnest
  
elseproceed

  ;; Next, compile in the branch instruction and keep a copy of
  ;; the branch address to be put on the stack in a moment.
  ;; this way, a successful IF clause should hit a branch that causes
  ;; it to jump to the end (skipping the ELSE clause)
  dex
  dex
  lda #<branchcode
  sta stackbase+1,x
  lda #>branchcode
  sta stackbase+2,x
  jsr commasub      ; compile in branch code

  lda DP            ; cache this address for a moment
  sta SCRATCH+2
  lda DP+1
  sta SCRATCH+3

.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  ;; Next, do the THEN-like behavior and update the address left by IF.
  ;; Take the current DP pointer, and subtract from it the value on
  ;; the stack. The result is the offset that should be stored in
  ;; the word pointed to by the item on the stack. Pop it from the stack.

  jsr pop16         ; pop branch address into stackaccess

;  sec               ; calculate offset
;  lda DP
;  sbc stackaccess
;  sta SCRATCH
;  lda DP+1
;  sbc stackaccess+1
;  sta SCRATCH+1

;  lda SCRATCH       ; write it into the branch instruction
  lda DP
  sta (stackaccess)
  ldy #1
;  lda SCRATCH+1
  lda DP+1
  sta (stackaccess),y

  ;; Finally, put that deferred branch instruction address onto
  ;; the stack
  lda SCRATCH+2
  sta stackaccess
  lda SCRATCH+3
  sta stackaccess+1
  jsr push16

  ;;; and replace the flag.
  lda #IFELSEFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

  jmp next

;nocompile
;  jmp abortcompile
.)

;;; dobegin is compiler behavior for BEGIN. It simply pushes the current
;;; DP onto the user stack, so that UNTIL can find it later and use it
;;; to calculate the offset.
dobegin
.(

  ;; add the current instruction location to the stack
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  ;; add a flag to signal that this is for a BEGIN
  lda #BEGINFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

;nocompile
  jmp next
.)

;;; dountil is the compiler behaviour for UNTIL. It compiles a 0branch
;;; with the offset calculated from the value left on the stack by
;;; dobegin.
dountil
.(
  ;; pop the flag off the stack to make sure it's a BEGINFLAG
  jsr pop16
  lda stackaccess
  cmp #BEGINFLAG
  beq proceed
  jmp abortnest
  
proceed
  ;; compile the zerobranch and update DP.
  dex
  dex
  lda #<zerobracode
  sta stackbase+1,x
  lda #>zerobracode
  sta stackbase+2,x
  jsr commasub

  ;; now write address in as a parameter to the branch.
  jsr commasub

  jmp next
.)


;;; dodo is the compiler behavior for DO (the runtime behavior is
;;; doparendo). It compiles in (do) and then pushes the next instruction
;;; address (the loop target) onto the stack along with a flag.
dodo
  ;; compile (do)
  lda #<parendocode
  sta (DP)
  ldy #1
  lda #>parendocode
  sta (DP),y

doshared            ; entry point for do-query-do below

  ;; increment DP
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; push this address on the stack as the loop target address
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  ;; push a flag to contextualize the item on the stack. LOOP will
  ;; need this in order to distinguish between a DO and a LEAVE.
  lda #DOFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

  jmp next          ; done!

;nocompiledo
;  jmp abortcompile

;;; doqdo is the compile-time code for ?DO, much of which is shared with
;;; do above.
;doqdo
;.(
;  ;; test if we're compiling
;  lda STATUS
;  bit #COMPILE
;  beq nocompiledo
;
;  ;; compile (do)
;  lda #<parenqdocode
;  sta (DP)
;  ldy #1
;  lda #>parenqdocode
;  sta (DP),y
;
;  jmp doshared
;
; realized that this is wrong. i need a forward branch in the case of
; the null loop. maybe make it look like a leave?


;;; doparendo is the implementation of (DO), the run-time behavior for
;;; DO. It pulls two values off the data stack (the loop limit and the
;;; loop index) and places them on the return stack (in inverted order).
doparendo
  lda stackbase+4,x ; MSB of limit
  sta (RP)
  dec RP
  lda stackbase+3,x ; LSB of limit
  sta (RP)
  dec RP
  lda stackbase+2,x ; MSB of index
  sta (RP)
  dec RP
  lda stackbase+1,x ; LSB of index
  sta (RP)
  dec RP
  jsr close2cells
  jmp next          ; done  


;;; doloop is the compiler behavior for LOOP. It compiles (LOOP) and a
;;; branch address to the address left on the stack.
doloop

  lda #<parenloopcode
  sta (DP)
  ldy #1
  lda #>parenloopcode
  sta (DP),y

looptest
  ;; pop the flag off the stack and check DOFLAG or LEAVEFLAG
  jsr pop16
  lda stackaccess
  cmp #LEAVEFLAG
  beq fixleave
  cmp #DOFLAG
  beq loopcompile
  jmp abortnest

fixleave
  jsr resolvebranch
  ;; there may be multiple LEAVEs, so loop around
  jmp looptest

;; we get here when we have found a DOFLAG on the stack
loopcompile
  ;; increment DP
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; at this point, next address on the stack is the branch address
  ;; so compile it in
  jsr commasub
  jmp next


;;; subroutine to resolve branch addresses left on the stack when
;;; creating control structures. used by LOOP and by REPEAT to handle
;;; LEAVE and WHILE structures respectively.
resolvebranch
  ;; update the address indicated by the value on the stack. it
  ;; should point to the instruction two cells (four bytes) after
  ;; this one, so first, calculate that.
  clc
  lda DP
  adc #4
  sta SCRATCH
  lda DP+1
  adc #0            ; in case of carry
  sta SCRATCH+1

  jsr pop16         ; get the address from the stack
;  sec               ; substract from SCRATCH to get the offset
;  lda SCRATCH
;  sbc stackaccess
;  pha               ; cache LSB
;  lda SCRATCH+1
;  sbc stackaccess+1
  ldy #1
  lda SCRATCH
  sta (stackaccess)
  lda SCRATCH+1
  sta (stackaccess),y ; and write it back into stackaccess
;  pla               ; pull the LSB
;  sta (stackaccess)
  rts


;;; doplusloop implements the compiler behavior for +LOOP. Basically,
;;; it compiles in a different run-timecode address but then jumps
;;; into the LOOP code to do all the calculations of offsets, etc.
doplusloop
.(

  lda #<parplusloopcode
  sta (DP)
  ldy #1
  lda #>parplusloopcode
  sta (DP),y
  bra looptest

  jmp next

;nocompile
;  jmp abortcompile
.)

;;; doparplusloop implements (+LOOP), the runtime code for +LOOP.
;;; much of this will be shared with (LOOP), except that we start
;;; by pulling a value from the stack to do increment.
doparplusloop
  jsr pop16         ; pull the increment value
  ldy #1
  clc               ; and add it to the value at top of r-stack
  lda (RP),y
  adc stackaccess
  sta (RP),y
  iny
  lda (RP),y
  adc stackaccess+1
  sta (RP),y

  ;; for a positive loop increment, we can just use the
  ;; same code as (LOOP). Check the sign of the increment

  bit stackaccess+1 ; test top bit of increment value
  bpl testandloop   ; branch when N=0 to shared code with (LOOP)

  ;; it's negative, so we have to do our own test
  ;; grab the loop limit and stash it in SCRATCH+2/3.
  ldy #3
  lda (RP),y
  sta SCRATCH+2
  iny
  lda (RP),y
  sta SCRATCH+3

  ;; compare index to the loop limit
.(
  ldy #1
  sec
  lda (RP),y        ; LSB of index
  sbc SCRATCH+2     ; LSB of limit
  iny
  lda (RP),y        ; MSB
  sbc SCRATCH+3
  sbc (RP),y
;  bmi noloop        ; minus if limit > index
  bpl takeloop
.)
  jmp noloop


;;; doparenloop implements (LOOP), which is the run-time code for LOOP.
;;; increment and test index and optionally branch back to address
;;; provided.
doparenloop
  ;; increment the loop index in-place
.(
  ldy #1
;  clc  carry always clear here
  lda (RP),y        ; no (),y mode for INC, sadly!
  adc #1
  sta (RP),y
  bcc continue
  iny
  lda (RP),y
  adc #0
  sta (RP),y
continue
.)

testandloop         ; also entry point for (+LOOP)
  ;; grab the loop limit and stash it in SCRATCH+2/3.
  ldy #3
  lda (RP),y
  sta SCRATCH+2
  iny
  lda (RP),y
  sta SCRATCH+3

  ;; compare index to the loop limit
.(
  ldy #1
  sec
  lda (RP),y        ; LSB, index
  sbc SCRATCH+2     ; compared to LSB, limit
  iny
  lda (RP),y
  sbc SCRATCH+3
  bpl noloop
.)

takeloop
  ;; take branch address from (IP), make it the new IP
  ldy #1
  lda (IP),y
  pha
  lda (IP)
  sta IP
  pla
  sta IP+1
  jmp next

noloop
  ;; drop values from the return stack by adding 4 (4 bytes, 2 cells)
  ;; to the RP. We assume RP is all on the same page and ignore MSB.
  clc
  lda RP
  adc #4
  sta RP
  jmp incIPby2


;;; Doleave implements the compile-time of LEAVE. It compiles
;;; a branch, leaving an offset to be resolved later by LOOP.
doleave
  dex
  dex
  lda #<parenleavecode
  sta stackbase+1,x
  lda #>parenleavecode
  sta stackbase+2,x
  jsr commasub

  ;; we want to push this onto the stack BUT we need to "tuck" it
  ;; under any interleaved IF/ELSE loops. so we need to look down
  ;; the stack until we find the right place to put it, copy everything
  ;; else, and then insert the address and the flag.
  jsr open2cells    ; first, make space for two new cells on the stack

  txa               ; copy X into Y. we'll use Y as the index
  tay               ; for looping down the stack

lookforflag
  cpy #128          ; check if Y has looped around
  bmi abortleave    ; in which case, we need to abort
  lda stackbase+5,y ; is top item a DOFLAG?
  cmp #DOFLAG
  beq foundflag     ; yes
  lda stackbase+5,y ; no, so we copy two cells up and try again
  sta stackbase+1,y
  lda stackbase+6,y
  sta stackbase+2,y
  lda stackbase+7,y
  sta stackbase+3,y
  lda stackbase+8,y
  sta stackbase+4,y
  iny               ; skip Y ahead to the next pair of cells
  iny
  iny
  iny
  bra lookforflag

abortleave
  jmp abortnest

foundflag
  ;; we have found the DOFLAG. use the two cells "above" this for our
  ;; address and flag
  lda DP            ; DP goes onto the stack
  sta stackbase+3,y
  lda DP+1
  sta stackbase+4,y
  lda #LEAVEFLAG
  sta stackbase+1,y
  lda #0
  sta stackbase+2,y

;  ;; increment DP to point to next instruction address
;.(
;  clc
;  lda DP
;  adc #2
;  sta DP
;  bcc continue
;  inc DP+1
;continue
;.)
;
;  jmp next
  jmp incDPby2


;;; doparenleave is the implementation of (leave), the run-time behavior
;;; for LEAVE. It basically just does a branch, but first, it pops
;;; some values off the return stack.
doparenleave
;  clc carry always clear here
  lda RP
  adc #4
  sta RP
  jmp dobranch


;;; dowords. Print out the words defined in the dictionary (including
;;; variables).
dowords
.(
  jsr crlf

  ;; set up search by initializing dictionary pointer. reuse the
  ;; same pointer (DPTR) used in matching (tick).
  lda DT
  sta DPTR
  lda DT+1
  sta DPTR+1

nextentry
  ;; have we run out of dictionary entries? (when DPTR is $0000)
  lda DPTR
  bne printit
  lda DPTR+1
  beq done

printit
  ldy #0
  lda (DPTR),y
  and #%00011111    ; mask off the tags
  phx
  tax
  ldy #1
nextchar
  lda (DPTR),y
  jsr puta
  iny
  dex
  bne nextchar

  lda #$20          ; end with a space
  jsr puta
  plx

  ;; move on to the next entry
  ;;
  lda (DPTR)        ; get word length...
  and #%00011111    ; mask off the tags
  tay               ; store in Y, and add one...
  iny               ; for the pointer to the next entry
  lda (DPTR),y      ; update DPTR to point to next entry
  pha
  iny
  lda (DPTR),y  
  sta DPTR+1
  pla
  sta DPTR
  bra nextentry

done
  jmp next
.)


;;; implements MAX (16-bit)
domax
.(
  ;; compare most significant bytes
  lda stackbase+2,x
  cmp stackbase+4,x
  beq testother
  bpl topofstack
  bra nextonstack
  
  ;; only in the case where they were equal, test less significant
testother
  lda stackbase+1,x
  cmp stackbase+3,x
  bmi nextonstack

  ;; item on the top of the stack was larger. copy it over
  ;; lower item, and pop top item off
topofstack
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  ;; and just fall through to the pop below

  ;; lower item on stack is max. just pop off the top.
nextonstack
  inx
  inx
.)

donemax
  jmp next


;;; implements MIN (16-bit)
domin
.(
  ;; compare most significant bytes
  lda stackbase+2,x
  cmp stackbase+4,x
  beq testother
  bmi topofstack
  bra nextonstack
  
  ;; only in the case where they were equal, test less significant
testother
  lda stackbase+1,x
  cmp stackbase+3,x
  bpl nextonstack

  ;; item on the top of the stack was larger. copy it over
  ;; lower item, and pop top item off
topofstack
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  ;; and just fall through to the pop below

  ;; lower item on stack is max. just pop off the top.
nextonstack
  inx
  inx
.)

donemin
  jmp next


;;; implements KEY -- read a character from the terminal and
;;; leave its ascii value on the stack
dokey
  jsr readchar
  sta stackaccess
  stz stackaccess+1
  jsr push16

  jmp next

;;; implements KEY? -- returns true/false signalling whether there
;;; is keyboard input waiting to be read.
dokeyqu
  dex
  dex
  lda ACIA_STATUS
  and #$08
  beq nokey
  jmp settrue
nokey
  jmp setfalse


;;; AND, OR, XOR
;;;
doand
  lda stackbase+1,x
  and stackbase+3,x
  sta stackbase+3,x
  lda stackbase+2,x
  and stackbase+4,x
  sta stackbase+4,x
;  inx
;  inx
;  jmp next
  jmp drop1cell

door
  lda stackbase+1,x
  ora stackbase+3,x
  sta stackbase+3,x
  lda stackbase+2,x
  ora stackbase+4,x
  sta stackbase+4,x
;  inx
;  inx
;  jmp next
  jmp drop1cell

doxor  
  lda stackbase+1,x
  eor stackbase+3,x
  sta stackbase+3,x
  lda stackbase+2,x
  eor stackbase+4,x
  sta stackbase+4,x
;  inx
;  inx
;  jmp next
  jmp drop1cell


;;; implements 0=. Faster than "0 =" and works in place.
;;; uses setfalse and settrue for result, which requires that X
;;; be set appropriately for the result before we jump
doeqlzero
.(
  lda stackbase+1,x ; test for zero
  ora stackbase+2,x
  beq iszero        ; yes?
notzero
  jmp setfalse
iszero              ; yes it's zero
  jmp settrue
.)

;;; implements TRUE
dotrue
  dex
  dex
settrue
  lda #$ff
  sta stackbase+1,x
  sta stackbase+2,x
  jmp next


;;; implements FALSE
dofalse
  dex
  dex
setfalse
  stz stackbase+1,x
  stz stackbase+2,x
  jmp next


;;; 1+, 1-, 2+, 2-
;;;
do1plus
.(
;  clc carry always clear here
  inc stackbase+1,x
  bne done
  inc stackbase+2,x
done
  jmp next
.)

do1minus
.(
  sec
  lda stackbase+1,x
  sbc #1
  sta stackbase+1,x
  bcs done
  dec stackbase+2,x
done
  jmp next
.)

do2plus
.(
;  clc carry always clear here
  lda stackbase+1,x
  adc #2
  sta stackbase+1,x
  bcc done
  inc stackbase+2,x
done
  jmp next
.)

do2minus
.(
  sec
  lda stackbase+1,x
  sbc #2
  sta stackbase+1,x
  bcs done
  dec stackbase+2,x
done
  jmp next
.)

doinvert
  lda stackbase+1,x
  eor #$ff
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  sta stackbase+2,x
  jmp next

;;; Implements compile-time behaviour for WHILE (inside BEGIN/REPEAT).
;;; Compiles to 0branch and then leaves offset address on the stack.
dowhile
  dex
  dex
  lda #<zerobracode ; compile 0branch
  sta stackbase+1,x  
  lda #>zerobracode
  sta stackbase+2,x
  jsr commasub

  lda DP            ; push the address of the branch offset
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  lda #WHILEFLAG    ; push a flag to contextualize that address
  sta stackaccess
  stz stackaccess+1
  jsr push16

  jmp incDPby2


;;; compile-time behaviour for repeat is to fix up any stacked
;;; WHILE calls and branch back to the last BEGIN
dorepeat
.(

  lda #<branchcode
  sta (DP)
  ldy #1
  lda #>branchcode
  sta (DP),y

reptest
  ;; pop the flag off the stack and check DOFLAG or LEAVEFLAG
  jsr pop16
  lda stackaccess
  cmp #WHILEFLAG
  beq fixwhile
  cmp #BEGINFLAG
  beq bracompile
  jmp abortnest

fixwhile
  jsr resolvebranch

  ;; may be multiple WHILEs so loop around
  jmp reptest

bracompile
  ;; we get here when we finally hit the BEGIN flag
  ;; increment DP
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; branch destination is on the stack, so compile it in.
  jsr commasub

  jmp next
.)



;;; Implement RECURSE. This is an immediate word, and uses CWORD
;;; (plus an offset) to insert the code address of the word currently
;;; being defined).
dorecurse
.(

;  clc  carry always clear here
  lda CWORD         ; put word address into SCRATCH
  sta SCRATCH
  lda CWORD+1
  sta SCRATCH+1

  lda (CWORD)       ; load length of word string
  inc               ; add one for the length byte
  inc               ; and another two for the link
  inc
;  clc carry still clear
  adc SCRATCH       ; add to address. now scratch will contain
  sta SCRATCH       ; the address of the code word (cfa).
.(
  bcc continue
  inc SCRATCH+1
continue
.)
  lda SCRATCH       ; write the address it at compiler location
  sta (DP)
  ldy #1
  lda SCRATCH+1
  sta (DP),y

;  ;; increment DP
;.(
;  clc
;  lda DP
;  adc #2
;  sta DP
;  bcc continue
;  inc DP+1
;continue
;.)
;
;  jmp next          ; we're done
  jmp incDPby2

;nocompile
;  jmp abortcompile
.)

;;; backslash -- ignore the rest of the line
dobackslsh
.(
  ldy #0
nextchar
  lda (IPTR),y
  beq gotzero
  cmp #$0A
  beq endofline
  cmp #$0D
  beq endofline
  iny
  bra nextchar
gotzero
  ;; if we are reading from terminal or from a buffer, then
  ;; this means the end of the comment. if we are reading from
  ;; a stream, it's more complicated.
  bit SOURCE
  bpl endofline     ; terminal or buffer
  jsr refill
  ;; now test if we are STILL reading from a file (ie didn't hit EOF).
  ;; if so, continue looking for end of line; if not, jump to the end
  bit SOURCE
  bpl skip
  bra dobackslsh
endofline
  clc
  tya
  adc IPTR
  sta IPTR
  bcc skip
  inc IPTR+1
skip
.)
  jmp next


;;; do comment. this is called as an immediate word. it basically
;;; skips ahead in the input buffer until it reads a word that is
;;; terminated by a closing parenthesis.
docomment
  jsr discardcomment
  jmp next


doabs
.(
  lda stackbase+2,x ; is number on stack negative?
  bit #%10000000
  beq endabs        ; no it's not, so we're done

  jmp donegate      ; otherwise, negate it
endabs
.)
  jmp next


donegate
;  clc               ; flip bits and add one to form two's complement
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  jmp next

;;; Implements .S, which prints the stack, mainly for debugging.
;;; Can't mess with X because we need to keep it as a working stack
;;; pointer ('cos we need to put numbers on the top of the stack
;;; to print them!
dodots
  jsr printstacksub
  jmp next

;;; broken out as a subroutine because it may be useful for debugging
printstacksub
.(
  ;; first, cache a copy of the stack pointer
  txa
  sta SCRATCH+8
  ;; then set Y to the bottom of the stack
  ldy #$ff
loop
  cpy SCRATCH+8     ; when we hit the saved stack pointer, stop
  beq done
  dey               ; move to next stack location
  dey
  dex               ; make space on the top of the stack
  dex
  lda stackbase+1,y ; copy from location pointed to by Y
  sta stackbase+1,x ; into new top-of-stack position
  lda stackbase+2,y
  sta stackbase+2,x
  jsr print16s      ; that will also pop the copy from the stack
  bra loop
done
.)
  rts

;;; dotick implements TICK ('). Grabs a word and looks is up in the
;;; dictionary. In the interpreter, leaves the xt on the stack; in
;;; the compiler, compiles it in to the current definition.
dotick
  jsr readnext
  jsr dmatchword

  lda DPTR+1
  bne tickproceed
tickabort
  lda #$20
  jsr puta
  jsr printword
  jmp abortnotdef

tickproceed
.(
  jsr pushxt

  ;; now check -- are we compiling? If so, then compile a literal
  ;; with that value. If not, leave it on the stack.
  lda STATE
  beq nocompile
  jsr compilelit    ; compile in LIT + value
nocompile
done
  jmp next
.)


;;; take the value on the stack and compile it in as a literal
;;; (ie compile dolitcode then the stack value)

compilelit
  dex
  dex
  lda #<dolitcode
  sta stackbase+1,x
  lda #>dolitcode
  sta stackbase+2,x
  jsr commasub      ; compile dolitcode
  jsr commasub      ; compile the pointer
  rts

;;; shared by dotick, dofind, and postpone
pushxt
  dex
  dex
  clc               ; calculate xt. Add length of word, plus one for
  lda (DPTR)        ; the length byte and two for the link
  and #%00011111    ; mask off the status bits
  adc #3            ; max count value is 32, so this won't cause carry
  adc DPTR
  sta stackbase+1,x ; add XT to stack, one byte at a time
  lda DPTR+1
  adc #0            ; in case of carry
  sta stackbase+2,x
  rts

dofind
.(
  jsr pop16
  jsr dmatchstack
  lda DPTR+1
  beq nomatch

  jsr pushxt

  dex               ; space for one more return value
  dex
  ; IMMEDIATE?
  lda (DPTR)
  and #IMM
  beq noimmed
  lda #1
  sta stackbase+1,x
  stz stackbase+2,x
  bra done
noimmed
  lda #$FF
  sta stackbase+1,x
  sta stackbase+2,x
done
  jmp next

nomatch
  jsr push16        ; put address back on stack
  jmp dofalse       ; return a FALSE on the stack
.)


dopostpone
  jsr readnext
  jsr dmatchword
  lda DPTR+1
  bne ppcontinue
  bra tickabort  
ppcontinue
  jsr pushxt        ; put the XT on the stack
  lda (DPTR)        ; immediate word?
  cmp #128          ; check top bit
  bcc nonimmediate  ; no...
  bra ppend         ; yes. compile in the XT
nonimmediate
  jsr compilelit    ; compile XT in as literal value
  dex
  dex
  lda #<commacode   ; set up to compile COMMA
  sta stackbase+1,x
  lda #>commacode
  sta stackbase+2,x
ppend
  jsr commasub      ; compile in COMMA or XT, depending
  jmp next


;;; doforget implements FORGET. Uses the same dictionary matching
;;; routine as the text interpreter (I'm gradually breaking this stuff
;;; out so that it can be used more generically).
doforget
.(
  jsr readnext      ; read next word from input stream
  jsr dmatchword    ; look for a match
  lda DPTR+1        ; no words on zero page, so only need to check this
  bne continue
  jmp abortnotdef

continue
  ;; first, reset DP to this location
  lda DPTR
  sta DP
  lda DPTR+1
  sta DP+1

  ;; next, grab the link pointer in order to reset DT
  lda (DPTR)        ; load the word count for this entry
  inc               ; and add one for the count byte
  clc               ; and add to DPTR, so that it points to the link
  adc DPTR
  sta DPTR
.(
  bcc skip
  inc DPTR+1
skip
.)
;  lda DPTR+1
;  adc #0
;  sta DPTR+1

  ldy #1            ; reset top of dictionary to the word preceeding
  lda (DPTR)        ; the word we are forgetting
  sta DT
  lda (DPTR),y
  sta DT+1
  jmp next

.)

;;; doimmediate implements IMMEDIATE, which sets the IMMEDIATE flag
;;; for the most recently defined word. Not sure if it should be
;;; immediate itself! Most recently defined word is the one at the
;;; top of the dictionary, ie at DT.
doimmed
  lda (DT)
  ora #IMM
  sta (DT)
  jmp next          ; shortest instruction yet?


;;; dofill implements FILL.
dofill
  lda stackbase+5,x ; copy base address into stackaccess
  sta stackaccess
  lda stackbase+6,x
  sta stackaccess+1

.(
outerloop
  lda stackbase+4,x ; MSB of count
  beq lessthanpage  ; if zero, there's less than a page to copy

  lda stackbase+1,x ; the value to copy in
  ldy #$ff
innerloop
  sta (stackaccess),y
  dey
  bne innerloop
  sta (stackaccess),y
  inc stackaccess+1 ; add one to MSB of our base
  dec stackbase+4,x ; count off one page
  bne outerloop     ; until MSB of count is zero
.)

lessthanpage
.(
  lda stackbase+1,x ; we might be coming from before we loaded this
  ldy stackbase+3,x ; remaining count
  beq done
finalloop
  dey
  sta (stackaccess),y
  cpy #0
  bne finalloop
done
.)
  clc               ; pop three cells off the stack
  txa
  adc #6
  tax
  jmp next


;; switch input to a streaming file.
doinclude
  jsr readnext      ; get name of file into WORD
  jsr finddirword   ; look it up in the root directory
.(
  bcc continue
  jmp abortnofile
continue
.)
  ;; grab pointer to the data
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

  ;; remove pointer from the stack
  inx
  inx

  ;; grab the file size and stash it both as a size and as the
  ;; "still to read" value
  ldy #28
  lda (SCRATCH),y
  sta FILESIZE
  sta READSIZE
  iny
  lda (SCRATCH),y
  sta FILESIZE+1
  sta READSIZE+1
  iny
  lda (SCRATCH),y
  sta FILESIZE+2
  sta READSIZE+2
  iny
  lda (SCRATCH),y
  sta FILESIZE+3
  sta READSIZE+3

  ;; next, grab the file cluster number and push onto stack as a double.
  ;; we put this on top of the directory cluster number that's there
  ;; because we don't need it
  ldy #26
  lda (SCRATCH),y ; LSB
  sta stackbase+1,x
  iny
  lda (SCRATCH),y ; MSB
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  ;; convert it to a sector number
  jsr cltosector

  ;; store this. eventually it'll be in a file table, but for now
  ;; it'll be in a single cache.
  lda stackbase+1,x
  sta NEXTSECTOR
  lda stackbase+2,x
  sta NEXTSECTOR+1
  lda stackbase+3,x
  sta NEXTSECTOR+2
  lda stackbase+4,x
  sta NEXTSECTOR+3

  ;; clean up the stack
  inx
  inx
  inx
  inx

  ;; TAG SRC SAV
  ;; save the current SOURCE and input pointer
  dec RP            ; this is just here to keep RP word-aligned
  lda SOURCE        ; store SOURCE on the stack
  sta (RP)
  dec RP
  lda IPTR+1        ; save the current input pointer on the R-stack
  sta (RP)
  dec RP
  lda IPTR
  sta (RP)
  dec RP

  ;; now set the input pointer to the zero-filled sentinel values at
  ;; the end of the stream buffer. we don't actually read any of the
  ;; file here. let refill do the work (all in one place).
  lda #<IOSENTINEL
  sta IPTR
  lda #>IOSENTINEL
  sta IPTR+1

  lda #$FF          ; bit 7 indicates stream. for now, one will do.
  sta SOURCE

  jmp next


donip
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  jmp drop1cell

;;; ( x1 x2 -- x2 x1 x2)
;;;            +5 +3 +1
dotuck
  dex
  dex
  lda stackbase+3,x
  pha
  sta stackbase+1,x
  lda stackbase+4,x
  pha
  sta stackbase+2,x

  lda stackbase+5,x
  sta stackbase+3,x
  lda stackbase+6,x
  sta stackbase+4,x

  pla
  sta stackbase+6,x
  pla
  sta stackbase+5,x
  jmp next

;;; Implement DUMP command by calling dump routine from the monitor.
;;; In Forth, the byte count is on the top of the stack and the base
;;; address underneath; the monitor looks for them the other way around.
;;; So to a swap before calling the routine.
;dodump
;  jsr crlf
;  jsr swap16
;  jsr DUMP
;  jmp next


;;; implements COUNT -- take a pointer to a counted string on the stack,
;;; and turn it into a pointer to the characters and the count.
docount
;  clc carry always clear here
  lda stackbase+1,x ; LSB of counted string address
  sta SCRATCH       ; cache it
  adc #1            ; add one (to get address of characters)
  sta stackbase+1,x ; put back
  lda stackbase+2,x ; now same for MSB
  sta SCRATCH+1
  adc #0
  sta stackbase+2,x
  lda (SCRATCH)     ; load character count from cached address
  sta stackaccess
  stz stackaccess+1
  jsr push16
  jmp next

  

;;;
;;; DOUBLE-LENGTH ARITHMETIC
;;;
;;; These routines are all for double-length (ie, 32-bit
;;; rather then 16-bit) arithmetic, although for the moment,
;;; I'm entirely ignoring issues about signed vs unsigned.
;;;

;;; promote a single-lenth value to a double-legnth value (S>D).
dosgltodbl
.(
  dex               ; add space on the stack
  dex
  lda stackbase+3,x ; copy the single-length cell down
  sta stackbase+1,x
  lda stackbase+4,x
  sta stackbase+2,x

  ;; extend whatever the sign bit is of this word into the
  ;; larger word. so check if it's one or zero
  lda stackbase+4,x
  bit #%10000000
  beq zerobits      ; it's zero
  lda #$ff          ; it's one, so load FF into each byte
  sta stackbase+3,x
  sta stackbase+4,x
  bra end
zerobits
  stz stackbase+3,x ; zero out the upper cell
  stz stackbase+4,x
end
.)
  jmp next

;;; double-length addition
doadd32
;  clc carry always clear here
  lda stackbase+1,x ; byte #1
  adc stackbase+5,x
  sta stackbase+5,x ; leaves result in lower area on stack
  lda stackbase+2,x ; byte #2
  adc stackbase+6,x
  sta stackbase+6,x
  lda stackbase+3,x ; byte #3
  adc stackbase+7,x
  sta stackbase+7,x
  lda stackbase+4,x ; byte #4
  adc stackbase+8,x
  sta stackbase+8,x
drop2cells
  inx               ; drop the upper two-cell number
  inx
  inx
  inx
  jmp next          ; done


;;; mixed-length addition. Add a 16-bit wide number on the top of
;;; the stack to a 32-bit wide number below it.
doaddmix
;  clc carry always clear here
  lda stackbase+1,x ; byte #1
  adc stackbase+3,x
  sta stackbase+3,x ; leaves result in lower area on stack
  lda stackbase+2,x ; byte #2
  adc stackbase+4,x
  sta stackbase+4,x
.(
  bcc skip
  inc stackbase+5,x
  bne skip
  inc stackbase+6,x
skip
.)

  jmp drop1cell


;;; double-length subtraction
dosub32
  sec                        ; set the carry
  lda stackbase+5,x ; byte #1
  sbc stackbase+1,x
  sta stackbase+5,x ; leaves result in lower area on stack
  lda stackbase+6,x ; byte #2
  sbc stackbase+2,x
  sta stackbase+6,x
  lda stackbase+7,x ; byte #3
  sbc stackbase+3,x
  sta stackbase+7,x
  lda stackbase+8,x ; byte #4
  sbc stackbase+4,x
  sta stackbase+8,x
  jmp drop2cells

donegate32
;  clc carry always clear here
  lda stackbase+1,x ; add one and flip bits to calculate two's complement
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  eor #$ff
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x
  jmp next


;;; test for equality for 32-bit numbers
doeql32
.(
  lda stackbase+1,x
  cmp stackbase+5,x
  bne notequal
  lda stackbase+2,x
  cmp stackbase+6,x
  bne notequal
  lda stackbase+3,x
  cmp stackbase+7,x
  bne notequal
  lda stackbase+4,x
  cmp stackbase+8,x
  bne notequal
equal
  clc               ; clean up stack before setting result
  txa
  adc #6
  tax
  jmp settrue
notequal
  clc               ; clean up stack before setting result
  txa
  adc #6
  tax
  jmp setfalse
.)


;;; compare a 32-bit number to zero
dozero32
.(
  lda stackbase+1,x ; or all the bytes together
  ora stackbase+2,x
  ora stackbase+3,x
  ora stackbase+4,x
  beq zero          ; zero?
notzero
  inx               ; clean up stack before setting result
  inx
  jmp setfalse
zero
  inx               ; clean up stack before setting result
  inx
  jmp settrue
.)

;;; implements D0<
dolesszero32
.(
  lda stackbase+4,x
  bit #%1000000
  bne yes
  inx
  inx
  jmp setfalse
yes
  inx
  inx
  jmp settrue
.)

;;; implements DABS
doabs32
.(
  lda stackbase+4,x
  bit #%1000000
  beq done
  jmp donegate32
done
  jmp next
.)

;;; implements D<
doless32
.(
  sec
  lda stackbase+5,x
  sbc stackbase+1,x
  lda stackbase+6,x
  sbc stackbase+2,x
  lda stackbase+7,x
  sbc stackbase+3,x
  lda stackbase+8,x
  sbc stackbase+4,x
  bpl no
  clc
  txa
  adc #6
  tax
  jmp settrue
no
  txa
  adc #6
  tax
  jmp setfalse
.)

;;; implements DMIN
dodmin
.(
  sec
  lda stackbase+5,x
  sbc stackbase+1,x
  lda stackbase+6,x
  sbc stackbase+2,x
  lda stackbase+7,x
  sbc stackbase+3,x
  lda stackbase+8,x
  sbc stackbase+4,x
  bpl no
yes
  clc               ; min value is lower on stack, so drop
  txa               ; the upper one
  adc #4
  tax
  jmp next
no
  jsr swap32
  bra yes
.)

;;; implements DMAX
dodmax
.(
  sec
  lda stackbase+5,x
  sbc stackbase+1,x
  lda stackbase+6,x
  sbc stackbase+2,x
  lda stackbase+7,x
  sbc stackbase+3,x
  lda stackbase+8,x
  sbc stackbase+4,x
  bpl no
yes
  jsr swap32        ; swap and proceed with "no"
no
  clc               ; min value is lower on stack, so drop
  txa               ; the upper one
  adc #4
  tax
  jmp next
.)



;;; domultmix -- multiply two 16-bit numbers, giving a 32-bit result
domultmix
  jsr multmixsub
  jmp next

;;; test the signs of two 16-bit operands. After this, each operand
;;; is on the stack in its absolute value, and SCRATCH is either 0
;;; (if the signs were the smae) or 128 if not.
testsigns16
.(
  lda stackbase+2,x
  eor stackbase+4,x
  and #128
  sta SCRATCH       ; scratch is 0 if numbers have same sign, 128 otherwise

  ;; BUG can't the flips and the addition be combined, saving load/saves?

  ;; if n1 is negative, make a note and invert it
  lda stackbase+2,x
  bit #128
  beq checkother
  eor #$ff
  sta stackbase+2,x
  lda stackbase+1,x
  eor #$ff
  clc
  adc #1
  sta stackbase+1,x
.(
  bcc skip
  inc stackbase+2,x
skip
.)

checkother
  lda stackbase+4,x
  bit #128
  beq done
  eor #$ff
  sta stackbase+4,x
  lda stackbase+3,x
  eor #$ff
  clc
  adc #1
  sta stackbase+3,x
  lda stackbase+4,x
  adc #0
  sta stackbase+4,x
done
  rts
.)

;;; as testsigns16, but this time, presume that there is a 16-bit
;;; value on the top of the stack and a 32-bit value below it.
testsignsmix
  lda stackbase+2,x
  eor stackbase+6,x
  and #128
  sta SCRATCH       ; scratch is 0 if numbers have same sign, 128 otherwise

  ;; BUG can't the flips and the addition be combined, saving load/saves?

absmix              ; alternative entry point
.(
  ;; if n1 is negative, make a note and invert it
  lda stackbase+2,x
  bit #128
  beq checkother
  eor #$ff
  sta stackbase+2,x
  lda stackbase+1,x
  eor #$ff
  clc
  adc #1
  sta stackbase+1,x
.(
  bcc skip
  inc stackbase+2,x
skip
.)
;  lda stackbase+2,x
;  adc #0
;  sta stackbase+2,x

checkother
  lda stackbase+6,x
  bit #128
  beq done
  eor #$ff
  sta stackbase+6,x
  lda stackbase+5,x
  eor #$ff
  sta stackbase+5,x
  lda stackbase+4,x
  eor #$ff
  sta stackbase+4,x
  lda stackbase+3,x
  eor #$ff
  clc
  adc #1
  sta stackbase+3,x
  bcc done
  inc stackbase+4,x
  bne done
  inc stackbase+5,x
  bne done
  inc stackbase+6,x
done
  rts
.)

;;; Fix up the signs after a signed arithmetic operation if
;;; the flag in SCRATCH signals that it's needed.
fixsigns16
.(
  lda SCRATCH
  beq done
  jmp flipsign16
done
  rts
.)

flipsign16          ; broken out so it can be called separately
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  rts


;;; Fix up the signs after a signed arithmetic operation if
;;; the flag in SCRATCH signals that it's needed.
fixsigns32
.(
  lda SCRATCH
  beq done
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  eor #$ff
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x
done
  rts
.)

multmixsub
  jsr testsigns16
  jsr umstarsub
  jsr fixsigns32
  rts

doumstar
  jsr umstarsub
  jmp next

;;; This version of UM* is based on one contributed by Dr Jeffyll
;;; to the 6502.org forum. See the thread at
;;; forum.6502.org/viewtopic.php?f=9&t=689
;;; The same code is also the basis of the UM* routine in Tali Forth.
umstarsub
  CLC 
  LDA 3,X    ;Copy TOS value to N+2,N+3. To eliminate CLC inside the loop, the
  SBC #0
  STA SCRATCH+3     ;special accommodation mandatory for the case of TOS = 0.
  LDA 4,X
  SBC #0
  BCC UST_Z         ; TOS = 0? Mandatory special treatment for this
  STA SCRATCH+4
  LDA #0
  STA SCRATCH+1     ; 16 bits of zero in A, N
  STX SCRATCH+5     ; tested later for exit from outer loop
  DEX               ; bias applied to X
  DEX
UST_OUTLP
  LDY #8            ; count for inner loop
  LSR 3,X           ; think "2,x" then later "3,X"
UST_INLP
  BCC UST_NOADD
  STA SCRATCH+2    ;Save time, don't CLC. Value in N+2,N+3 is reduced by 1 to allow this
  LDA SCRATCH+1
  ADC SCRATCH+3
  STA SCRATCH+1
  LDA SCRATCH+2
  ADC SCRATCH+4
UST_NOADD
  ROR
  ROR SCRATCH+1
  ROR 3,X           ; think "2,x" then later "3,X"
  DEY
  BNE UST_INLP      ; go back for 1 more shift?
  INX
  CPX SCRATCH+5
  BNE UST_OUTLP     ; go back for 8 more shifts?
  STA 4,X           ; ms byte of hi-word of result
  LDA SCRATCH+1
  STA 3,X           ; ls byte of hi-word of result
UST_EXIT
  RTS
UST_Z
  STZ 1,X
  STZ 2,X
  BCC UST_EXIT


dosmdivrem
  jsr smdivmodsub
  jmp next


smdivmodsub
.(
  ;; unfortunately, signs are weird here, so I have to do this
  ;; by hand here rather than using the usual routines.
  lda stackbase+2,x ; check divisor MSB
  lsr               ; moves sign bit into bit 6
  and #64           ; mask off other bits
  sta SCRATCH       ; stash it
  lda stackbase+6,x ; check dividend MSB
  and #128          ; grab sign bit
  ora SCRATCH       ; combine it with other bit
  sta SCRATCH       ; SCRATCH is 0 when both are positive
  jsr absmix        ; invert both if needed

  jsr umdivmodsub

  ;; now fix up the signs

  lda SCRATCH       ; short circuit fixsigns if nothing to be done
  beq done

  ;; if the dividend is negative, then flip the remainder
  bit SCRATCH
  bpl testmixed
  inx
  inx
  jsr flipsign16
  dex
  dex

testmixed
  ;; if mixed signs (ie, not 0 and not not 192), flip the quotient
  ;; we've already tested for 0
  lda SCRATCH
  cmp #192
  beq done    

  ;; flip the quotient
  jsr flipsign16

done
  rts
.)

;;; Mixed-length division. Divide a 32-bit number by a 16-bit number,
;;; giving a 16-bit result. This is used as part of */.
;;; on entry, the 16-bit divisor is on the top of the stack (ie
;;; at stackbase+1 and +2), and the 32-bit divisand is lower (ie
;;; at stackbase+3 through +6)
divmixsub
  jsr smdivmodsub
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  inx
  inx
  rts

doumdivmod
  jsr umdivmodsub
  jmp next

;;; This implementation of UM/MOD is from Garth Wilson on 6502.org.
umdivmodsub
.(
  SEC             ; Detect overflow or /0 condition.
  LDA 5,X         ; Divisor must be more than high cell of dividend.  To
  SBC 1,X         ; find out, subtract divisor from high cell of dividend;
  LDA 6,X         ; if carry flag is still set at the end, the divisor was
  SBC 2,X         ; not big enough to avoid overflow. This also takes care
  BCS overflow    ; of any /0 condition.  Branch if overflow or /0 error.
                  ; We will loop 16 times; but since we shift the dividend
  LDY     #$11    ; over at the same time as shifting the answer in, the
                  ; operation must start AND finish with a shift of the
                  ; low cell of the dividend (which ends up holding the
                  ; quotient), so we start with 17 (11H) in X.
loop
  ROL 3,X         ; Move low cell of dividend left one bit, also shifting
  ROL 4,X         ; answer in. The 1st rotation brings in a 0, which later
                  ; gets pushed off the other end in the last rotation.
  DEY
  BEQ done        ; Branch to the end if finished.

  ROL 5,X         ; Shift high cell of dividend left one bit, also
  ROL 6,X         ; shifting next bit in from high bit of low cell.
  STZ SCRATCH+1   ; Zero old bits of CARRY so subtraction works right.
  ROL SCRATCH+1   ; Store old high bit of dividend in CARRY.  (For STZ
                  ; one line up, NMOS 6502 will need LDA #0, STA CARRY.)
  SEC             ; See if divisor will fit into high 17 bits of dividend
  LDA 5,X         ; by subtracting and then looking at carry flag.
  SBC 1,X         ; First do low byte.
  STA SCRATCH+2   ; Save difference low byte until we know if we need it.
  LDA 6,X
  SBC 2,X         ; Then do high byte.
  STA SCRATCH+3   ; Save difference high byte until we know if we need it.
  LDA SCRATCH+1   ; Bit 0 of CARRY serves as 17th bit.
  SBC #0          ; Complete the subtraction by doing the 17th bit before
  BCC loop        ; determining if the divisor fit into the high 17 bits
                  ; of the dividend.  If so, the carry flag remains set.
  LDA SCRATCH+2   ; If divisor fit into dividend high 17 bits, update
  STA 5,X         ; dividend high cell to what it would be after
  LDA SCRATCH+3
  STA 6,X         ; subtraction
  BRA     loop    ; Always branch.

overflow
  LDA #$FF        ; If overflow occurred, put FF
  STA 5,X         ; in remainder low byte
  STA 6,X         ; and high byte,
  STA 3,X         ; and in quotient low byte
  STA 4,X         ; and high byte.

done
  INX
  INX
  RTS
.)



stardivshared
  lda stackbase+1,x ; move the divisor out of the way temporarily
  sta stackaccess
  lda stackbase+2,x
  sta stackaccess+1
  inx
  inx
  jsr multmixsub    ; do the multiplication
  dex
  dex
  lda stackaccess+1 ; put the divisor back
  sta stackbase+2,x
  lda stackaccess
  sta stackbase+1,x
  rts

dostardiv
  jsr stardivshared
  jsr divmixsub     ; do the division
  jmp next

;; this is exactly dostardiv, but with a different division call
;; to get me the modulus too.
dostardivmod
  jsr stardivshared
  jsr smdivmodsub   ; do the division
  jmp next

;; this is used by both print32s and rprint32s. Test the sign of the
;; number being printed, and if it's negative, output a minus and
;; prepare the number for unsigned processing
handlesign32
.(
  ;; check the most significant bit of the number
  ;; to see if it's negative
  lda stackbase+4,x
  bit #%10000000
  beq nominus

  lda #$2d          ; minus sign
  sta (PADPTR)      ; add it to the string we're assembling
  inc PADPTR

  ;; now calculate the two's complement of the number we have.
  ;; flip all the bits and add one.
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  eor #$ff
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x

nominus
  rts
.)


;;; BUG there is an awful lot of code shared between rprint32
;;; and print32. Can all the setup stuff be broken out?
rprint32s
  jsr initpadptr    ; set up PADPTR
  jsr handlesign32  ; handle if number is negative
  jsr assemble32    ; assemble the 32-bit number on the pad
  jsr pop16         ; pull the field width (presume < 256)
  phy
  sec
.(
  lda stackaccess   ; load field width
  sbc PAD           ; subtract the the string length
  bmi printnum      ; skip spaces if number longer than field
  tay
  lda #$20
  cpy #0
  beq printnum
space
  jsr puta
  dey
  bne space
printnum
.)
  jsr prpadnum
  ply               ; restore Y
  rts



;;; Print a 32-bit decimal number. This is kinda awful. The technique
;;; I used for 16-bits was messy enough, but this is messier now that
;;; I've extended it. (Updated to handle negative numbers.)
print32s
  jsr initpadptr    ; set up PADPTR
  jsr handlesign32  ; handle if number is negative
  bra sharedprint32

;;; unsigned version
print32u
  jsr initpadptr    ; set up PADPTR
sharedprint32
  jsr assemble32
  lda #$20
  jsr puta
  jsr prpadnum
  rts



assemble32
.(
  lda BASE
  cmp #16
  bne continue
  jmp hassemble32
continue
.)
  ;; Open five bytes of storage on the stack. These will be
  ;; ten nybbles each holding a single binary-coded decimal
  ;; digit (since 32 bytes stores a max of a ten-digit decimal).
  jsr open2cells
  dex
  
  ;; that leaves the data to be read at stackbase+6,x through
  ;; stackbase+9,x
  
  stz stackbase+1,x ; dec0
  stz stackbase+2,x ; dec1
  stz stackbase+3,x ; dec2
  stz stackbase+4,x ; dec3
  stz stackbase+5,x ; dec4

  phy               ; preserve Y
  lda #0
  sed
  ldy #32           ; count of bits we are processing

.(
loop
  asl stackbase+6,x ; roll bits out of the data values
  rol stackbase+7,x ; and into the carry, one by one
  rol stackbase+8,x
  rol stackbase+9,x
  lda stackbase+1,x ; and then use carry to add into the
  adc stackbase+1,x ; decimal space
  sta stackbase+1,x
  lda stackbase+2,x
  adc stackbase+2,x
  sta stackbase+2,x
  lda stackbase+3,x
  adc stackbase+3,x
  sta stackbase+3,x
  lda stackbase+4,x
  adc stackbase+4,x
  sta stackbase+4,x
  lda stackbase+5,x
  adc stackbase+5,x
  sta stackbase+5,x
  dey
  bne loop
.)
  cld
  ;; we have the result in the temporary storage, as BCD. now print
  ;; that as a ten-character string. do this as five loops of
  ;; an upper and lower nybble.

  ;; set a flag to determine whether we've printed anything non-zero
  stz SCRATCH

  txa
  adc #<stackbase
  sta SCRATCH+2
  lda #>stackbase
  sta SCRATCH+3
  ldy #5

.(
nextbcd             ; go through this loop for each BCD digit
  ;; first, upper four bytes
  lda (SCRATCH+2),y
  and #%11110000
  bne prupper       ; non-zero
  cmp SCRATCH       ; if it's zero, check if we're printing zeros
  beq lower         ; if we're not, then skip this one
prupper
  clc               ; shift the top four bits down to the bottom
  ror
  ror
  ror
  ror
  clc
  adc #'0
;  jsr puta
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

lower
  ;; next, lower four bytes
  lda (SCRATCH+2),y
  and #%00001111
  bne prlower       ; non-zero
  cmp SCRATCH       ; if it's zero, check if we're printing zeros
  beq skip          ; if we're not, then skip this one
prlower
  clc
  adc #'0
;  jsr puta
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

skip
  dey
  bne nextbcd
.)

.(
  ;; check -- if we never printed anything, output a zero
  lda SCRATCH
  bne finalize
  lda #$30          ; add a zero
  ;jsr puta
  sta (PADPTR)
  inc PADPTR

finalize
  sec
  lda PADPTR        ; calculate string length
  sbc #<PAD
  dec
  sta PAD           ; update string count
  ply               ; restore Y

  clc               ; clear bytes off the stack (five for
  txa               ; working space and four for 32-bit number).
  adc #9
  tax
.)
  rts




;;;
;;; DOUBLE CELL STACK ROUTINES
;;;

do2dup
  jsr open2cells
  lda stackbase+5,x
  sta stackbase+1,x
  lda stackbase+6,x
  sta stackbase+2,x
  lda stackbase+7,x
  sta stackbase+3,x
  lda stackbase+8,x
  sta stackbase+4,x
  jmp next

do2drop
  jmp drop2cells

do2over
  jsr open2cells
  lda stackbase+9,x
  sta stackbase+1,x
  lda stackbase+10,x
  sta stackbase+2,x
  lda stackbase+11,x
  sta stackbase+3,x
  lda stackbase+12,x
  sta stackbase+4,x
  jmp next

do2swap
  jsr swap32
  jmp next

;;; this routine is broken out because we use it in some other
;;; places too
swap32
  lda stackbase+1,x ; cache two cells from top of stack
  pha               ; on the processor's hardware stack
  lda stackbase+2,x
  pha
  lda stackbase+3,x
  pha
  lda stackbase+4,x
  pha

  lda stackbase+5,x ; copy two lower cells into the two cells
  sta stackbase+1,x ; on the top of the stack
  lda stackbase+6,x
  sta stackbase+2,x
  lda stackbase+7,x
  sta stackbase+3,x
  lda stackbase+8,x
  sta stackbase+4,x

  pla               ; restore the cached values and place them
  sta stackbase+8,x ; in the two lower cells
  pla
  sta stackbase+7,x
  pla
  sta stackbase+6,x
  pla
  sta stackbase+5,x

  rts


;;; Implements EXECUTE. execute the code indicated by the XT on the stack.
doexecute
  lda stackbase+1,x ; reset XT (W) to the address signalled on the stack
  sta XT
  lda stackbase+2,x
  sta XT+1
  inx
  inx
  jmp XT-1

dounused
  jsr unusedsub
  jmp next

unusedsub
  dex
  dex
  sec
  lda #<RESERVED
  sbc DP
  sta stackbase+1,x
  lda #>RESERVED
  sbc DP+1
  sta stackbase+2,x
  rts

doident
  lda #32
  jsr puta
  lda #<greeting
  sta PRINTVEC
  lda #>greeting
  sta PRINTVEC+1
  jsr printvecstr
  jmp next

dohex
  lda #16
  sta BASE
  stz BASE+1
  jmp next

dodecimal
  lda #10
  sta BASE
  stz BASE+1
  jmp next

;dobase
;  dex
;  dex
;  lda #<BASE
;  sta stackbase+1,x
;  lda #>BASE
;  sta stackbase+2,x
;  jmp next

dochar
  jsr readnext
  ldy #1
  lda WORD,y
  dex
  dex
  sta stackbase+1,x
  stz stackbase+2,x
  jmp next  
  
dobrchar
  jsr readnext

  ;; put character value on the stack
  dex
  dex
  lda WORD+1        ; +1 to skip the character count
  sta stackbase+1,x
  stz stackbase+2,x
  jsr compilelit    ; compile it in as a literal

  jmp next


;;; dodoes is the compile-time behaviour for DOES>. This is an immediate
;;; word, so this code runs when a word using DOES> is being compiled.
;;; It compiles in the run-time code (DOES) and a copy of the current
;;; next compilation address (which will shortly contain the start of
;;; the code that was compiled after "DOES>".
dodoes
.(
  ldy #0
  lda #<dodoesrtcode  ; first, compile in the code address
  sta (DP),y
  iny
  lda #>dodoesrtcode
  sta (DP),y
  iny

  clc                 ; and the parameter address is DP
  lda DP              ; plus two cells
  adc #4              ; ie four bytes
  sta (DP),y
  iny
  lda DP+1
  adc #0
  sta (DP),y
  iny

  tya
  clc
  adc DP
  sta DP
  bcc skip
  inc DP+1
skip
  jmp next

;nocompile
;  jmp abortcompile
.)


;;; dodoesrt is the run-time behaviour for (DOES), which is
;;; compiled by DOES>. This runs when the defining word, which
;;; creates a word whose behavior is defined using DOES> runs.
;;; it resets the XT of the most recent word, and then takes
;;; the  parameter that DOES> compiled in, and recodes
;;; the most recent word to begin execution there (by compiling
;;; it into the start of the parameter space).
dodoesrt
  ;; find the code field address of the most recently defined
  ;; word (designated by DT). I think I do this often enough that
  ;; perhaps it should be a subroutine?
  lda DT
  sta DPTR
  lda DT+1
  sta DPTR+1
.(
  clc
  lda DPTR
  adc (DPTR)        ; add the word length
  inc               ; plus one byte for the length count
  inc               ; and two more for the link
  inc
  sta DPTR
  bcc skip
  inc DPTR+1
skip
.)

  ;; we are going to set that address to the code for dodoes, which
  ;; will necessitate moving any already-allocated storage. however,
  ;; we don't need to do that if XT is already set to dododoes. so,
  ;; first check and then jump to either setit or alreadyset.
  ldy #1
  lda (DPTR)  
  cmp #<dododoes
  bne setit
  lda (DPTR),y
  cmp #>dododoes
  beq alreadyset  

setit
  ;; not yet set to dododoes, so set and do the copy
  lda #<dododoes
  sta (DPTR)
  lda #>dododoes
  sta (DPTR),y      ; y is still 1 here

  ;; we need to copy all the allocated space ahead by two bytes.
  ;; calculate the parameters for the copy.
  clc               ; first, the base address for copy, 
  lda DPTR          ; which is the parameter space
  adc #2
  sta SCRATCH
  lda DPTR+1
  adc #0
  sta SCRATCH+1

  clc               ; second, the destination for copy, which
  lda SCRATCH       ; is source address plus two
  adc #2
  sta SCRATCH+2
  lda SCRATCH+1
  adc #0
  sta SCRATCH+3

  sec               ; third, number of bytes to copy, which is
  lda DP            ; found via DP
  sbc SCRATCH
  sta SCRATCH+4
  lda DP+1
  sbc SCRATCH+1
  sta SCRATCH+5

  jsr movedownsub   ; copy in a downward direction (ie going high to low)

alreadyset
  ;; compile in the parameter that we stored before. this should go
  ;; into the first parameter space, ie right after that code address
  ldy #0
  lda (IP)
  ldy #2
  sta (DPTR),y
  ldy #1
  lda (IP),y
  ldy #3
  sta (DPTR),y

.(
  ;; bump the IP since we've just consumed a value
  clc
  lda IP
  adc #2
  sta IP
  bcc skip
  inc IP+1
skip
.)

  ;; increment DP by two to account for the extra cell of storage
  ;; that we just used at the start
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skip
  inc DP+1
skip
.)

  ;; we don't execute the rest of the word, because it's actually
  ;; just compiled code to be executed later. Jump straight to exit.
  jmp exit
  

;;; dododoes is the run-time behaviour inserted by (DOES) and
;;; used to execute words constructed using DOES>. dododoes is rather
;;; like dolist; we will return from it using EXIT, so we need to 
;;; set up the return stack appropriately. unlike dolist, it takes
;;; a parameter and starts execution there (which is the compiled
;;; code from the word in which DOES> was originally used).
dododoes
  ;; first, push the current instruction pointer onto the
  ;; return stack (subroutine unrolled)
  lda IP+1
  sta (RP)
  dec RP
  lda IP
  sta (RP)
  dec RP

  ;; next, push the address of the storage area on the stack
  ;; that's not the usual parameter space, but one value after that
  ;; since the first slot in the parameter space is being used for
  ;; the instruction pointer (two cells so four bytes)
  dex
  dex
  clc
  lda XT
  adc #4
  sta stackbase+1,x
  lda XT+1
  adc #0
  sta stackbase+2,x

  ;; now reset IP from the parameter stored here
  ldy #2
  lda (XT),y
  pha
  iny
  lda (XT),y
  sta IP+1
  pla
  sta IP

  jmp next


;;; implements LATEST (leaves DT on the stack)
dolatest
  dex
  dex
  lda DT
  sta stackbase+1,x
  lda DT+1
  sta stackbase+2,x
  jmp next



;;;
;;; *** TEXT INTERPRETER
;;;
;;; For the moment, this is a basically a stopgap. The real FORTH
;;; text interpreter has many individual components that manifest
;;; themselves as words in the dictionary, and we'll get there.
;;; (The fact that the text interpreter is called QUIT in true Forth
;;; is the ultimate testement to Chuck Moore's twisted nature.)
;;; This is just something to get us going. Again, much borrowed here
;;; from the code of the monitor.
;;;

;;; This is the warm start address, which does some more setup.
;;; This updates the highly fluid variables; in fact, this warm-
;;; start routine is also called by ABORT to reset stacks and
;;; initiate interpreter interaction.
warmstart
  ;; turn off the compiler
  stz STATE

  lda #$FF
  sta RP            ; reset return stack
  tax               ; reset user stack
  stz INPUT         ; initialize the terminal input buffer with zero
  lda #<INPUT       ; set input pointer to the terminal input area
  sta IPTR
  lda #>INPUT
  sta IPTR+1
  stz SOURCE        ; take input from terminal
  stz IOSENTINEL    ; place zeros at the end of the file I/O buffer
  stz IOSENTINEL+1  ; to make sure we don't read off the end

  ;; no jump... we call straight through to interploop below.

;;; This is the main loop of the interpreter -- which also includes
;;; hooks to the compiler, because in Forth those are deeply
;;; conjoined.
;;;
interploop

  ;; get the next input word into WORD, potentially refilling
  ;; the text buffer in the process
  jsr readnext

  ;; search for a match in the dictionary
  jsr dmatchword
  lda DPTR+1        ; no words on zero page, so this indicates failure
  beq nomatch

  ;; we found a match for a word to execute. Set up the context
  ;; and call NEXT to get started.
gotmatch
  ;; DPTR currently indicates the matching dictionary entry.
  ;; update it so that it points to the code word.
  ldy #1
.(
  clc
  lda (DPTR)        ; load the word length
  sta SCRATCH       ; save a copy
  and #%00011111    ; mask off tag bits
  adc #3            ; one byte for length, two more for link word
  adc DPTR          ; add to address and store in dummy word entry
  sta DPTR
  bcc done
  inc DPTR+1
done
.)

  ;; next, check if we're compiling. if we are not, then we can continue
  lda STATE
  beq nocompile

  ;; now check if the word is immediate... because if it is, we should
  ;; go ahead and execute it, even if we're compiling
  lda SCRATCH
  bit #IMM
  bne nocompile

  ;; compile this into the currently-compiling word. that means we
  ;; should add the address of the code word into the location
  ;; pointed to by DP and increment DP.
  ;; DPTR stores the start of the entry for the word to execute.
  ;; So its code word is at (DPTR) + wordlength + 1 (len) + 2 (link)
  ldy #1
  lda DPTR
  sta (DP)
  lda DPTR+1
  sta (DP),y

  ;; increment DP by 2
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; proceed with the interpreter loop
  jmp interploop

nocompile
  ;; we are interpreting. if it's a compile-only word, check that
  ;; the compiler is on.
  lda SCRATCH
  bit #CPO
  beq interp
  lda STATE
  beq compileonly

interp
  lda DPTR          ; add to address and store in dummy word entry
  sta dummyparam
  lda DPTR+1
  sta dummyparam+1

execdummy
  ;; put the dummy parameter address into IP.
  lda #<dummyparam
  sta IP
  lda #>dummyparam
  sta IP+1

  ;; jump to NEXT to start running it
  jmp next

compileonly
  jmp abortcompile

  ;; we didn't find a match in the dictionary, so see if we can parse
  ;; it as a number.
nomatch

  ;; attempt to convert word to number and put it on the stack
  ;; my routines for this us a null-terminated string, so add a null
  ldy WORD
  iny
  lda #0
  sta WORD,y        ; add a null
  lda #<WORD        ; put address on the stack threshold
  sta stackaccess
  lda #>WORD
  sta stackaccess+1
.(
  inc stackaccess   ; bump it by one to avoid the count
  bne done
  inc stackaccess+1
done
.)
  jsr push16        ; put string address on the stack
  jsr readsign      ; attempt to read a signed number
  bcs nointerpret   ; carry signals failure to read a number


  ;; if we are compiling, we need to take it off the stack again
  ;; and compile it into the word.
  lda STATE
  beq normal

  ;; we are compiling. so we need to add this to the current
  ;; word as a literal. that means adding the code for DOLIT
  ;; and then the number.
  jsr compilelit

normal
  jmp interploop
  
  ;; if we get here, we couldn't find a match, nor could we read it as
  ;; a number. there's no interpretation, so issue an error, flush
  ;; the input, and loop
nointerpret  

  ;; turn off the compiler, if we were compiling
  stz STATE

  ;; print an error, in three stages. first, a space; then, the
  ;; undefined word; finally, the error message.

  lda #$20
  jsr puta
  jsr printword
  jmp abortnotdef

;;; print the word in WORD
printword
  ldy #1
.(
next_char
  lda WORD,y
  jsr puta
  iny
  cpy WORD
  bcc next_char
  beq next_char
.)

  rts

;;; look up a word in the dictionary. The word being 
;;; matched is indicated by WORD, which holds a pointer to a
;;; counted string; it is copied over into stackaccess for a
;;; second entry point for stack lookups.
;;; On exit, DPTR either points to the entry for the word, or
;;; 0000 in case of no match.
dmatchword
  lda #<WORD
  sta stackaccess
  lda #>WORD
  sta stackaccess+1

dmatchstack
  ;; set up search by initializing dictionary pointer
  lda DT
  sta DPTR
  lda DT+1
  sta DPTR+1

nextentry
  ;; have we run out of dictionary entries? (when DPTR is $0000)
  lda DPTR
  bne compareentry
  lda DPTR+1
  beq return

compareentry
  ;; compare words. counted strings can be compared directly;
  ;; byte by byte will compare counts first. But we need to
  ;; mask out the tags in the count.

  ldy #0
  lda (DPTR),y
  and #%00011111    ; mask off the tags
  cmp (stackaccess),y  ; compare word lengths
  bne trynext       ; no match

  ;; now compare words. do this from the end (for easier testing)
  lda (stackaccess)
  tay
.(
nextchar
  lda (DPTR),y
  cmp (stackaccess),y
  bne trynext
  dey
  bne nextchar
.)
  ;; successful match!
  bra return
  
  ;; loop to next entry
trynext
  lda (DPTR)        ; get word length...
  and #%00011111    ; mask off the tags
  tay               ; store in Y, and add one...
  iny               ; for the pointer to the next entry
  lda (DPTR),y      ; update DPTR to point to next entry
  sta SCRATCH
  iny
  lda (DPTR),y  
  sta DPTR+1
  lda SCRATCH
  sta DPTR
  bra nextentry
return
  rts


;; Read the next word in the current input stream, and leave it in
;; WORD. Potentially refills the input. In the new model, IPTR
;; always points to the next character to be read, from whichever
;; input buffer we're using.
readnext
  ldy #0
lookforword
  ;; skip over space to find a word
.(
  lda (IPTR),y
  beq endofbuffer
  cmp #$20          ; space?
  beq nextchar
  cmp #$09          ; tab?
  beq nextchar
  cmp #$0A          ; newline?
  beq nextchar
  cmp #$0D          ; carriage return?
  beq nextchar
  bra startword
nextchar
  iny
  bne lookforword
  ;; Y has looped back to zero, so increment the high byte
  ;; of the input pointer.
  inc IPTR+1
  bra lookforword
endofbuffer
  jsr refill
  jmp readnext      ; so, presumes that we're still pre-word
.)

startword
.(
  ;; first, update IPTR and reset Y
  clc
  tya
  adc IPTR
  sta IPTR
  bcc skip
  inc IPTR+1
skip
  ldy #0
.)
.(
  stz WORD
  phx
  ldx #1
  stx WORD          ; keep this updated in case of refill
nextchar
  lda (IPTR),y
  beq midword       ; got a null in the middle of a word
  cmp #$20
  beq doneword
  cmp #$09
  beq doneword
  cmp #$0A
  beq doneword
  cmp #$0D
  beq doneword
  sta WORD,x
  stx WORD          ; update character count
  iny
  beq doneword      ; max 255 characters
  inx
  bra nextchar
midword
  ;; we hit a null in the middle of a word -- need to refill
  ;; but only if we are streaming?
  lda SOURCE
  bpl doneword
  plx               ; restore X to stack pointer
  jsr refill        ; refill uses stack, hence phx/plx
  phx               ; save stack pointer again
  ldx WORD          ; restore X as WORD offset, but it's off by 1
  inx               ; so increment to next charaacter
  ldy #0            ; reset input pointer offset
  jmp nextchar
doneword
  clc               ; update IPTR past consumed input
  tya
  adc IPTR
  sta IPTR
  bcc skip
  inc IPTR+1
skip
  plx               ; restore X
  rts
.)

;;; refills the input buffer, possibly switching buffers if we have
;;; exhausted our current source.
refill
.(
  lda SOURCE        ; where are we reading from?
  beq terminal      ; 0 = terminal
  bmi refillstream  ; bit 7 = stream
  ;; otherwise, it's a buffer, so fall through...
buffer
reverttoterm
  ;; when we hit the end of a buffer, there is no more text to
  ;; read, so we restore the old IPTR from the R-stack and continue
  ;;
  ;; BUG BUG BUG this presumes, if we're returning to another block,
  ;; that the block is still loaded in the same part of memory as it
  ;; was. that is not necessarily true. We might need to reload it.
  ;; TAG SRC SAV
  inc RP
  lda (RP)
  sta IPTR
  inc RP
  lda (RP)
  sta IPTR+1
  inc RP
  lda (RP)
  sta SOURCE
  inc RP            ; ignore upper byte
  bra finishedread
terminal
  ;; are we compiling?
  lda STATE
  beq usualprompt   ; not compiling so say "OK" as usual
  jsr cprompt       ; different prompt to say we're still compiling
  bra afterprompt
usualprompt
  txa
  bmi noerr      ; top bit of FORTH stack pointer should be set
  lda #<stackerrstr
  sta PRINTVEC
  lda #>stackerrstr
  sta PRINTVEC+1
  jsr printvecstr
noerr
  lda #<ok
  sta PRINTVEC
  lda #>ok
  sta PRINTVEC+1
  jsr printvecstr
  bra afterprompt
afterprompt
  jsr readtermline  ; read another line of text
  lda #<INPUT       ; set input pointer to the text input area
  sta IPTR
  lda #>INPUT
  sta IPTR+1
finishedread
  rts

;;; refill I/O buffer from stream
refillstream
  ;; is there more data to read?
  lda READSIZE
  ora READSIZE+1
  ora READSIZE+2
  ora READSIZE+3
  bne moredata
  jmp  endofstream

moredata
  ;; set up block to read
  jsr open2cells
  lda NEXTSECTOR
  sta stackbase+1,x
  lda NEXTSECTOR+1
  sta stackbase+2,x
  lda NEXTSECTOR+2
  sta stackbase+3,x
  lda NEXTSECTOR+3
  sta stackbase+4,x

  ;; read data
  jsr sdloadbuf
  lda LBLOCK

  ;; do I need to place a sentinel value in there? ie, were there fewer
  ;; than 512 characters left to read?
  lda READSIZE+3
  bne skipsentinel
  lda READSIZE+2
  bne skipsentinel
  lda READSIZE+1
  beq needsentinel
  cmp #1
  bne skipsentinel
needsentinel
  clc               ; calculate offset for sentinel value
  lda #<LBLOCK      ; IO buffer base address plus bytes remaining
  adc READSIZE      ; plus one (the one is handled via Y, to save
  sta SCRATCH       ; an extra addition).
  lda #>LBLOCK
  adc READSIZE+1
  sta SCRATCH+1
  ldy #1
  lda #0
  sta (SCRATCH),y
skipsentinel

  ;; update read data count. we read in units of 512 bytes, so bottom
  ;; byte is untouched. decrement by 512 and if we've gone negative,
  ;; reset to zero
  sec
  lda READSIZE
  sbc #0
  sta READSIZE
  lda READSIZE+1
  sbc #2
  sta READSIZE+1
  lda READSIZE+2
  sbc #0
  sta READSIZE+2
  lda READSIZE+3
  sbc #0
  sta READSIZE+3
  bpl skipzero
  stz READSIZE
  stz READSIZE+1
  stz READSIZE+2
  stz READSIZE+3
skipzero

  ;; update next block pointer
.(
  clc
  lda NEXTSECTOR
  adc #1
  sta NEXTSECTOR
  bcc skip
  inc NEXTSECTOR+1
  bne skip
  inc NEXTSECTOR+2
  bne skip
  inc NEXTSECTOR+3
skip
.)

  ;; reset IPTR
  lda #<LBLOCK
  sta IPTR
  lda #>LBLOCK
  sta IPTR+1
  rts

endofstream
  jmp reverttoterm
.)




;;; Read a new line into the INPUT buffer. This reads from the
;;; terminal; readbufline will read from a buffer.
readtermline
  ldy #0
readone
  jsr readchar
  cmp #$08           ; check for backspace
  beq backspace
  cmp #$0D           ; check for newline (carriage return)
  beq doneline
  cmp #$0A           ; also allow line feed to terminate line
  beq doneline
  sta INPUT,y        ; track the input
  iny
  jsr puta           ; echo the typed character
  jmp readone        ; loop to repeat
backspace
  cpy #0             ; beginning of line?
  beq readone
  dey                ; if not, go back one character
  jsr puta           ; move cursor back
  lda #$20           ; output a space
  jsr puta
  lda #$08           ; and then another backspace
  jsr puta
  jmp readone

  ;; this is where we land if the line input has finished
  ;;
doneline
  lda #0
  sta INPUT,y       ; add a null terminator
  rts


readchar
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA
  rts



;;; Run-time behavior for ABORT". Print the string, then jump to abort.
doabortqrt
  lda #$20
  jsr puta

  phx               ; save X, since we're about to use it
  lda (IP)          ; load the string length
  tax               ; transfer to X. X counts down as Y counts up
  ldy #1

  ;; now print X characters 
.(
next_char
  lda (IP),y
  jsr puta
  iny
  dex
  bne next_char
done
.)

  plx               ; restore X

  ;; normally, we would update the IP here, but we're going to reset
  ;; it when we do the warm start anyway
  bra abort         ; could just fall throught but this is safer

;;; Implements ABORT. On error, resets and returns to interpreter.
;;; BUG doesn't reset DP if we were in the process of compiling, so
;;; leave a mess in the user space.
;;; warm-start routine.
abort
  jsr crlf          ; print newline
  jmp warmstart     ; reset variables and return to interpreter loop

;;; ABORT with a message about nesting
abortnest
  lda #<nestingmsg
  sta PRINTVEC
  lda #>nestingmsg
  sta PRINTVEC+1
abortpr
  jsr printvecstr
  jmp abort

;;; ABORT with a message about compiling
abortcompile
  lda #<compileerr
  sta PRINTVEC
  lda #>compileerr
  sta PRINTVEC+1
  jmp abortpr
  
;;; ABORT with a message about an undefined word
abortnotdef
  lda #<notdefinedmsg
  sta PRINTVEC
  lda #>notdefinedmsg
  sta PRINTVEC+1
  jmp abortpr

;;; ABORT with a message about block count exceeded
abortblocks
  lda #<blockcountmsg
  sta PRINTVEC
  lda #>blockcountmsg
  sta PRINTVEC+1
  jmp abortpr


;;; LIST prints a disk block to the screen
dolistword
.(
  lda USEBASE+3     ; is there a block file set up?
  beq continue
  jmp abortusing
continue
  jsr blocksub
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1
  stz SCRATCH+2
  inx               ; clean up stack
  inx

  jsr crlf

startrow
  ldy #0
nextchar
  lda (SCRATCH),y
  bne print
  jsr crlf
  bra nextline
print
  jsr puta
  cmp #$0a
  bne nocr
  lda #$0d
  jsr puta
  bra nextline
nocr
  iny
  cpy #64
  bne nextchar
nextline
  clc
  lda SCRATCH
  adc #64
  sta SCRATCH
  bcc doneadd
  inc SCRATCH+1  
doneadd
  inc SCRATCH+2
  lda SCRATCH+2
  cmp #16
  bne startrow
.)
  jmp next

;;; load input from a disk block
doload
.(
  lda USEBASE+3     ; is there a block file set up?
  beq continue
  jmp abortusing
continue
.)
  ;; BUG should check that the block number is in scope
  lda stackbase+1,x
  pha               ; stash the block number for a moment
  jsr blocksub      ; find/load the block, leave address on stack
  
  ;; TAG SRC SAV
  lda #0            ; we ignore this top byte but it keeps RP word-aligned
  sta (RP)          ; and storing 0 helps with debugging
  dec RP
  lda SOURCE        ; store SOURCE on the R-stack
  sta (RP)
  dec RP
  lda IPTR+1        ; save the current input pointer on the R-stack
  sta (RP)
  dec RP
  lda IPTR
  sta (RP)
  dec RP
  lda stackbase+1,x ; set input pointer to buffer address
  sta IPTR
  lda stackbase+2,x
  sta IPTR+1
  pla               ; restore the block number
  sta SOURCE
  inx               ; clean up the stack
  inx
  jmp next


dospat
  dex
  dex
  txa
  sta stackbase+1,x
  stz stackbase+2,x
  jmp next



;;; implements MOVE
;;; ( srcaddr destaddr u )
;;; if dest > src, then high-to-low, otherwise copy low-to-high.
;;; this should avoid conflicts in case of overlapping segments.
domove
  jsr movesetup

  sec
  lda stackbase+3,x
  sbc stackbase+5,x
  lda stackbase+4,x
  sbc stackbase+6,x
  bvc there
  eor #$80          ; what is this FOR? to do with BPL somehow...
there
  bpl here
  ; dest < src
  jsr moveupsub
  jmp next
here
  ; dest > src
  jsr movedownsub
  jmp next


domoveup
  jsr movesetup
  jsr moveupsub
  clc               ; clean up the stack
  txa
  adc #6
  tax
  jmp next

domovedown
  jsr movesetup
  jsr movedownsub
  clc               ; clean up the stack
  txa
  adc #6
  tax
  jmp next

movesetup
  lda stackbase+1,x
  sta SCRATCH+4
  lda stackbase+2,x
  sta SCRATCH+5
  lda stackbase+3,x
  sta SCRATCH+2
  lda stackbase+4,x
  sta SCRATCH+3
  lda stackbase+5,x
  sta SCRATCH
  lda stackbase+6,x
  sta SCRATCH+1
  rts

;;; move memory from source to destination, copying from low to high
;;; on input, SCRATCH+0/1 are source address, SCRATCH+2/3 are destination
;;; address, and SCRATCH+4/5 are byte count
moveupsub
.(
  phx
  ldy #0
  ldx SCRATCH+5     ; X is # full pages to move
  beq lastblock
pageloop
  lda (SCRATCH),y
  sta (SCRATCH+2),y
  iny
  bne pageloop
  inc SCRATCH+1
  inc SCRATCH+3
  dex
  bne pageloop
lastblock
  cpy SCRATCH+4     ; we know Y=0 at this point
  beq finish
  lda (SCRATCH),y
  sta (SCRATCH+2),y
  iny
  bra lastblock
finish
  plx
  rts
.)

;;; move memory from source to destination, copying from high to low
;;; on input, SCRATCH+0/1 are source address, SCRATCH+2/3 are destination
;;; address, and SCRATCH+4/5 are byte count
;;; BUG there must be a better way to do this! Perhaps the other way
;;; around -- start with the less-than-page segment and then do
;;; full pages?
movedownsub
.(
  phx

  clc               ; update source pointer to END of block
  lda SCRATCH
  adc SCRATCH+4
  sta SCRATCH
  lda SCRATCH+1
  adc SCRATCH+5
  sta SCRATCH+1
  dec SCRATCH+1     ; move back by one page

  clc               ; now do same with destination pointer
  lda SCRATCH+2
  adc SCRATCH+4
  sta SCRATCH+2
  lda SCRATCH+3
  adc SCRATCH+5
  sta SCRATCH+3
  dec SCRATCH+3

  ldx SCRATCH+5     ; this is the number of full pages to copy
  beq lastblock
movepage
  ldy #255
innerloop
  lda (SCRATCH),y
  sta (SCRATCH+2),y
  dey
  bne innerloop
  lda (SCRATCH)     ; copy the zero-byte
  sta (SCRATCH+2)
  dec SCRATCH+1     ; decrement both pointers by one page
  dec SCRATCH+3
  dex               ; decrement page-copy count by one
  bne movepage
lastblock
  ldy #255
  ldx SCRATCH+4
  beq done
lastloop
  lda (SCRATCH),y
  sta (SCRATCH+2),y
  dex
  beq done
  dey
  bne lastloop
done
  plx
  rts  
.)

;;; implements -TRAILING (removes trailing spaces from string)
;;; ( c-addr u1 -- c-addr u2 )
dodashtrail
.(
  ;; if u1 is zero, we're done
  lda stackbase+1,x
  ora stackbase+2,x
  beq finish
setup
  sec               ; set up SCRATCH+4/5 as sentinel value (c-addr - 1)
  lda stackbase+3,x
  sbc #1
  sta SCRATCH+4
  lda stackbase+4,x
  sbc #0
  sta SCRATCH+5
  clc               ; now add string count to that
  lda SCRATCH+4     ; creating pointer to end of string
  adc stackbase+1,x ; and store at SCRATCH and SCRACH+1
  sta SCRATCH
  lda SCRATCH+5
  adc stackbase+2,x
  sta SCRATCH+1
  stz SCRATCH+2     ; finally, use SCRATCH+2/3 as count of spaces
  stz SCRATCH+3
loop
  lda (SCRATCH)     ; look at current character
  cmp #32           ; is it a space?
  bne nospace
  clc               ; yes, so bump counter
  lda SCRATCH+2
  adc #1
  sta SCRATCH+2
  bcc doneadd
  inc SCRATCH+3
doneadd
  sec               ; dec pointer by one byte
  lda SCRATCH
  sbc #1
  sta SCRATCH
  lda SCRATCH+1
  sbc #0
  sta SCRATCH+1
  lda SCRATCH       ; compare pointer to start-of-string ptr
  cmp SCRATCH+4
  bne loop          ; loop if LSB not equal to sentinel
  lda SCRATCH+1
  cmp SCRATCH+5
  bne loop          ; loop if MBS not equal
nospace
  ;; we get here if (1) we have encountered a non-space, or (2) we
  ;; have exhausted the string. either way, the behaviour is the
  ;; same; subtract the counter from the length value on the
  ;; stack.
  sec
  lda stackbase+1,x
  sbc SCRATCH+2
  sta stackbase+1,x
  lda stackbase+2,x
  sbc SCRATCH+3
  sta stackbase+2,x
finish
  jmp next
.)


;;; implement /STRING
;;; adjust left-hand of string by n chars
;;; ( c-addr1 u1 n -- c-addr2 u2 )
doslashstr
  ;; first, substract n from u1
  sec
  lda stackbase+3,x
  sbc stackbase+1,x
  sta stackbase+3,x
  lda stackbase+4,x
  sbc stackbase+2,x
  sta stackbase+4,x
  ;; then, add n to c-addr2
  clc
  lda stackbase+5,x
  adc stackbase+1,x
  sta stackbase+5,x
  lda stackbase+6,x
  adc stackbase+2,x
  sta stackbase+6,x
  ;; drop n
  inx
  inx
  ;; done
  jmp next


;;; implement COMPARE
;;; ( c-addr1 u1 c-addr2 u2 -- n )
;;; BUG limits string length to 255
docompare
.(
  lda stackbase+7,x
  sta SCRATCH
  lda stackbase+8,x
  sta SCRATCH+1
  lda stackbase+3,x
  sta SCRATCH+2
  lda stackbase+4,x
  sta SCRATCH+3
  lda stackbase+1,x
  sta SCRATCH+4
  lda stackbase+5,x
  sta SCRATCH+5

  ldy #0
loop
  lda (SCRATCH),y
  cmp (SCRATCH+2),y
  bne endmatch
  iny
  cpy #0            ; looped around?
  beq ident
  ; compare to string lengths
  cpy SCRATCH+4     ; stackbase+1,x
  beq hitu2
  cpy SCRATCH+5     ; stackbase+5,x
  beq hitu1
  bra loop
hitu2
  cpy SCRATCH+5     ; stackbase+5,x
  beq ident
  ;; otherwise, not ident but str2 shorter than str1
  bra return1
hitu1
  cpy SCRATCH+4     ; stackbase+1,x
  beq ident
  ;; otherwise, not ident but str1 shorter than str2
  bra returnm1
endmatch
  bmi returnm1      ; minus if c2 > c1 so return -1
  bra return1       ; otherwise c1 < c2 so return 1
ident
return0
  jsr close3cells
  stz stackbase+1,x
  stz stackbase+2,x
  jmp next
return1
  jsr close3cells
  lda #1
  sta stackbase+1,x
  stz stackbase+2,x
  jmp next
returnm1
  jsr close3cells
  lda #$ff
  sta stackbase+1,x
  sta stackbase+2,x
  jmp next
.)

  
  


;;;
;;; *** SD CARD SUPPORT
;;;
;;; I have an SD breakout card attached to Port B on the 6522. These
;;; routines are the drivers to initialize, read, and write, as
;;; well (later) as navigating the FAT16 filesystem.
;;; 
;;; Wiring details:
;;;   CLK is PB0, ie 1
;;;   MOSI is PB1, ie 2
;;;   CS is PB2, ie 4
;;;   CD is PB6, ie 64 (CD = card detect)
;;;   MISO is PB7, which maps onto S flag on BIT (test with BPL and BMI)
;;; MISO, MOSI, and CS all have pull-up resisters, so they are high in
;;; the idle/unused state, except when pulled low by active circuitry.
;;;
;;; SD card support code is organized into roughly three layers. The
;;; lowest is the signalling layer that uses the 6522 to implement the
;;; SPI protocol. The thin middle layer is a basic layer for reading
;;; and writing data blocks. The upper layer implements (a subset of)
;;; the FAT16 filesystem.
;;;
SD_CLK  = 1
SD_MOSI = 2
SD_CS   = 4
SD_MISO = 128

;;; LOWEST LAYER (SPI PROTOCOL)
;;;

;;; set up data direction for PORTB -- lower four bits are outputs
;;; and upper four bits are inputs. This is called from FORTH startup.
setup6522
  lda #15
  sta VIA_DDRB
  rts

;;; Forth word to initialize the SD card and read the boot block.
;;; all the actual work is in mountsub, though. (This lets me call
;;; it from other places too.)
domount
.(
  bit VIA_PORTB
  bvs continue
  jmp abortnodisk
continue
  jsr mountsub
  bcc done
  jmp abortcardfail
done
  jmp next
.)

;;; do the work of mounting a new card. carry on exit signals
;;; an error.
mountsub
.(
  clc
  stz CURSEC        ; reset the sector cache
  stz CURSEC+1
  stz CURSEC+2
  stz CURSEC+3

  lda #$FF          ; reset USEBASE. Top byte should always be zero,
  sta USEBASE+3     ; so FF signals invalid.

  jsr resetsd
  jsr cmd0
  cmp #1
  beq continue
  sec
  bra donemount
continue

  jsr sendff
  jsr cmd8
  ;; BUG test the response

  lda #200           ; going to try this up to 200 times
  sta SCRATCH

repeat55
  jsr sendff
  jsr cmd55
  jsr sendff
  jsr acmd41
  cmp #0            ; loop until we get a 0 response
  beq success

  dec SCRATCH
  bne repeat55
  sec               ; carry signals an error
  bra donemount

success
  jsr sendff
  jsr cmd17

  lda #<LBLOCK
  sta SCRATCH+8
  lda #>LBLOCK
  sta SCRATCH+9
  jsr gettoken
  jsr getblocks8

.(

  ;; copy first 64 bytes into MBR area
  ldy #0
loop
  lda LBLOCK,y
  sta MBR,y
  iny
  cpy #64
  bne loop
.)

  ;; print a message with the card name
  ldy #0
.(
next_char
  lda initializedmsg,y
  beq done
  jsr puta
  iny
  jmp next_char
done
.)

.(
  ldy #0
next_char
  lda MBR_LABEL,y
  jsr puta
  iny
  cpy #11
  bne next_char
.)

  clc               ; carry signals error, so clear
donemount
  rts
.)


;;; ABORT with a message about card not initializing
abortcardfail
  lda #<cardfailmsg
  sta PRINTVEC
  lda #>cardfailmsg
  sta PRINTVEC+1
  jsr printvecstr
  jmp abort

;;; ABORT with a disk error
abortdiskerror
  lda #<diskerrormsg
  sta PRINTVEC
  lda #>diskerrormsg
  sta PRINTVEC+1
  jsr printvecstr
  ;; invalidate the sector number cache
  lda #$ff
  sta CURSEC+3
  jmp abort

;;; ABORT with a "no disk" error
abortnodisk
  lda #<nodiskmsg
  sta PRINTVEC
  lda #>nodiskmsg
  sta PRINTVEC+1
  jsr printvecstr
  jmp abort

;;; ABORT with a file error
abortnofile
  lda #<nofilemsg
  sta PRINTVEC
  lda #>nofilemsg
  sta PRINTVEC+1
  jsr printvecstr
  jmp abort

;;; ABORT with a (different) file error
abortexists
  lda #<existserr
  sta PRINTVEC
  lda #>existserr
  sta PRINTVEC+1
  jsr printvecstr
  jmp abort

;;; ABORT with a USING file error
abortusing
  lda #<usingerrormsg
  sta PRINTVEC
  lda #>usingerrormsg
  sta PRINTVEC+1
  jsr printvecstr
  jmp abort



docmd0
  jsr resetsd
  jsr cmd0
  ;; push whatever came back onto the stack
  sta stackaccess
  stz stackaccess+1
  jsr push16
  jmp next

;;; initialize the SD card and set it to SPI mode.
resetsd
  lda #SD_CS+SD_MOSI  ; set MOSI and CS to 1
  sta PORTB

  ;; toggle CLK at least 74 times (ie do 80, for 10 bytes of FF)
  ;;
  ldy #80
.(
initloop
  inc PORTB
  dec PORTB
  dey
  bne initloop
.)
  rts

cmd0
  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd0 (01+6*0 + 24*0 + 10010101)
  lda #SPI_CMD+0
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #%10010101    ; CRC plus end bit
  jsr sendbyte

  jsr setidle       ; set to idle to await input
  jsr getresponse   ; get single byte response

  ldy #SD_CS+SD_MOSI ; set CS and MOSI high to release card
  sty PORTB
  rts

setidle
  ldy #%00000010    ; CLK off, MOSI high, CS low
  sty PORTB
  rts  

;; send an $ff... this is basically just about creating delays
;; between commands
sendff
  ;; set cs to 1
  lda #SD_CS
  tsb PORTB
  lda #$ff
  jsr sendbyte
  rts

cmd8
  ;; set cs to 0
  lda #4
  trb PORTB

  ;; send cmd8 with parameter 0x000001aa
  lda #SPI_CMD+8
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  lda #1
  jsr sendbyte
  lda #$aa
  jsr sendbyte
  lda #$87          ; crc
  jsr sendbyte

  jsr setidle
  jsr await40bits

  lda #SD_CS+SD_MOSI  ; release card (CS and MOSI high)
  sta PORTB

  rts

cmd58
  ;; set cs to 0
  lda #4
  trb PORTB

  ;; send cmd58
  lda #SPI_CMD+58
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #%01110101
  jsr sendbyte

  jsr setidle
  jsr await40bits

  lda #SD_CS+SD_MOSI  ; release card (CS and MOSI high)
  sta PORTB

  rts


cmd55
  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd55 with parameter 0
  lda #SPI_CMD+55
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; crc
  jsr sendbyte

  jsr setidle
  jsr getresponse
  ldy #6
  sty PORTB
  rts

  
acmd41
  ;; set cs to 0
  lda #4
  trb PORTB

  lda #SPI_CMD+41
  jsr sendbyte
  lda #%01000000    ; bit 30 is HCS flag
  jsr sendbyte
  lda #16           ; bit 20 selects 3.2-3.3V
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; checksum, but doesn't matter in SPI mode?
  jsr sendbyte

  jsr setidle
  jsr getresponse

  ldy #6
  sty PORTB
  rts

;docmd17
;  jsr sendff
;  jsr cmd17
;  sta stackaccess
;  stz stackaccess+1
;  jsr push16
;  jmp next  

cmd17
  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd17 with parameter 0
  lda #SPI_CMD+17
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; crc, doesn't matter
  jsr sendbyte

  jsr setidle
  jsr getresponse
  rts


gettoken
  ; listen until we hear %11111110 (254/$FE)
  jsr recv8bits
  cmp #$FE
  bne gettoken
  rts


;;; read incoming data from the SD card and store it in memory at
;;; location pointed to by SCRATCH+8 and +9.
getblocks8

  ;; get first 256 bytes
.(
  ldy #0
loop
  jsr recv8bits
  sta (SCRATCH+8),y
  iny
  bne loop
.)
  inc SCRATCH+9
.(
  ;; get second 256 bytes
loop
  jsr recv8bits
  sta (SCRATCH+8),y
  iny
  bne loop
.)

  ; get CRC but ignore it. 16 bits, so two byte reads.
  jsr recv8bits
  jsr recv8bits

  jsr sendff        ; eight clock ticks to let SD card finish up
  rts


doloadblock
.(
  jsr sdloadbuf
  bcc done
  jmp abortdiskerror
done
  jmp next
.)

dosaveblock
.(
  jsr sdsavebuf
  bcc done
  jmp abortdiskerror
done
  jmp next
.)

dosdsave
  jsr sdsavegen
  jmp next


;; SECOND LAYER -- SD LAYER
;;


;;; load sector passed on the stack into the standard I/O buffer.
sdloadbuf
.(
  ;; check if this block is already loaded.
  lda stackbase+1,x
  cmp CURSEC
  bne startload
  lda stackbase+2,x
  cmp CURSEC+1
  bne startload
  lda stackbase+3,x
  cmp CURSEC+2
  bne startload
  lda stackbase+4,x
  cmp CURSEC+3
  bne startload
  clc               ; make sure carry is clear (error signal)
  bra skipload      ; jump to end, clean up stack

startload
  ;; update cache of current sector number
  lda stackbase+1,x
  sta CURSEC
  lda stackbase+2,x
  sta CURSEC+1
  lda stackbase+3,x
  sta CURSEC+2
  lda stackbase+4,x
  sta CURSEC+3

  ;; add load address onto the stack
  dex
  dex
  lda #<LBLOCK
  sta stackbase+1,x
  lda #>LBLOCK
  sta stackbase+2,x
  jmp sdloadtomem

skipload  
  jsr close2cells   ; discard the sector address
  rts
.)

;;; Load block specified by double on the stack (translating between
;;; number formats). Places data at a memory block signalled on
;;; the stack
;;; ( sector address -- )
sdloadtomem
.(
  ;; take memory target address off the stack and place it into
  ;; SCRATCH+8/9 (where getblock will look for it)
  lda stackbase+1,x
  sta SCRATCH+8
  lda stackbase+2,x
  sta SCRATCH+9
  inx
  inx

  jsr sendff

  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd17 with parameter from the stack
  lda #SPI_CMD+17
  jsr sendbyte
  lda stackbase+4,x
  jsr sendbyte
  lda stackbase+3,x
  jsr sendbyte
  lda stackbase+2,x
  jsr sendbyte
  lda stackbase+1,x
  jsr sendbyte
  lda #$95          ; crc, doesn't matter
  jsr sendbyte

  jsr setidle
  jsr getresponse
  cmp #0
  bne abortread

  jsr gettoken
  jsr getblocks8
.)

finishload
  jsr close2cells   ; clean up the stack
  clc               ; operation successful, so clear carry
  rts

abortread
  jsr close2cells   ; clean up the stack
  sec               ; set carry to signal failure
  rts


sdloadnext
  ;; copy cached block number onto the stack, adding one
  jsr open2cells
  clc
  lda CURSEC
  adc #1
  sta stackbase+1,x
  lda CURSEC+1
  adc #0
  sta stackbase+2,x
  lda CURSEC+2
  adc #0
  sta stackbase+3,x
  lda CURSEC+3
  adc #0
  sta stackbase+4,x

  ;; now jump to regular block load code, skipping cache check
  ;; (because we know it's different, clearly).
  jmp sdloadbuf


;;; save standard I/O buffer to sector identified by a double on
;;; the stack. this should really put things on the stack, but instead
;;; we save time to putting it directly into the parameter space.
sdsavebuf
  lda stackbase+1,x
  sta CURSEC
  lda stackbase+2,x
  sta CURSEC+1
  lda stackbase+3,x
  sta CURSEC+2
  lda stackbase+4,x
  sta CURSEC+3

  lda #<LBLOCK
  sta SCRATCH+8
  lda #>LBLOCK
  sta SCRATCH+9

  bra startsave

;;; save the buffer back to the block from which it was loaded,
;;; as cached at CURSEC
sdsaveback
  jsr open2cells
  lda CURSEC
  sta stackbase+1,x
  lda CURSEC+1
  sta stackbase+2,x
  lda CURSEC+2
  sta stackbase+3,x
  lda CURSEC+3
  sta stackbase+4,x

  lda #<LBLOCK
  sta SCRATCH+8
  lda #>LBLOCK
  sta SCRATCH+9

  bra startsave


;;; Save to block specified by double on the stack, translating
;;; between number formats. Takes address from stack to identify
;;; memory to save
sdsavefrommem
  ;; take memory address and put in in SCRATCH+8/9, where sendblocks8
  ;; will find it
  lda stackbase+1,x
  sta SCRATCH+8
  lda stackbase+2,x
  sta SCRATCH+9
  inx
  inx

startsave
.(
  jsr sendff

  ;; set cs to 0
  lda #SD_CS
  trb PORTB

;  lda #"1
;  jsr puta

  ;; send cmd24 with parameter from the stack
  lda #SPI_CMD+24
  jsr sendbyte
  lda stackbase+4,x
  jsr sendbyte
  lda stackbase+3,x
  jsr sendbyte
  lda stackbase+2,x
  jsr sendbyte
  lda stackbase+1,x
  jsr sendbyte
  lda #$95          ; crc, doesn't matter
  jsr sendbyte

;  lda #"2
;  jsr puta

.(
  jsr setidle
  jsr getresponse
  cmp #0            ; other things might have messed with Z lately
  beq continue

  bra abortsave
continue
.)

;  lda #"3
;  jsr puta

  jsr sendff
  ;; set cs to 0
  lda #SD_CS
  trb PORTB

;  lda #"4
;  jsr puta

  jsr sendtoken
  jsr sendblocks8
  jsr setidle

;  lda #"5
;  jsr puta

.(
  jsr getresponse
  and #%00001110
  cmp #4
  beq continue

  lda #$20
  jsr puta
  lda #$32          ; error code 2
  jsr puta
  bra abortsave
continue
.)

;  lda #"6
;  jsr puta

  ;; now wait until the card is ready again. card will hold the data
  ;; line low while it is processing.
.(
busywait
  jsr recv8bits
  beq busywait
.)

;  lda #"7
;  jsr puta

  ;; update the cache of the current sector number
  lda stackbase+1,x
  sta CURSEC
  lda stackbase+2,x
  sta CURSEC+1
  lda stackbase+3,x
  sta CURSEC+2
  lda stackbase+4,x
  sta CURSEC+3

finishsave
  jsr close2cells   ; clean up the stack

  ;; there is a huge amount of delay code in here. I think it's
  ;; just a construction/breadboard problem that is causing crashes
  ;; after writes, so with luck this can go away later...
.(
  ldy #255          ; added this loop to see if it prevents
pauseloop           ; crashes on SAVE-BUFFERS that might be caused
  nop               ; by power dips. BUG REMOVE THIS LATER.
  nop
  nop
  nop
  dey
  bne pauseloop
.)
.(
  ldy #255          ; added this loop to see if it prevents
pauseloop           ; crashes on SAVE-BUFFERS that might be caused
  nop               ; by power dips. BUG REMOVE THIS LATER.
  nop
  nop
  nop
  dey
  bne pauseloop
.)
.(
  ldy #255          ; added this loop to see if it prevents
pauseloop           ; crashes on SAVE-BUFFERS that might be caused
  nop               ; by power dips. BUG REMOVE THIS LATER.
  nop
  nop
  nop
  dey
  bne pauseloop
.)
.(
  ldy #255          ; added this loop to see if it prevents
pauseloop           ; crashes on SAVE-BUFFERS that might be caused
  nop               ; by power dips. BUG REMOVE THIS LATER.
  nop
  nop
  nop
  dey
  bne pauseloop
.)

  clc               ; all okay, clear error flag
  rts

abortsave
  jsr close2cells   ; clean up the stack
  sec               ; set flag to signal error
  rts
.)

sdsavenext
  ;; copy cached block number onto the stack, adding one
  jsr open2cells
  clc
  lda CURSEC
  adc #1
  sta stackbase+1,x
  lda CURSEC+1
  adc #0
  sta stackbase+2,x
  lda CURSEC+2
  adc #0
  sta stackbase+3,x
  lda CURSEC+3
  adc #0
  sta stackbase+4,x

  ;; now jump to regular block save code
  jmp sdsavebuf


;;;
;;; generic sd write of an arbitrary block of memory to
;;; an offset in a cluster. (addr count cluster offset)
;;; all parameters are regular 16-bit cells.
;;; after initial setup, three phases--
;;; in phase 1, write any partial block at the start of data
;;; in phase 2, write all full blocks
;;; in phase 3, write any partial block at the end
sdsavegen
.(
  ;; copy the base data out of the stack
  lda stackbase+7,x ; the base address for the write
  sta SCRATCH+10
  lda stackbase+8,x
  sta SCRATCH+11

  lda stackbase+5,x ; the number of bytes to write
  sta SCRATCH+12
  lda stackbase+6,x
  sta SCRATCH+13

  lda stackbase+1,x ; the offset into the cluster
  sta SCRATCH+14
  lda stackbase+2,x
  sta SCRATCH+15

  ;; move cluster number down the stack as a double
  stz stackbase+7,x  
  stz stackbase+8,x
  lda stackbase+3,x
  sta stackbase+5,x
  lda stackbase+4,x
  sta stackbase+6,x

  jsr close2cells   ; leaves only cluster double on stack
  jsr cltosector    ; convert cluster to sector number

  ;; if offset is > 512, we have to add offset DIV 512 to the
  ;; sector number and then reduce offset to offset MOD 512.
  lda SCRATCH+15
  and #254
  beq phase1

.(
  lsr
  clc
  adc stackbase+1,x
  sta stackbase+1,x
  bcc skip
  inc stackbase+2,x
  bne skip
  inc stackbase+3,x
  bne skip
  inc stackbase+4,x
skip
.)

  lda SCRATCH+15    ; for MOD 512, mask off upper bits
  and #1
  sta SCRATCH+15


;;; phase 1
;;; write the partial sector at the start of the write block
;;; if offset is a multiple of 512, there's nothing to do here.
;;; the amount of data to be written is 512-(offset mod 512).
;;; if we need to write into a partial block, we need to load
;;; that block first
;;; take offset and mask off bottom nine bits
phase1

  lda SCRATCH+14
  sta SCRATCH+6
  lda SCRATCH+15
  and #1
  sta SCRATCH+7     ; S+6/7 is offset mod 512
  ora SCRATCH+6     ; if both are zero, nothing to process
  bne continue
  jmp phase2

continue
  sec
  lda #0
  sbc SCRATCH+6
  sta SCRATCH+6
  lda #2
  sbc SCRATCH+7
  sta SCRATCH+7     ; S+6/7 now 512-(offset mod 512)

  ;; which block to load? take base sector number then
  ;; add offset div 512 to get sector to load
  ;; (BUT WE HAVE ALREADY DONE THIS NOW)

  ;; load block into default buffer
tag1
  jsr sdloadbuf
;  jsr close2cells this was for debugging

  ;; copy text onto the latter part of the buffer
  ;; number of bytes to copy is offset mod 512
  ;; location is IOSENTINEL minus offset mod 512

  ;; push srcaddr
  dex
  dex
  lda SCRATCH+10
  sta stackbase+1,x
  lda SCRATCH+11
  sta stackbase+2,x

  ;; push destaddr
  dex
  dex
  sec
  lda #<IOSENTINEL
  sbc SCRATCH+6
  sta stackbase+1,x
  lda #>IOSENTINEL
  sbc SCRATCH+7
  sta stackbase+2,x

  ;; push count. this is the lower of the total count
  ;; or the calculated count, so check that first.
  ;; (WHY IS THIS NOT JUST ALWAYS S+6/7?)
  sec
  lda SCRATCH+12
  sbc SCRATCH+6
  lda SCRATCH+13
  sbc SCRATCH+7
  bvc lower
  eor #$80
lower
  bpl notlower
  ;; yes, so restore original count
  lda SCRATCH+12
  sta SCRATCH+6
  lda SCRATCH+13
  sta SCRATCH+7
notlower

  dex
  dex
  lda SCRATCH+6
  sta stackbase+1,x
  lda SCRATCH+7
  sta stackbase+2,x

tag0
  jsr movesetup     ; set up the move parameters
  jsr moveupsub     ; do the copy
  jsr close3cells   ; clean up stack
tag0a

  ;; adjust counts
  clc               ; master base of copy region
  lda SCRATCH+10
  adc SCRATCH+6
  sta SCRATCH+10
  lda SCRATCH+11
  adc SCRATCH+7
  sta SCRATCH+11

  sec               ; master count of bytes to copy
  lda SCRATCH+12
  sbc SCRATCH+6
  sta SCRATCH+12
  lda SCRATCH+13
  sbc SCRATCH+7
  sta SCRATCH+13

  ;; write it out
tag2
  jsr sdsaveback

  ;; set up next sector number on stack
  jsr stacknextsector

;;; phase 2
;;; write some number of complete blocks
;;; how many complete blocks? count div 512
phase2
  lda SCRATCH+13
  lsr
  sta SCRATCH+6
  beq phase3        ; nothing to do here
  stz SCRATCH+7     ; S+7/8 is the number of complete blocks to write

ph2loop

  ;; sector number is already on the stack. add the current base
  ;; address from which we're going to save 512 bytes.
  dex
  dex
  lda SCRATCH+10
  sta stackbase+1,x
  lda SCRATCH+11
  sta stackbase+2,x

tag3
  jsr sdsavefrommem ; save the data
  ;jsr close3cells this was for debugging

  ;; load next block address onto stack
  jsr stacknextsector

  ;; increment base address by 512
  clc
  lda SCRATCH+11
  adc #$02
  sta SCRATCH+11

  ;; not decrementing the master count here -- leave to end

  ;; decrement number of blocks by 1
  dec SCRATCH+6
  bne ph2loop       ; loop while more to do

  ;; set count to count mod 512
  lda SCRATCH+13
  and #$01
  sta SCRATCH+13

;;; phase 3
;;; write whatever partial sector is left over
;;; it's the number of bytes in SCRATCH+12/13
;;; but first we need to load the block, in order to preserve
;;; the data that we don't overwrite.
phase3
  ;; anything left to do?
  lda SCRATCH+12
  ora SCRATCH+13
  beq endphase3

  ;; load the block
  ;; sector address is already on the stack
tag4
  jsr sdloadbuf
  ;jsr close2cells this was for debugging

  ;; set up the parameters to copy remaining data into
  ;; the IO buffer

  ;; push srcaddr
  dex
  dex
  lda SCRATCH+10
  sta stackbase+1,x
  lda SCRATCH+11
  sta stackbase+2,x

  ;; push destaddr
  dex
  dex
  clc
  lda #<LBLOCK
  sta stackbase+1,x
  lda #>LBLOCK
  sta stackbase+2,x

  ;; push count
  dex
  dex
  lda SCRATCH+12
  sta stackbase+1,x
  lda SCRATCH+13
  sta stackbase+2,x

  jsr movesetup     ; set up copy parameters
  jsr moveupsub     ; do the copy
  jsr close3cells   ; clean up the stack

  ;; save the block
tag5
  jsr sdsaveback

endphase3
  rts
.)


stacknextsector
  ;; restore sector number on stack?
  dex
  dex
  dex
  dex
  clc
  lda CURSEC
  adc #1
  sta stackbase+1,x
  lda CURSEC+1
  adc #0
  sta stackbase+2,x
  lda CURSEC+2
  adc #0
  sta stackbase+3,x
  lda CURSEC+3
  adc #0
  sta stackbase+4,x
  rts



sendtoken
  lda #254
  jsr sendbyte
  rts


sendblocks8
  ;; send the first 256 bytes
  ldy #0
.(
sendloop
  lda (SCRATCH+8),y
  jsr sendbyte
  iny
  bne sendloop
.)

  inc SCRATCH+9

  ;; send the second 256 bytes. y is already 0.
.(
sendloop
  lda (SCRATCH+8),y
  jsr sendbyte
  iny
  bne sendloop
.)
  lda #0
  jsr sendbyte      ; types for CRC
  jsr sendbyte
  rts

;; UPPER LAYER - FAT16 FILESYSTEM
;;

;; load the root directory
sdloadroot
  jsr open2cells
  lda #1            ; sector 513 == 0x00000201
  sta stackbase+1,x
  lda #2
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x
  jmp sdloadbuf
  

;;; List files from the root directory
;;;
dodir
.(
  clc
  jsr dirsub
  bcs error
  jmp next
error
  jmp abortdiskerror
.)

;;; this is structured as a subroutine so that we can also make it
;;; available to the disk manager. that means that errors should be
;;; returned as a flag rather than aborting directly.
dirsub
  ;; BUG should check that there's a disk mounted and present
  ;; load the root directory -- just hardcoding location for now
  ;; BUG calculate this properly
  jsr sdloadroot
  bcc header
  rts               ; otherwise, return with carry flag set

header
  jsr crlf
  lda #<dirofmsg
  sta PRINTVEC
  lda #>dirofmsg
  sta PRINTVEC+1
  jsr printvecstr

  ldy #0
.(
loop
  lda MBR_LABEL,y
  cmp #$20
  beq done
  jsr puta
  iny
  cpy #11
  beq done
  bra loop
done
.)
  jsr crlf
  
nextdirblock
  ;; set pointer to first entry
  lda #<LBLOCK
  sta SCRATCH+6
  lda #>LBLOCK
  sta SCRATCH+7

printdirent         ; print the entry pointed to by SCRATCH+6

  lda (SCRATCH+6)
  beq endofdir      ; if it's null, we're done
  cmp #$e5          ; $e5 indicates file is deleted, so skip it
  beq nextdirent

  ldy #11           ; check for hidden file
  lda (SCRATCH+6),y
  and #2
  bne nextdirent    ; skip hidden files

  ;; print two spaces
  lda #$20
  jsr puta
  jsr puta

  ;; print the file name (and then extension)
  ;; we always print eight characters for the filename because
  ;; they are padded with spaces
  ldy #0
.(
nextchar
  lda (SCRATCH+6),y
  jsr puta
  iny
  cpy #8            ; stop after eight characters
  bne nextchar
.)

  lda #"."
  jsr puta

printext            ; now print extension, if there is one
  lda (SCRATCH+6),y
  jsr puta
  iny
  cpy #11
  bne printext

  lda #8            ; set up field size parameter for rprint
  sta stackaccess
  stz stackaccess+1
  jsr push16

  ldy #28           ; bytes 28-31 are the filesize in bytes
  jsr open2cells
  lda (SCRATCH+6),y
  sta stackbase+1,x
  iny
  lda (SCRATCH+6),y
  sta stackbase+2,x
  iny
  lda (SCRATCH+6),y
  sta stackbase+3,x
  iny
  lda (SCRATCH+6),y
  sta stackbase+4,x
  jsr rprint32s
  jsr crlf

nextdirent
.(
  clc               ; add 32 to skip to next entry
  lda SCRATCH+6
  adc #32
  sta SCRATCH+6
bcc done
  inc SCRATCH+7
done

  ;; check if we have run off the end of the input buffer space
  ;; (by comparing to the MSB of IOSENTINEL, which is the space
  ;; right after). if so, load the next block.
  ;; BUG there are 32 blocks allocated to the root directory. should
  ;; count to make sure that we don't exceed that. but I'm presuming
  ;; for the moment that we'll hit a null entry before then.
  ;; BUG for this to work, IOSENTINEL must be PAGE-aligned
  lda SCRATCH+7
  cmp #>IOSENTINEL
  bne endnext       ; still fine, continue
  jsr sdloadnext
  bcc nextdirblock
  rts               ; otherwise return with carry set
endnext
.)
  bra printdirent

endofdir
  jsr crlf
  rts


;; NOTE this uses SCRATCH+4,5,12,13,14,15 (BUG still true?)
doshow
  jsr readnext      ; get next word and put it into input buffer
  jsr showsub
.(
  bcc continue      ; error reported?
  jmp abortnofile
continue
.)
  jmp next


;;; this is broken out as a subroutine so that it can be shared
;;; with the disk manager. presumes on entry that the filename
;;; is in WORD.
showsub
  jsr finddirword   ; look up in the directory
.(
  bcc continue
  rts
continue
.)
  jsr crlf

  ;; grab the pointer to the data
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

  ;; remove pointer from the stack
  inx
  inx

  ;; first, grab the cluster number for the file and push onto
  ;; stack (overwriting directory sector number) as a double
  ldy #26
  lda (SCRATCH),y ; LSB
  sta stackbase+1,x
  iny
  lda (SCRATCH),y ; MSB
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  ;; grab the file size and stash it
  iny
  lda (SCRATCH),y
  sta SCRATCH+12
  iny
  lda (SCRATCH),y
  sta SCRATCH+13
  iny
  lda (SCRATCH),y
  sta SCRATCH+14
  iny
  lda (SCRATCH),y
  sta SCRATCH+15

  ;; don't need to hold onto SCRATCH any more, it's safe to reuse

  ;; turn block count on stack into sector count, and load the sector
  jsr cltosector
  jsr sdloadbuf

  ;; now type what's in the block, up to the file size. we print in
  ;; blocks of 256 bytes, but we do so twice because the buffer is
  ;; actually 512 bytes.
  ;; BUG we ignore anything over 32k for the file size

  ;jsr crlf

typeblock
.(
  ;; by default, print 256 characters
  lda #255
  sta SCRATCH
  ;; are there fewer than 256 characters to process?
  lda SCRATCH+13
  beq under256
  dec SCRATCH+13    ; we will print 256 characters, take 256 off the count
  bra first256
under256
  lda SCRATCH+12    ; < 256, so lowest byte is # of chars to print
  beq endshow       ; if it's zero, we're done
  dec               ; range from 0 rather than 1
  sta SCRATCH
  stz SCRATCH+12
.)

first256
  ldy #0
.(
typechar
  lda LBLOCK,y
  jsr puta
  cmp #10           ; in the case of an LF, add a CR too
  bne nextchar
  lda #13
  jsr puta
nextchar
  cpy SCRATCH
  beq done
  iny
  bra typechar
done
.)

  ;; now consider the second 256 characters in the sector
.(
  ;; by default, print 256 characters
  lda #255
  sta SCRATCH
  ;; are there fewer than 256 characters to process?
  lda SCRATCH+13
  beq under256
  dec SCRATCH+13    ; update count for the end of the print
  bra second256
under256
  lda SCRATCH+12    ; < 256, so lowest byte is # of chars to print
  beq endshow       ; if it's zero, we're done
  dec               ; re-range to zero-index
  sta SCRATCH
  stz SCRATCH+12    ; after which, there will be none left
.)

second256
  ldy #0
.(
typechar
  lda HBLOCK,y
  jsr puta
  cmp #10           ; in the case of an LF, add a CR too
  bne nextchar
  lda #13
  jsr puta
nextchar
  cpy SCRATCH
  beq done
  iny
  bra typechar
done
.)

  ;; if there is more data, load the next block and repeat
  lda SCRATCH+13
  bne nextblock
  lda SCRATCH+12
  beq endshow

nextblock
  jsr sdloadnext
  jmp typeblock

endshow
;  jsr crlf
  clc
  rts

;doloadfile
;  jsr readnext
;  jsr loadfilesub
;  jmp next

;;; load a file into a designated block of memory. on entry,
;;; WORD contains the filename and stack has the destination address.
loadfilesub
.(
  ;; take the destination address off the stack and stash it
  lda stackbase+1,x
  pha
  lda stackbase+2,x
  pha
  inx
  inx

  jsr finddirword

.(
  bcc continue
  pla
  pla
  rts               ; return with carry set to signal failure
continue
.)
  ;; grab pointer to the data
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

  ;; remove pointer from the stack
  inx
  inx

  ;; grab the file size and stash it as the "still to read" count
  ldy #28
  lda (SCRATCH),y
  sta SCRATCH+2
  iny
  lda (SCRATCH),y
  sta SCRATCH+3
  iny
  lda (SCRATCH),y
  sta SCRATCH+4
  iny
  lda (SCRATCH),y
  sta SCRATCH+5

  ;; next, grab the file cluster number and push onto stack as a double.
  ;; we put this on top of the directory cluster number that's there
  ;; because we don't need it
  ldy #26
  lda (SCRATCH),y ; LSB
  sta stackbase+1,x
  iny
  lda (SCRATCH),y ; MSB
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  ;; turn cluster number into block number
  jsr cltosector

  ;; make a note of the sector number, leaving it on the stack
  lda stackbase+1,x
  sta SCRATCH+10
  lda stackbase+2,x
  sta SCRATCH+11
  lda stackbase+3,x
  sta SCRATCH+12
  lda stackbase+4,x
  sta SCRATCH+13

  ;; retreive and store destination address, add to stack
  dex
  dex
  pla
  sta SCRATCH+7
  sta stackbase+2,x
  pla
  sta SCRATCH+6
  sta stackbase+1,x

nextsector
  ;; is there less then 512 types left to read?
  ;; we ignore upper two bytes of length (file limit is 32K) so
  ;; just look at whether second byte is 0 or 1.
  lda SCRATCH+3
  beq lastsector
  cmp #01
  beq lastsector

  jsr sdloadtomem

  ;; subtract 512 from the count of data to read
  sec
  lda SCRATCH+3
  sbc #2
  sta SCRATCH+3
  lda SCRATCH+4     ; +4 and +5 perhaps not needed?
  sbc #0
  sta SCRATCH+4
  lda SCRATCH+5
  sbc #0
  sta SCRATCH+5

  ;; add one to the sector count and add it to the stack
  jsr open2cells
  clc
  lda SCRATCH+10
  adc #1
  sta SCRATCH+10
  sta stackbase+1,x
  lda SCRATCH+11
  adc #0
  sta SCRATCH+11
  sta stackbase+2,x
  lda SCRATCH+12
  adc #0
  sta SCRATCH+12
  sta stackbase+3,x
  lda SCRATCH+13
  adc #0
  sta SCRATCH+13
  sta stackbase+4,x

  ;; add 512 to the data pointer
  clc
  lda SCRATCH+7
  adc #2
  sta SCRATCH+7

  ;; put it on the stack for the next read
  dex
  dex
  lda SCRATCH+6
  sta stackbase+1,x
  lda SCRATCH+7
  sta stackbase+2,x

  bra nextsector

lastsector

  ;; the last sector -- laod the block into the default buffer
  ;; and copy as much as we need.
  inx               ; drop memory pointer from the stack
  inx  
  jsr sdloadbuf     ; fill the buffer
  lda #<LBLOCK
  sta SCRATCH
  lda #>LBLOCK
  sta SCRATCH+1
  lda SCRATCH+3     ; more than 256 characters to copy?
  beq last256       ; no
  ldy #0            ; yes. copy 256 to destination
loop1
  lda (SCRATCH),y
  sta (SCRATCH+6),y
  iny
  bne loop1
  inc SCRATCH+1     ; bump pointer to useful data
  inc SCRATCH+7
last256
  lda SCRATCH+2     ; all done?
  beq done
  tya
loop2
  dey
  lda (SCRATCH),y
  sta (SCRATCH+6),y
  cpy #0
  bne loop2
done
  clc
.)
  rts


  





;;; USING specifies the block file from which subsequent block
;;; operations should load and save.
dousing
  jsr readnext      ; get next word and put it into input buffer
  jsr finddirword   ; search the root directory

.(
  bcc continue
  jmp abortnofile

continue
.)
  ;; copy the directory pointer into SCRATCH
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

  ;; drop it from the stack
  inx
  inx

  ;; now check file size to calculate largest block count. File size
  ;; is at bytes 28-31 of the directory entry, but I need to divide by
  ;; 1024, which means dropping the bottom byte altogether and shifting
  ;; right by two.
  ldy #29
  lda (SCRATCH),y
  sta stackbase+1,x
  iny  
  lda (SCRATCH),y
  sta stackbase+2,x
  iny  
  lda (SCRATCH),y
  sta stackbase+3,x
  iny  
  stz stackbase+4,x

  lsr stackbase+3,x ; top byte is zero, so ignore it
  ror stackbase+2,x
  ror stackbase+1,x
  lsr stackbase+3,x ; shift a second time
  ror stackbase+2,x
  ror stackbase+1,x

  ;; a block count for any file up to 256k should fit in just one byte,
  ;; so I'm going going to stash and test stackbase+1,x
  lda stackbase+1,x
  sta USEBLKS

  ;; next, grab the file cluster number and push onto stack as a double.
  ;; it is stored at bytes 26 and 27 of the directory entry. we just
  ;; write it over the directory cluster number that's on the stack
  ;; because we don't need that.
  ldy #26
  lda (SCRATCH),y   ; LSB
  sta stackbase+1,x
  iny
  lda (SCRATCH),y   ; MSB
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  ;; turn cluster count on stack into sector count, and stash
  ;; it for future reference
  jsr cltosector
  lda stackbase+1,x
  sta USEBASE
  lda stackbase+2,x
  sta USEBASE+1
  lda stackbase+3,x
  sta USEBASE+2
  lda stackbase+4,x
  sta USEBASE+3

  ;; clean up the stack
  jsr close2cells

  ;; the old buffers are no longer useful. zero them out
  ;; and reset the pointers.
  stz PREV
  stz PREV+1
  lda #<FIRST
  sta USE
  lda #>FIRST
  sta USE+1
  jsr zerobuffers

  ;; cache the name of the file we are using
.(
  ldy #0
copyloop
  lda (SCRATCH+6),y
  sta USENAME,y
  iny
  cpy #11
  bne copyloop
.)

  jmp next


;;; USING? prints the name of the file we're USING.
;;; do the work.
dousingq
.(
  lda USEBASE+3
  bne endusingq
  lda #32
  jsr puta
  lda #<USENAME
  sta stackaccess
  lda #>USENAME
  sta stackaccess+1
  ldy #0
nameloop
  lda (stackaccess),y
  cmp #32
  beq donename
  jsr puta
  iny
  cpy #8
  bne nameloop
donename
  lda #".
  jsr puta
  ldy #8
extloop
  lda (stackaccess),y
  cmp #32
  beq endusingq
  jsr puta
  iny
  cpy #11
  bne extloop
endusingq
  jmp next
.)



;; convert a cluster address into a sector address
;; calculation is cluster-2 * sectors/cluster + resv + len FATs + len root
;; generally, cluster-2 * 64 + 545
cltosector
.(
  ;; subtract 2
  sec
  lda stackbase+1,x
  sbc #2
  sta stackbase+1,x
  lda stackbase+2,x
  sbc #0
  sta stackbase+2,x
  lda stackbase+3,x
  sbc #0
  sta stackbase+3,x
  lda stackbase+4,x
  sbc #0
  sta stackbase+4,x
done
.)

  ;; shift left 6 times, to multiply by 64
  clc
  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  rol stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  ;; add 545 ( = 512+33 = 2*256 + 33)
.(
  clc
  lda stackbase+1,x
  adc #33
  sta stackbase+1,x
  lda stackbase+2,x
  adc #2
  sta stackbase+2,x
  bcc skip
  inc stackbase+3,x
  bne skip
  inc stackbase+4,x
skip
.)

  rts


;;; take a cluster address on the stack and return the sector number
;;; of the relevant FAT block, and the offset within it.
cltofat
  ;; we are going from two bytes on the stack to six, so
  ;; reserve space
  jsr open2cells

  ;; cluster number (C) is now at stacbkbase+5/6
  ;; the offset is C mod 256 * 2.
  lda stackbase+5,x
  sta stackbase+1,x
  stz stackbase+2,x
  asl stackbase+1,x
  rol stackbase+2,x

  ;; the sector is C div 256 + 1, so just shift by one full byte and
  ;; add one
  clc
  lda stackbase+6,x
  adc #1
  sta stackbase+3,x
  lda #0
  adc #0
  sta stackbase+4,x
  stz stackbase+5,x
  stz stackbase+6,x
  rts


;;; TEMPORARY FOR TESTING
;docltofat
;  jsr cltofat
;  jmp next

;dofatat
;  jsr fatatsub
;  jmp next

;fatatsub
;  jsr cltofat
;  lda stackbase+2,x
;  pha
;  lda stackbase+1,x
;  pha
;  inx
;  inx
;  jsr sdloadbuf
;  dex
;  dex
;  clc
;  pla
;  adc #<LBLOCK
;  sta stackbase+1,x
;  pla
;  adc #>LBLOCK
;  sta stackbase+2,x
;  jsr pop16
;  dex
;  dex
;  ldy #1
;  lda (stackaccess)
;  sta stackbase+1,x
;  lda (stackaccess),y
;  sta stackbase+2,x
;  rts

  
;dofatset
;  jsr fatsetsub
;  jmp next

;;; stack is a value and a cluster number; saves the value at the
;;; right point in the FAT. There are two copies of the FAT, so
;;; write both of them.
fatsetsub
  jsr cltofat       ; get FAT sector and offset
  lda stackbase+2,x ; put offset out of the way
  pha
  lda stackbase+1,x
  pha
  inx
  inx
  jsr sdloadbuf     ; load sector to buffer
  clc
  pla               ; get offset back
  adc #<LBLOCK      ; add LBLOCK to offset to find entry
  sta SCRATCH       ; put address in SCRATCH
  pla
  adc #>LBLOCK
  sta SCRATCH+1
  jsr pop16         ; move new value into stackaccess
  ldy #1
  lda stackaccess
  sta (SCRATCH)     ; store at location pointed to by SCRATCH
  lda stackaccess+1
  sta (SCRATCH),y

;  jsr open2cells    ; make space for a double on the stack
;  lda CURSEC        ; write in current disk block number
;  sta stackbase+1,x ; cached at load time
;  lda CURSEC+1
;  sta stackbase+2,x
;  lda CURSEC+2
;  sta stackbase+3,x
;  lda CURSEC+3
;  sta stackbase+4,x
;  jsr sdsavebuf     ; write back the block
  jsr sdsaveback    ; write back the block
  inc CURSEC+1      ; jump ahead by 256 blocks for second FAT
  jsr sdsaveback    ; do it again

;  lda #"!
;  jsr puta
  rts


dofile
  jsr finddirstack  ; look up filename from stack
.(
  bcc continue      ; found the file?
  jmp abortnofile
continue
.)
  jmp next

;dofreefat
;  jsr findfreecluster
;  jmp next


;;; find first free cluster on the disk by searching the FAT
findfreecluster
.(

  ;; SCRATCH+2...6 is a block pointer, counting sectors that make
  ;; up the FAT. SCRATCH and SCRATCH+1 point to entires inside the
  ;; loaded FAT.

  ;; set up the sector pointer for the start of the FAT
  lda #1
  sta SCRATCH+2
  stz SCRATCH+3
  stz SCRATCH+4
  stz SCRATCH+5

searchnextblock
  ;; load a sector of the FAT. Put sector number on the stack and load.
  jsr open2cells
  lda SCRATCH+2
  sta stackbase+1,x
  lda SCRATCH+3
  sta stackbase+2,x
  lda SCRATCH+4
  sta stackbase+3,x
  lda SCRATCH+5
  sta stackbase+4,x
  jsr sdloadbuf

  ;; set up the offset pointer
  lda #<LBLOCK
  sta SCRATCH
  lda #>LBLOCK
  sta SCRATCH+1

  ;; cycle through entries
nextfatentry
  ;; is this entry free?
  ldy #1
  lda (SCRATCH)
  ora (SCRATCH),y
  beq free

  ;; move onto next entry
.(
  clc
  lda SCRATCH
  adc #2
  sta SCRATCH
  bcc skip
  inc SCRATCH+1
skip
.)
  ;; end of block?
  lda SCRATCH
  cmp #<IOSENTINEL
  bne nextfatentry
  lda SCRATCH+1
  cmp #>IOSENTINEL
  bne nextfatentry

  ;; inc block count
  clc
  lda SCRATCH+2
  adc #1
  sta SCRATCH+2
  bcc skip
  lda SCRATCH+3
  adc #0
  sta SCRATCH+3
skip
  ;; that's enough, because we never touch beyone byte 2
  ;; out of blocks?
  ;; # blocks in FAT is 256, so last block is 0x00000100
  ;; so 0x00000101 is overflow
  lda SCRATCH+2
  cmp #01
  bne searchnextblock
  lda SCRATCH+3
  cmp #01
  bne searchnextblock

  ;; out of blocks, so no luck
  dex
  dex
  stz stackbase+1,x
  stz stackbase+2,x
  sec
  bra endfind

free
  ;; found a free entry. calculate the cluster number. Take the sector
  ;; number, subtract one, multiply by 256 and add the block pointer,
  ;; minus LBLOCK, divided by two

  sec
  lda SCRATCH+2
  sbc #1
  sta SCRATCH+2
  lda SCRATCH+3
  sbc #0
  sta SCRATCH+3
  ;; stop there because we know it's zero after that

  lda SCRATCH+3
  sta SCRATCH+4
  lda SCRATCH+2
  sta SCRATCH+3
  stz SCRATCH+2

  sec
  lda SCRATCH       ; subtract lBLOCK
  sbc #<LBLOCK
  sta SCRATCH+2
  lda SCRATCH+1
  sbc #>LBLOCK
  sta SCRATCH+1
  lsr SCRATCH+2     ; divide by two
  ror SCRATCH+1

  clc
  lda SCRATCH+1
  adc SCRATCH+3
  sta SCRATCH+3
  ;; again, we can stop here

  dex
  dex
  lda SCRATCH+2
  sta stackbase+1,x
  lda SCRATCH+3
  sta stackbase+2,x
  clc
endfind
  rts
.)


;;; Look up filename in root directory. On success, the
;;; relevant directory sector is left in the LBLOCK/HBLOCK area,
;;; and the stack contains both the double-precision sector number
;;; and a pointer to the matching entry within it. On failure,
;;; stack is unchanged and carry flag is set.
;;; There are two entry-points. finddirword takes the filename
;;; from WORD, while finddirstack takes a c-string on the stack.
finddirword
  lda #<WORD
  sta stackaccess
  lda #>WORD
  sta stackaccess+1
  bra finddirshared

finddirstack
  jsr pop16

finddirshared
  jsr mkcanon       ; transform filename into canonical form

  jsr sdloadroot    ; load the root directory

  lda #<LBLOCK      ; set up pointer into directory data
  sta SCRATCH+6
  lda #>LBLOCK
  sta SCRATCH+7

.(
  ;; loop until end of directory block or match
matchloop
  lda (SCRATCH+6)   ; null entry (ie, end of directory)?
  beq endofdirectory

  ;; test a single directory entry
matchentry
  ldy #0
nameloop
  lda (SCRATCH+6),y
  cmp (PADPTR),y
  bne matchfail
  iny
  cpy #11
  bne nameloop
success
  jsr open3cells    ; found a match. return pointer and sector number.
  lda SCRATCH+6
  sta stackbase+1,x
  lda SCRATCH+7
  sta stackbase+2,x
  lda CURSEC
  sta stackbase+3,x
  lda CURSEC+1
  sta stackbase+4,x
  lda CURSEC+2
  sta stackbase+5,x
  lda CURSEC+3
  sta stackbase+6,x
  clc               ; clear carry to signal success
  rts

matchfail
  ;; this name doesn't match so get next directory entry
  clc
  lda SCRATCH+6     ; bump pointer
  adc #32           ; entries are 32 bytes long
  sta SCRATCH+6
  lda SCRATCH+7
  adc #0
  sta SCRATCH+7
  cmp #>PAD         ; run off the end of the buffer?
  bne matchloop
  jsr sdloadnext    ; load next block
  lda #<LBLOCK      ; reset the directory pointer to new block
  sta SCRATCH+6
  lda #>LBLOCK
  sta SCRATCH+7
  bra matchloop     ; loop to test this one

;; hit the end of directory without a match. return 0.
endofdirectory
  stz SCRATCH+6
  stz SCRATCH+7
  sec               ; set carry to signal failure
  rts
.)


;;; find a free directory entry. returns cluster and offset.
findfreedir
.(
  jsr sdloadroot    ; load the root directory

searchonesector
  lda #<LBLOCK      ; set up pointer into directory data
  sta SCRATCH+6
  lda #>LBLOCK
  sta SCRATCH+7

  ;; loop until end of directory block or match
matchloop
  ;; need to test for end of directory, which is basically when
  ;; we have just loaded beyond the actual directory.
  ;; directory begins at block 513, and is 16 sectors long, so
  ;; 529 is end. Use 17 in the low byte as sentinel
  lda CURSEC
  cmp #11
  beq endofdirectory

  ;; test a single directory entry
matchentry
  ;; entry is empty if first byte is either zero or $E5
  lda (SCRATCH+6)
  beq success       ; 0 means slot is free
  cmp #$E5          ; $E5 also means slot is free
  bne matchfail
success
  jsr open3cells    ; found a match. return pointer and sector number.
  sec
  lda SCRATCH+6
  sbc #<LBLOCK
  sta stackbase+1,x
  lda SCRATCH+7
  sbc #>LBLOCK
  sta stackbase+2,x
  lda CURSEC
  sta stackbase+3,x
  lda CURSEC+1
  sta stackbase+4,x
  lda CURSEC+2
  sta stackbase+5,x
  lda CURSEC+3
  sta stackbase+6,x
  clc               ; clear carry to signal success
  rts

matchfail
  ;; this slot is full, so move on
  clc
  lda SCRATCH+6     ; bump pointer
  adc #32           ; entries are 32 bytes long
  sta SCRATCH+6
  lda SCRATCH+7
  adc #0
  sta SCRATCH+7
  cmp #>PAD         ; run off the end of the buffer?
  bne matchloop
  jsr sdloadnext    ; load next block
;  lda #"+
;  jsr puta
  bra searchonesector

;; hit the end of directory without a match. return 0.
endofdirectory
  stz SCRATCH+6
  stz SCRATCH+7
  sec               ; set carry to signal failure
  rts
.)


;;; Filenames are stored in directories in FAT16 in a canonical format:
;;; all caps, with the base name padded to eight characters using spaces,
;;; and the extension padded to three. Take a c-string from stackaccess
;;; and rewrite it onto the PAD in canonical form.
mkcanon
  ;; reset PADPTR
  lda #<PAD
  sta PADPTR
  lda #>PAD
  sta PADPTR+1

  ;; start by filling destination with default characters
.(
  ldy #10
  lda #$20
loop
  sta (PADPTR),y
  dey
  bne loop
.)

  ;; now, copy filename into the canonicalized version, switching
  ;; lower case to upper case along the way
.(
  lda (stackaccess) ; null-terminate the string, just in case
  tay
  iny
  lda #0
  sta (stackaccess),y

  ldy #1            ; skip the first byte (char count)
  lda PADPTR
  sta SCRATCH
  lda PADPTR+1
  sta SCRATCH+1
loop
  lda (stackaccess),y
  cmp #"."
  beq endname
  cmp #"a"
  bcc copy
  cmp #"{"          ; first character after "z"
  bcs copy
  and #%11011111    ; convert lower to upper
copy  
  sta (SCRATCH)
  inc SCRATCH       ; BUG depends on PAD not crossing page boundary
  iny
  cpy #9
  beq endname
  bra loop
endname
  iny               ; skip "."
  clc
  lda PADPTR
  adc #8
  sta SCRATCH       ; BUG ignores upper byte, presumes no page boundary
.)

  ;; finally, copy the extension.
.(
extloop
  lda (stackaccess),y
  beq done
  cmp #"a"
  bcc copy
  cmp #"{"          ; first character after "z"
  bcs copy
  and #%11011111    ; convert lower to upper
copy  
  sta (SCRATCH)
  inc SCRATCH
  iny
  cpy #3
  bne extloop
done
.)
  rts


donewfile
.(
  jsr dup16         ; copy string address
  jsr finddirstack  ; look it up
  bcs continue      ; make sure file name DOESN'T exist
  jmp abortexists
continue
  clc
.)
  jsr newfilesub
  jmp next

;;; Create a new file named by c-string on stack. Leave directory
;;; details on the stack, like FILE. Sets file to be length 0 but
;;; does allocate a cluster for it in the FAT.
newfilesub

  ;; find available cluster. returns cluster number.
  jsr findfreecluster

  ;; cache cluster #
  lda stackbase+1,x
  sta SCRATCH+14
  lda stackbase+2,x
  sta SCRATCH+15

  ;; allocate cluster. set up the stack with the write value ($ffff)
  ;; and cluster number, then call routine to set it.
  lda #$ff
  sta stackbase+1,x
  sta stackbase+2,x
  dex
  dex
  lda SCRATCH+14
  sta stackbase+1,x
  lda SCRATCH+15
  sta stackbase+2,x

  jsr fatsetsub

  ;; find directory slot. returns sector and offset. sector is loaded.
  jsr findfreedir
  bcs abortmkfile

;  clc  carry guaranteed clear here
  lda stackbase+1,x
  adc #<LBLOCK
  sta SCRATCH+12
  lda stackbase+2,x
  adc #>LBLOCK
  sta SCRATCH+13

  ;; grab the name string address off the stack, although it's
  ;; buried now.
  lda stackbase+7,x
  sta stackaccess
  lda stackbase+8,x
  sta stackaccess+1

  jsr mkcanon       ; rewrite name in canonical form

  ;; NOTE stack is 8 bytes deep here after findfreedir

  ;; set name
  dex
  dex
  lda SCRATCH+12
  sta stackbase+1,x
  lda SCRATCH+13
  sta stackbase+2,x

  jsr copypadname
  inx
  inx

  ;; set attributes
  lda #0
  ldy #$0B
  sta (SCRATCH+12),y

  ;; set cluster #
  ldy #$1A
  lda SCRATCH+14
  sta (SCRATCH+12),y
  iny
  lda SCRATCH+15
  sta (SCRATCH+12),y

  ;; set size to zero
  ldy #$1C
  lda #0
  sta (SCRATCH+12),y
  iny
  sta (SCRATCH+12),y
  iny
  sta (SCRATCH+12),y
  iny
  sta (SCRATCH+12),y

  ;; stack currently has directory block and offset for
  ;; entry we've been filling. Drop offset and write
  ;; directory block.
  inx
  inx
  jsr sdsavebuf

  ;; we've ended with just the name on the stack. set up the
  ;; return stack that we want
  jsr open2cells
  lda CURSEC
  sta stackbase+3,x
  lda CURSEC+1
  sta stackbase+4,x
  lda CURSEC+2
  sta stackbase+5,x
  lda CURSEC+3
  sta stackbase+6,x
  lda SCRATCH+12
  sta stackbase+1,x
  lda SCRATCH+13
  sta stackbase+2,x

  ;; return
  rts

abortnewfile
abortmkfile
  ;; BUG BUG UNALLOCATE FAT AND ISSUE ERROR MESSAGE
  rts



;;; TESTING
dorename
  jsr renamefile
  jmp next

;;; rename a file, taking both old and new names from the input stream
renamefile
  jsr readnext
  jsr finddirword
.(
  bcc continue
  jmp abortgenericsub
continue
.)

  ;; at this point, stack should have sector number and pointer,
  ;; and the sector should be loaded in the I/O buffer.
  jsr readnext      ; get destination filename
  ; jsr mkcanon       ; canonicalize (not needed, lookupdir will do it)

  ;; make sure that the destination file does NOT exist
.(
  jsr finddirword
  bcs continue
  jsr close3cells   ; throw away results from directory lookup
  jsr close3cells   ; and from the last one
  bra abortgenericsub
continue
  ;; reload original block in case we just trashed it
  jsr open2cells
  lda stackbase+7,x
  sta stackbase+1,x
  lda stackbase+8,x
  sta stackbase+2,x
  lda stackbase+9,x
  sta stackbase+3,x
  lda stackbase+10,x
  sta stackbase+4,x
  jsr sdloadbuf

.)

  jsr copypadname   ; copy name from pad to address on stack
  inx               ; drop that pointer from the stack
  inx
  clc
  jsr sdsavebuf     ; write back the directory data
  bcs abortgenericsub

  rts

abortgenericsub
  lda #<generic
  sta PRINTVEC
  lda #>generic
  sta PRINTVEC+1
  jsr printvecstr
  rts

;;; TEMPORARY

dodelete
  jsr deletefile
  jmp next


deletefile
  jsr readnext
  jsr finddirword
.(
  bcc continue
  jmp abortgenericsub
continue
.)

  lda stackbase+1,x ; grab data address
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

  ldy #$1a          ; cache cluster number
  lda (SCRATCH),y
  sta SCRATCH+2
  iny
  lda (SCRATCH),y
  sta SCRATCH+3

  lda #$e5          ; mark directory entry as unused
  sta (SCRATCH)
  inx               ; drop pointer from stack,
  inx               ; leaving just sector number
  jsr sdsavebuf     ; write back directory

  ;; now mark cluster as unused. First, put $0000 (free) on stack
  jsr open2cells
  stz stackbase+3,x
  stz stackbase+4,x
  ;; now put cached cluster number on stack
  lda SCRATCH+2
  sta stackbase+1,x
  lda SCRATCH+3
  sta stackbase+2,x
  ;jsr printstacksub
  jsr fatsetsub     ; update fat

  ;; end
  rts


;;; interpret the address on the stack as a pointer into the I/O
;;; buffer. Copy the filename from the PAD into that address.
;;; Note that this does NOT clear the address off the stack.
copypadname
.(
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

  ldy #0
nextchar
  lda PAD,y
  sta (SCRATCH),y
  iny
  cpy #11
  bne nextchar
  rts
.)



close3cells
  inx
  inx
close2cells
  inx
  inx
  inx
  inx
  rts

open3cells
  dex
  dex
open2cells
  dex
  dex
  dex
  dex
  rts



;;; lowest levels -- send a byte, receive a byte...


sendbyte
  phy
  ldy #8
sendloop
  asl
  pha
  bcc sendzero
sendone
  lda #SD_MOSI
  tsb PORTB
  bra send
sendzero
  lda #SD_MOSI
  trb PORTB
send
  inc PORTB
  dec PORTB
  pla
  dey
  bne sendloop
  ply
  rts

;; wait for data by pulsing the clock until there's a zero on MISO
awaitdata
.(
  inc PORTB         ; set CLK high
  bit PORTB         ; check for data on MISO
  bpl done          ; exit if we see a zdero
  dec PORTB         ; otherwise, set CLK low and 
  bra awaitdata     ; loop around again
done
  dec PORTB
.)
  rts

;; wait with a timeout. if we don't hear something within 256 pulses,
;; set carry flag and return
awaittimeout
.(
  clc
  ldy #0
awaitloop
  inc PORTB
  bit PORTB
  bpl done
  dec PORTB
  dey
  beq timeout
  bra awaitloop
timeout
  sec
  rts
done
  dec PORTB
  rts
.)

;; wait for data and then receive a byte starting with zero
awaitbyte
  jsr awaitdata
  lda #0
  jmp recv7bits

;; wait for byte with timeout (signalled with carry)
awaitbto
  jsr awaittimeout
  bcs timeout
  lda #0
  jmp recv7bits
timeout
  rts
  
await40bits
  jsr awaitdata     ; wait for any data
  jsr recv7bits     ; grab first 7 bits (presuming leading 0)
  sta SCRATCH
  jsr recv8bits     ; second byte
  sta SCRATCH+1
  jsr recv8bits     ; third byte
  sta SCRATCH+2
  jsr recv8bits     ; fourth byte
  sta SCRATCH+3
  jsr recv8bits     ; fifth byte
  sta SCRATCH+4
  rts

getresponse
.(
  phx
  ldx #0
loop
  inx
  beq timedout
  jsr recv8bits
  cmp #$ff
  beq loop
timedout
  plx
  rts
.)

;; TODO unroll this, probably a good deal faster then looping
recv8bits
  lda #0            ; zero out result
  inc PORTB         ; set clock high
  lda PORTB         ; read data
  cmp #128          ; this sets carry flag to top bit
  rol               ; shift carry into A
  dec PORTB         ; set clock off
  ;; now fall through to receive next seven bits

recv7bits           ; used to be a loop, unrolled for speed
.(
  phx               ; store X, since we'll use it (and can't use Y)

  inc PORTB         ; set CLK high #1
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #2
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #3
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #4
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #5
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #6
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  inc PORTB         ; set CLK high #7
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low

  plx               ; restore X
.)
  rts               ; return with data in A




;;;
;;; *** BUFFER/BLOCK/VIRTUAL MEMORY
;;;
;;; I don't implement the full panoply of regular FORTH routines
;;; just yet (and perhaps never), but this is enough to get things
;;; going and then incorporate the editor. Blocks are 1024 characters
;;; long, so buffers are 1028 bytes.
;;; 

;;; BUFFER allocates a buffer, which might require flushing out
;;; old data. All the activity happens in a subroutine so that I can
;;; also call it from inside the code for BLOCK.
dobuffer
  jsr buffersub
  jmp next


;;; Allocates a buffer for a block number given on the stack. Looks
;;; through current buffers to see if the block is already loaded,
;;; and if so, returns the existing buffer. If not, looks for an
;;; available buffer. If the buffer it wants to use is already
;;; allocated, and is dirty, then write it out before returning.
buffersub
.(
  ;; check that the requested buffer is within range
  lda USEBLKS
  cmp stackbase+1,x
  bpl continue
  jmp abortblocks
continue
.)
  dex               ; make two bytes of working space on the stack
  dex

  lda #<FIRST
  sta stackbase+1,x
  sta SCRATCH
  lda #>FIRST
  sta stackbase+2,x
  sta SCRATCH+1

  ;; is the buffer currently loaded?
  ;; if so, return that one
.(
checkbuffer
  ldy #0
  lda (SCRATCH),y
  cmp stackbase+3,x
  bne checknext
  iny
  lda (SCRATCH),y
  and #$7F          ; mask off the top bit, which indicates clean/dirty
  cmp stackbase+4,x
  beq foundbuffer   ; yes, so return this buffer

checknext
  jsr plusbuf       ; no, so move on to the next one

  lda stackbase+1,x ; have we wrapped around? if we have, leave this
  cmp #<FIRST       ; loop and allocate a buffer
  bne continue
  lda stackbase+2,x
  cmp #>FIRST
  bne continue
  bra allocatebuffer

continue
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1
  bra checkbuffer
.) 

foundbuffer
  lda SCRATCH       ; update PREV to point to this buffer
  sta PREV
  lda SCRATCH+1
  sta PREV+1

  clc               ; return ptr to the first data byte of the buffer
  lda stackbase+1,x ; which is two bytes after the buffer address itself
  adc #2
  sta stackbase+3,x ; leave these over the buffer number on the stack
  lda stackbase+2,x
  adc #0
  sta stackbase+4,x

  inx               ; clean up the stack
  inx
  rts

;;; allocate a buffer. I don't look for an empty one. Run through how
;;; this is likely to work with what I expect to be the initial conditions
;;; for USE and PREV.
allocatebuffer
  ;; start with the buffer marked by USE
  lda USE
  sta stackbase+1,x
  lda USE+1
  sta stackbase+2,x

  ;; look at the next buffer address
  ;; is it the same as indicated by PREV?
  ;; if not, we're good
.(
checkbuffer
  lda stackbase+1,x
  cmp PREV
  bne good
  lda stackbase+2,x
  cmp PREV+1
  bne good

  ;; if so, pick another
  jsr plusbuf
  bne checkbuffer
.)

good
  lda stackbase+1,x ; copy buffer pointer into SCRATCH
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

  ;; is the buffer dirty?
  ldy #1
  lda (SCRATCH),y
  and #$80          ; check top bit
  beq clean

  ;; buffer is dirty, so flush it before continuing
  jsr flushbuf

  ;; mark it as clean
  ldy #1
  lda (SCRATCH),y
  and #127
  sta (SCRATCH),y
  
clean
  ;; at this point, stackbase+1/2 are working space containing
  ;; a buffer address, and stackbase+3/4 is still the block #

  ;; update USE and PREV
  clc
  lda stackbase+1,x
  sta PREV
  adc #2            ; we return a data address, which is BUF+2
  sta stackbase+3,x
  lda stackbase+2,x
  sta PREV+1
  adc #0
  sta stackbase+4,x

  jsr plusbuf
  lda stackbase+1,x
  sta USE
  lda stackbase+2,x
  sta USE+1
  inx               ; clean up the stack
  inx
  rts
;; end of buffersub


;; flush a buffer. on entry, the buffer pointer is in SCRATCH.
flushbuf

  ;; make space on the stack for the sector number
  jsr open2cells
  
  ;; convert buffer number to sector number and store on stack
  ldy #1
  sec
  lda (SCRATCH)
  sbc #1            ; first step of conversion is to subtract one
  sta stackbase+1,x
  lda (SCRATCH),y
  and #127          ; mask off the dirty bit
  sbc #0
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  asl stackbase+1,x ; multiply by two. we know that this won't exceed
  rol stackbase+2,x ; 15 bits so we can stop after two shifts/rolls.

  clc
  lda stackbase+1,x
  adc USEBASE
  sta stackbase+1,x
  lda stackbase+2,x
  adc USEBASE+1
  sta stackbase+2,x
  lda USEBASE+2
  adc #0
  sta stackbase+3,x
  lda USEBASE+3
  adc #0
  sta stackbase+4,x

  ;; going to need this twice, so make a second copy
  jsr open2cells
  lda stackbase+5,x
  sta stackbase+1,x
  lda stackbase+6,x
  sta stackbase+2,x
  lda stackbase+7,x
  sta stackbase+3,x
  lda stackbase+8,x
  sta stackbase+4,x

  ;; copy from buffer to I/O space

  clc               ; source pointer is buffer address plus two
  lda SCRATCH
  adc #2
  sta SCRATCH+2
  lda SCRATCH+1
  adc #0
  sta SCRATCH+3

  dex
  dex
  lda SCRATCH+2
  sta stackbase+1,x
  lda SCRATCH+3
  sta stackbase+2,x

  jsr sdsavefrommem
  ;; BUG NOT CHECKING ERRORS

  ;; add one to the sector number on the stack
  clc
  lda stackbase+1,x
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  adc #0
  sta stackbase+3,x

  ;; put next base address on the stack
  dex
  dex
;  clc carry clear at this point
  lda SCRATCH+2
  sta stackbase+1,x
  lda SCRATCH+3
  adc #2            ; 512 bytes after previous
  sta stackbase+2,x

  jsr sdsavefrommem
  ;; BUG NOT CHECKING ERRORS

endflush
  rts
;; end of flushbuf


;;; BLOCK finds a buffer allocated for the block given on the stack
;;; and loads it into memory.
doblock
  lda USEBASE+3     ; check whether we are USING a file
  bne blockerr
  jsr blocksub
  jmp next
blockerr
  jmp abortusing

;;; The actual functionality of BLOCK is broken out into this
;;; subroutine so that it can be easily incorporated into
;;; other words that need it.
blocksub
  ;; make a copy of the buffer number for later reference
  jsr dup16

  ;; allocate a buffer, result left on the stack
  jsr buffersub

  ;; is the block already loaded into that buffer?
  sec               ; subtract two to get to the buffer header
  lda stackbase+1,x
  sbc #2
  sta SCRATCH+2
  lda stackbase+2,x
  sbc #0
  sta SCRATCH+3
  lda (SCRATCH+2)   ; now check the block number from the header
  cmp stackbase+3,x
  bne loadit
  ldy #1
  lda (SCRATCH+2),y
  and #127          ; mask off the dirty bit
  cmp stackbase+4,x
  bne loadit
  jmp loaded

loadit
  ;; clear some working space on the stack
  jsr open2cells

  ;; at this point, stackbase+1/2/3/4 are my working space (and will
  ;; be a sector numer). stackbase+5/6 is the buffer address.
  ;; stackbase+7/8 is the block number that was passed in.

  ;; make a copy of the block number (subtracting 1, because blocks
  ;; are numbered from one, and we will need to translate this into
  ;; a zero-ranged sector address).
  sec
  lda stackbase+7,x
  sbc #1
  sta stackbase+1,x
  lda stackbase+8,x
  sbc #0
  sta stackbase+2,x

  ;; translate block into a sector number. note that blocks
  ;; are numbered from 1, but we have already subtracted that.
  ;; multiply by two, and add the base address. leave result on
  ;; the stack. cache a copy on the hardware stack too
  asl stackbase+1,x
  rol stackbase+2,z
  clc
  lda stackbase+1,x
  adc USEBASE
  sta stackbase+1,x
  pha
  lda stackbase+2,x
  adc USEBASE+1
  sta stackbase+2,x
  pha
  lda USEBASE+2
  adc #0
  sta stackbase+3,x
  pha
  lda USEBASE+3
  adc #0
  sta stackbase+4,x
  pha

  ;; add a new cell to the top of the stack and copy the buffer
  ;; address into it
  dex
  dex
  lda stackbase+7,x ; was +5, now +7
  sta stackbase+1,x
  lda stackbase+8,x
  sta stackbase+2,x

  ;; load the first sector (512 bytes), removes four byte
  ;; sector number and two byte memory address from stack
  jsr sdloadtomem

  ;; BUG ought to test for load error here

  ;; so now, stackbase+1/2 is the buffer address.
  ;; stackbase+3/4 is the block number that was passed in.

  ;; retreive the sector number, add one, add put the value on the stack
  jsr open2cells
  pla
  sta stackbase+4,x
  pla
  sta stackbase+3,x
  pla
  sta stackbase+2,x
  pla
  sta stackbase+1,x

  ;; add one for next sector
  clc
  lda stackbase+1,x
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  adc #0
  sta stackbase+4,x


  ;; put the buffer address, plus 512, onto the stack
  ;; add a new cell to the top of the stack and copy the buffer
  ;; address into it
  dex
  dex
;  clc carry clear at this point
  lda stackbase+7,x ; was +5, now +7
  sta stackbase+1,x
  lda stackbase+8,x
  adc #2            ; plus 512, for upper half of the block
  sta stackbase+2,x

  ;; load the second sector (512 bytes) for full 1k block
  jsr sdloadtomem

  ;; BUG ought to test for load error here...

  ;; now that we've successfully loaded the data,
  ;; update the block number in the buffer header
  sec
  lda stackbase+1,x
  sbc #2
  sta SCRATCH+2
  lda stackbase+2,x
  sbc #0
  sta SCRATCH+3
  lda stackbase+3,x
  sta (SCRATCH)
  ldy #1
  lda stackbase+4,x
  sta (SCRATCH),y

loaded
  ;; finish, leaving the buffer data address on the stack
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  inx
  inx
  rts
;; end of blocksub


;;; UPDATE marks the most recently accessed buffer (pointed to by
;;; PREV) as dirty, so that it will be written back if it needs
;;; to be flushed.
doupdate
  ldy #1
  lda (PREV),y
  ora #128
  sta (PREV),y
  jmp next

;doprev
;  dex
;  dex
;  lda #<PREV
;  sta stackbase+1,x
;  lda #>PREV
;  sta stackbase+2,x
;  jmp next
;
;dofirst
;  dex
;  dex
;  lda #<FIRST
;  sta stackbase+1,x
;  lda #>FIRST
;  sta stackbase+2,x
;  jmp next

;;; Flush all buffers that are currently marked as dirty. In
;;; some Forths, this is called SAVE-BUFFERS
dosavebufs
  jsr savebufssub
  bcc endsavebufs

  lda #$43  ; error code three
  jsr puta
  lda #$20
  jsr puta

  jmp abortdiskerror
endsavebufs
  jmp next

;;; this is implemented as a subroutine so that it can be called
;;; from both save-buffers and flush
savebufssub
.(
  dex
  dex
  lda #<FIRST
  sta stackbase+1,x
  lda #>FIRST
  sta stackbase+2,x

bufloop
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

  ;; if it's zero'd, skip
  ldy #1
  lda (SCRATCH)
  ora (SCRATCH),y
  beq nextbuffer

  lda (SCRATCH),y   ; test the dirty flag
  and #128
  beq nextbuffer

  jsr flushbuf
  bcs abortsave

  ldy #1            ; clear the dirty flag
  lda (SCRATCH),y
  and #127
  sta (SCRATCH),y

nextbuffer
  jsr plusbuf
  lda stackbase+1,x
  cmp #<FIRST
  bne bufloop
  lda stackbase+2,x
  cmp #>FIRST
  bne bufloop

  inx               ; clean up the stack
  inx
  clc               ; clear carry because no error to signal
  rts

abortsave
  inx
  inx
  sec
  rts
.)

doflush
.(
  jsr savebufssub

  dex
  dex
  lda #<FIRST
  sta stackbase+1,x
  lda #>FIRST
  sta stackbase+2,x

bufloop
  lda stackbase+1,x
  sta stackaccess
  lda stackbase+2,x
  sta stackaccess+1
  lda #0
  ldy #1
  sta (stackaccess)
  sta (stackaccess),y

  jsr plusbuf
  lda stackbase+1,x
  cmp #<FIRST       ; plusbuf loops, so we are done when we
  bne bufloop       ; return to FIRST
  lda stackbase+2,x
  cmp #>FIRST
  bne bufloop

  inx
  inx
.)
  jmp next


;;; Take a buffer pointer on the stack and cycles it to the next
;;; buffer pointer, circling around.
plusbuf
.(
  clc
  lda stackbase+1,x
  adc #<BUFFERSIZE  ; increment to next buffer
  sta stackbase+1,x
  lda stackbase+2,x
  adc #>BUFFERSIZE
  sta stackbase+2,x
  cmp #>LIMIT       ; have we run out of buffers?
  bne done
  lda stackbase+1,x
  cmp #<LIMIT
  bne done

  lda #<FIRST
  sta stackbase+1,x
  lda #>FIRST
  sta stackbase+2,x
done
  rts
.)


;;; Zero out all the buffer space. The mechanism used is not very
;;; efficient but it's designed to be agnostic as to the size of the
;;; buffers or their number -- which is kinda silly because I know
;;; both and they are unlikely to change... but hey, we only call this
;;; once (actually, twice...)
zerobuffers
.(
  lda #<FIRST
  sta SCRATCH
  lda #>FIRST
  sta SCRATCH+1

loop
  lda #0
  sta (SCRATCH)
  clc
  lda SCRATCH
  adc #1
  sta SCRATCH
  bcc doneadd
  inc SCRATCH+1
doneadd
  lda SCRATCH
  cmp #<LIMIT
  bne loop
  lda SCRATCH+1
  cmp #>LIMIT
  bne loop

  rts
.)

doliteral
  jsr compilelit
  jmp next

doleftbr
  stz STATE
  jmp next

dorightbr
  inc STATE
  jmp next


;;;
;;; *** SCREEN EDITOR
;;;
;;; Basic screen editor for text, using EMACS-like commands.
;;; Assumes 16 rows of 64 characters to fit with block/buffer size,
;;; with nulls filling empty space.
;;;

;;; Just for the editor, relabel a bunch of the scratch space.
temp=SCRATCH
row=SCRATCH+1
col=SCRATCH+2
rowbase=SCRATCH+3 ; and 4
count=SCRATCH+5
upper=SCRATCH+6   ; and 7
lower=SCRATCH+8   ; and 9
jmpvec=SCRATCH+10 ; and 11

NROWS=16
MAXROW=NROWS-1
NCOLS=64
MAXCOL=NCOLS-1
TEXTBASE=SCRATCH+12
TEXTSIZE=NROWS*NCOLS

;;; table of entry points for the commands invoked by each
;;; control-key.
table
  .word tostart     ; a
  .word back        ; b
  .word undefined   ; c
  .word delfwd      ; d
  .word toend       ; e
  .word forw        ; f
  .word undefined   ; g
  .word delback     ; h
  .word undefined   ; i
  .word undefined   ; j
  .word delline     ; k
  .word repaint     ; l
  .word newline     ; m
  .word nextch      ; n
  .word openline    ; o
  .word prev        ; p
  .word undefined   ; q
  .word undefined   ; r
  .word undefined   ; s
  .word undefined   ; t
  .word undefined   ; u
  .word undefined   ; v
  .word undefined   ; w
  .word endedit     ; x
  .word undefined   ; y
  .word undefined   ; z


;;; entry point for the editor. the stack indicates the disk
;;; block to be edited, so we start by calling block to load
;;; it and determine the buffer address.
doedit
.(
  lda USEBASE+3     ; is there a block file set up?
  beq continue
  jmp abortusing
continue
.)
  jsr blocksub
  lda stackbase+1,x
  sta TEXTBASE
  lda stackbase+2,x
  sta TEXTBASE+1
  inx               ; clean up the stack
  inx
  phx
  jsr beginedit
  plx
  jmp next

beginedit
;  stz rowbase   ; set rowbase to 0
;  lda #$60
;  sta rowbase+1

  ;; reset variables and screen for startup
  lda TEXTBASE
  sta rowbase
  lda TEXTBASE+1
  sta rowbase+1
  stz row
  stz col

  ;; BUG HACK HORRIBLE
  ;; on loading, convert trailing spaces to NULs and make sure
  ;; that there's a NUL at the end of each line
  lda rowbase
  sta lower
  lda rowbase+1
  sta lower+1
  lda #NROWS
  sta count
.(
nulloop
  ldy #MAXCOL
  lda #0
  sta (lower),y
  dey
spaceloop
  lda (lower),y
  beq checknext
  cmp #32
  beq replace
  cmp #10
  beq replace
  bra finishline
replace
  lda #0
  sta (lower),y
checknext
  dey
  cpy #255
  bne spaceloop  
finishline
  clc
  lda lower
  adc #NCOLS
  sta lower
  lda lower+1
  adc #0
  sta lower+1
  dec count
  lda count
  bne nulloop
.)
  jmp repaint ; repaint jumps back to editloop below

;;; This is the main editor dispatch loop. Fetch a character; if it's
;;; in the command-code range, then look it up in the table; otherwise,
;;; insert it. Everything is done with JMPs and every command JMPs back
;;; to here. Escape is handled with a separate messy routine rather
;;; that a second table.
editloop

  jsr getchar
  cmp #$1B        ; if it's less than 27, it's a control code
  beq escape      ; exactly 27 is escape
  bcs notcmd      ; over 27 is not a command
  dec             ; subtract 1 (to turn it into a 0-ranged value)
  asl             ; shift to multiply by two
  tax             ; that's an offset, so put it in X
  jmp (table,x)   ; invoke the command

notcmd
  jsr insert      ; not a command, so insert the character
  bra editloop

escape
  jsr getchar
  cmp #"f"
  beq escf
  cmp #"b"
  beq escb
  cmp #"["
  beq arrow
  jmp editloop
escf
  jmp fowdword
escb
  jmp backword
arrow
  jsr getchar
  cmp #"A"
  beq arrowup
  cmp #"B"
  beq arrowdown
  cmp #"C"
  beq arrowright
  cmp #"D"
  beq arrowleft
  jmp editloop
arrowup
  jmp prev
arrowdown
  jmp nextch
arrowright
  jmp forw
arrowleft
  jmp back

;;; move forward a word. BUG only really uses spaces as delimiters;
;;; should really use any non-alpha character.
fowdword
.(
  ;; if we are on a space, then find a word
  ldy col
findword
  lda (rowbase),y
  beq endofline
  cmp #$20
  bne findend
  iny
  cpy #MAXCOL
  beq endofline
  bra findword
findend
  ;; now find the end of the word
  lda (rowbase),y
  beq endofline
  cmp #$20
  beq found  
  iny
  cpy #MAXCOL
  bne findend
found  
endofline
  sty col
  jsr moveto
  jmp editloop
.)

backword
.(
  ;; if we are on a space, then find a word
  ldy col
  beq donebackword
findword
  lda (rowbase),y
  beq nextchar
  cmp #$20
  bne findstart
nextchar
  dey
  beq startofline
  bra findword
findstart
  ;; now find the end of the word
  lda (rowbase),y
  beq startofline
  cmp #$20
  beq found  
  dey
  bne findstart
found  
startofline
  sty col
  jsr moveto
donebackword
  jmp editloop
.)


;; for small integers (<100), convert to decimal and output
;; use this for the ansi codes for positioning
todecimal
.(
  ldy #$30
  sty temp  ; temp
convloop
  cmp #$0A
  bmi donedigit
  sec
  sbc #$0A
  inc temp
  bne convloop
donedigit
  tay
  lda temp
  jsr puta
  tya
  clc
  adc #$30
  jsr puta
  rts
.)


;; clear the screen
cls
  lda #$1B  ; esc
  jsr puta
  lda #$5B  ; "["
  jsr puta
  lda #$32  ; "2"
  jsr puta
  lda #$4A  ; "J"
  jsr puta
  rts

;; move cursor to home position
home
  lda #$1B  ; esc
  jsr puta
  lda #$5B  ; [
  jsr puta
  lda #$48  ; H
  jsr puta
  rts

;; clear from current line to bottom of screen
clrtoend
  lda #$1B  ; ESC
  jsr puta
  lda #$5B  ; [
  jsr puta
  lda #$30  ; 0
  jsr puta
  lda #$4A  ; J
  jsr puta
  rts

;; move cursor to current position (stored in row/col).
moveto
  lda #$1B ; ESC
  jsr puta
  lda #$5B ; [
  jsr puta
  lda row  ; row
  inc
  jsr todecimal
  lda #$3B  ; semic
  jsr puta
  lda col  ; col
  inc
  jsr todecimal
  lda #$48  ; H
  jsr puta
  rts

;; add a "+" marker at 65,17 to mark the extent of edit
;; edit region for forth words (16 rows x 64 chars).
addmarker
  lda #$1B ; ESC
  jsr puta
  lda #$5B ; [
  jsr puta
  lda #17
  jsr todecimal
  lda #$3B  ; semic
  jsr puta
  lda #65
  jsr todecimal
  lda #$48  ; H
  jsr puta
  lda #$2b  ; +
  jsr puta
  rts

nextch
.(
  lda row
  cmp #MAXROW ; #$13
  beq donothing
  inc row
.(
  clc
  lda rowbase
  adc #NCOLS ; #$40
  sta rowbase
  bcc doneadd
  inc rowbase+1
doneadd
.)
 jsr moveto
donothing
 jmp editloop
.)

prev
.(
  lda row
  beq donothing
  dec row
  sec
  lda rowbase
  sbc #NCOLS ; #$40
  sta rowbase
  lda rowbase+1
  sbc #$00
  sta rowbase+1
  jsr moveto
donothing
  jmp editloop
.)

back
.(
  lda col
  beq donothing
  dec col
  jsr moveto
donothing
 jmp editloop
.)

forw
.(
  lda col
  cmp #MAXCOL ; #$3F
  beq donothing
  inc col
  jsr moveto
donothing
 jmp editloop
.)

tostart
  stz col
  jsr moveto
  jmp editloop

toend
.(
  ldy #$00
endloop
  lda (rowbase),y
  beq atend
  iny
  cpy #MAXCOL ;#$3F
  beq atend
  bra endloop
atend
  sty col
  jsr moveto
  jmp editloop
.)

delfwd
.(
  ldy     col
delloop
  iny
  lda     (rowbase),y
  dey
  sta     (rowbase),y
  jsr     puta
  beq     done
  iny
  bra   delloop
done
  lda     #$20
  jsr     puta
  jsr     moveto
  jmp     editloop
.)

delback
.(
  lda col
  beq donothing
  dec col
  jsr moveto
  jmp delfwd
donothing
  jmp editloop
.)

insert
  pha
  ldy col
  lda (rowbase),y
  bne notatend
inschar
  pla
  sta (rowbase),y
  jsr puta
  inc col
  jsr moveto
  rts

notatend
  phy
  inc col
  jsr moveto
  dec col
  ply
  ;; move the rest of the line right by one character
  lda (rowbase),y
insloop
  iny
  pha
  lda (rowbase),y
  tax
  pla
  sta (rowbase),y
  jsr puta
  txa
  bne insloop
  iny
  sta (rowbase),y
  jsr moveto
  ldy col
  bra inschar
  lda row
  cmp #MAXROW
  bne newline
  jmp editloop

newline
  ldy col           ; are we at the end of a line?
  lda (rowbase),y
  beq atend         ; if yes
  jmp  breakline    ; if no

atend
.(
  clc               ; reset rowbase to the new line
  lda rowbase
  adc #NCOLS
  sta rowbase
  bcc doneadd
  inc rowbase+1
doneadd        
.)
  lda (rowbase)      ; is this next line empty?
  bne movelines      ; no, so move lines to insert a new one
  inc row            ; yes, so move to it
  stz col
  jsr moveto
  jmp editloop

movelines
  ;; move the rest of the text down by one line
  jsr rippledown

  ;; clear data out of this line
  ldy #MAXCOL
  lda #0
.(
clearloop
  sta (rowbase),y
  dey
  bne clearloop
  sta (rowbase)
.)

  ;; now that the data is in the right place, repaint the screen
  ;; first, clear everything below the current row
  jsr clrtoend
  inc row           ; we haven't done that yet
  jsr moveto

  ;; stash the row count
  lda row
  pha

  ;; now, paint rows that remain
  clc
  lda rowbase
  adc #NCOLS
  sta lower
  lda rowbase+1
  adc #$00
  sta lower+1
  stz col

paintnext
  lda row
  inc
  cmp #NROWS
  beq donerepaint
  sta row
  stz col
  jsr moveto
  jsr paintrow
  clc
  lda lower
  adc #NCOLS
  sta lower
  bcc paintnext
  inc lower+1
  bra paintnext

donerepaint
  pla
  sta row
  jsr addmarker
  jsr moveto

finish
  jmp editloop

breakline ;; BUG   TO BE IMPLEMENTED
  jmp editloop


;; output the text for one row, pointed to by lower. do it
;; directly for faster output without the subroutine call.
paintrow
.(
  phy
  ldy #0
rdyloop
  lda ACIA_STATUS
  and #$10
  beq rdyloop
  lda (lower),y
  beq done
  sta ACIA_DATA
  iny
  cpy #MAXCOL
  beq done
  bra rdyloop
done
  ply
  rts
.)

;;; clear below and print from current row to the bottom of
;;; of the screen. (uses rowbase to point to line)
paintdown
.(
  lda rowbase
  sta lower
  lda rowbase+1
  sta lower+1
  lda row
  pha               ; stash the row count
  lda col
  pha               ; stash the column count
  stz col
paintloop
  jsr moveto
  jsr clrtoend
  jsr paintrow
  lda row
  inc
  cmp #NROWS
  beq endpaint
  sta row
  clc
  lda lower
  adc #NCOLS
  sta lower
  lda lower+1
  adc #0
  sta lower+1
  bra paintloop
endpaint
  pla
  sta col
  pla
  sta row
  jsr addmarker
  jsr moveto
  rts
.)


;;; repaint the whole screen, saving and then restoring cursor position
;;;
repaint
  lda row
  pha
  lda col
  pha
  lda rowbase
  pha
  lda rowbase+1
  pha
  stz row
  stz col
  lda TEXTBASE
  sta rowbase
  lda TEXTBASE+1
  sta rowbase+1
  jsr cls
  jsr home
  jsr paintdown
  jsr addmarker
  pla
  sta rowbase+1
  pla
  sta rowbase
  pla
  sta col
  pla
  sta row
  jsr addmarker
  jsr moveto
  jmp editloop


;;; open a new line
openline
.(
  ldy col
  bne midline
  jsr rippledown
  ldy #0
  lda #0
clearloop
  sta (rowbase),y
  iny
  cpy #MAXCOL
  bne clearloop
  jsr paintdown
  jmp editloop

midline
  ;; BUG still to be implemented
  jmp editloop
.)

;;; move lines down to open up a space. starts from the last line and
;;; works its way down to the current row (rowbase).
rippledown
.(
  ;; find the end of the text area by adding textsize to textbase
  clc
  lda TEXTBASE
  adc #<TEXTSIZE
  sta upper
  lda TEXTBASE+1
  adc #>TEXTSIZE
  sta upper+1

  ;; subtract one line length to get the last line in area
  sec
  lda upper
  sbc #NCOLS
  sta upper
  lda upper+1
  sbc #$00
  sta upper+1

  ;; is that the row we're on now?
  lda upper
  cmp rowbase
  bne continue
  lda upper+1
  cmp rowbase+1
  bne continue
  jmp finish        ;  yes so we are done

continue
  ;; substract one more line length and store in lower
  sec
  lda upper
  sbc #$40
  sta lower
  lda upper+1
  sbc #$00
  sta lower+1

  ;; at this point, we have two pointers, lower and upper,
  ;; which point to two adjacent lines at the end of the buffer.
  ;; we want to reapeatedly copy the contents of lower into
  ;; upper. We do this backwards from the end of the buffer
  ;; so that we are preserving text as it ripples down.
linecopy
  ldy #MAXCOL
charcopy
  lda (lower),y
  sta (upper),y
  dey
  bne charcopy
  lda (lower)   ; copy the last character
  sta (upper)

  sec           ; lower line now becomes upper line
  lda lower     ; and lower moves down by one line
  sta upper
  sbc #NCOLS
  sta lower
  lda lower+1
  sta upper+1
  sbc #$00
  sta lower+1

  lda upper      ; stop when upper hits the new line we're at
  cmp rowbase
  bne linecopy
  lda upper+1
  cmp rowbase+1
  bne linecopy
.)
  rts

;;; move lines up when one line is deleted. starts from rowbase (row
;;; being deleted) up to the end
rippleup
.(
  clc
  lda rowbase
  sta lower         ; set lower to be same as rowbase
  adc #NCOLS        ; and upper to be one row later
  sta upper
  lda rowbase+1
  sta lower+1
  adc #0
  sta upper+1

  clc               ; calculate limit for copying
  lda TEXTBASE
  adc #<TEXTSIZE
  sta jmpvec        ; weird, but just temporary
  lda TEXTBASE+1
  adc #>TEXTSIZE
  sta jmpvec+1

copyrow
  ldy #0
.(
charloop
  lda (upper),y
  sta (lower),y
  cpy #MAXCOL
  beq endofline
  iny
  bra charloop
.)
endofline

  clc               ; move upper to lower, and increment upper
  lda upper         ; by one row
  sta lower
  adc #NCOLS
  sta upper
  lda upper+1
  sta lower+1
  adc #0
  sta upper+1

  lda upper
  cmp jmpvec
  bne copyrow
  lda upper+1
  cmp jmpvec+1
  bne copyrow
  ;; now clear out that last line (now lower)
  ldy #0
  lda #0
loop
  sta (lower),y
  cpy #MAXCOL
  beq done
  iny
  bra loop  
done
.)
  rts


;;; delete line (^K) -- clears the line when there is text, and close
;;; up the line if it's empty.
delline
  ldy col           ; are we at the start of the line?
  bne midline       ; no

  lda (rowbase),y   ; is the line empty?
  beq closeline     ; yes, so close it up

  ;; delete contents of this line (and erase with spaces)
  ldy #0
.(
clearloop
  lda (rowbase),y
  beq endofline
  lda #0
  sta (rowbase),y
  lda #32
  jsr puta
  cpy #MAXCOL
  beq endofline
  iny
  bra clearloop
endofline
  jsr moveto
  jmp editloop
.)

closeline
  jsr rippleup
  jsr paintdown
  jmp editloop

midline
  ;; still to be implemented
  jmp editloop


;; move to bottom of the screen and quit via rts (back to doedit).
;; in an ugly hack, convert nulls to spaces on exit
endedit
  jsr nulltospace
  lda #$12
  sta row
  stz col
  jsr moveto
  rts

getchar
  lda ACIA_STATUS
  and #$08
  beq getchar
  lda ACIA_DATA
  rts

undefined
  lda #$07          ; BEL (but it doesn't do anything)
  jsr puta
  jmp editloop


;; convert nulls to spaces in the buffer and add newlines
nulltospace
.(
  lda #NROWS
  sta count
  lda TEXTBASE
  sta lower
  lda TEXTBASE+1
  sta lower+1

outerloop
  ldy #63
innerloop
  lda (lower),y
  cmp #32
  beq moveback
  cmp #0
  bne foundit
  lda #32
  sta (lower),y
  bra moveback
foundit
  iny
  lda #10
  sta (lower),y
  bra nextline
moveback
  dey
  cpy #255          ; wrapped around?
  bne innerloop
  lda #10
  sta (lower)
nextline
  clc
  lda lower
  adc #NCOLS
  sta lower
  bcc doneadd
  inc lower+1
doneadd
  dec count
  lda count
  bne outerloop
  rts
.)

  



;;;
;;; *** USER I/O SUPPORT ROUTINES
;;;

puta
.(
  pha
  lda #$10
wait_txd_empty
  bit ACIA_STATUS
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts

okcrlf
  rts

cprompt
  lda #<dots
  sta PRINTVEC
  lda #>dots
  sta PRINTVEC+1
  jsr printvecstr
  rts

crlf
  lda #13
  jsr puta
  lda #10
  jsr puta
  rts




;;;
;;; *** NUMBER READING/PRINTING
;;;
;;; Various conversions to read and print variously-sized numbers
;;; in various formats.
;;;
;;;

;; Look on the stack for the address of a nul-terminated string.
;; Try to interpret that string as a number, and leave that number
;; on the stack. A trailing dot signals that we want it to be a
;; double. If we can't read a number, the stack will be empty
;; and we set Carry on exit.
readsign
  jsr pop16         ; move the string address into stackaccess

  sec               ; create space on the stack for two 32-byte
  txa               ; values.
  sbc #8
  tax

  stz stackbase+1,x ; zero out both 32-bit values
  stz stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x
  stz stackbase+5,x
  stz stackbase+6,x
  stz stackbase+7,x
  stz stackbase+8,x

  lda #6            ; how many bytes to drop at the end, ie, whether
  sta SCRATCH+1     ; we are pushing single or double.

  phy               ; preserve y
  ldy #0            ; y indexes digits of the input string

  ;; first, check if the first character is a minus
  stz SCRATCH       ; default to positive number
  lda (stackaccess),y
  cmp #$2d
  bne checkbase     ; no minus, so proceed as usual
  inc SCRATCH       ; negative, so flag for later
  iny               ; skip that character

checkbase
  lda BASE          ; check if we're reading hexadecimal
  cmp #16
  bne nextcheck
  jmp readhex

nextcheck
  lda (stackaccess),y
  cmp #36           ; dollar sign signals a hex number
  bne checkhash     ; no, so proceed as normal
  iny               ; yes, so skip this character and then
  jmp readhex       ; read as hex

checkhash           ; if there's a #, ignore it
  lda (stackaccess),y
  cmp #$23
  bne nextdigit
  iny

readdecimal
nextdigit
.(
  lda (stackaccess),y
  beq donelastdigit ; ended?

  cmp #$2e          ; dot signals a double
  bne checkdigit
  lda #4
  sta SCRATCH+1
  bra bumpdigit

checkdigit
  cmp #$30
  bcc notnumber
  cmp #$40
  bcs notnumber
  bra processdigit
notnumber
  jmp abortnumread

processdigit

  ;; there is a digit to process. First, multiply our partial result
  ;; by ten (once by 2, once by eight, and then add them).

  asl stackbase+5,x ; shift left to multiply by two
  rol stackbase+6,x
  rol stackbase+7,x
  rol stackbase+8,x

  lda stackbase+5,x ; make a copy in the other temporary slot
  sta stackbase+1,x
  lda stackbase+6,x
  sta stackbase+2,x
  lda stackbase+7,x
  sta stackbase+3,x
  lda stackbase+8,x
  sta stackbase+4,x

  asl stackbase+1,x ; shift the copy left twice more, so x8 in total
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x
  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  clc               ; add them (8x + 2x = 10x)
  lda stackbase+1,x
  adc stackbase+5,x
  sta stackbase+5,x
  lda stackbase+2,x
  adc stackbase+6,x
  sta stackbase+6,x
  lda stackbase+3,x
  adc stackbase+7,x
  sta stackbase+7,x
  lda stackbase+4,x
  adc stackbase+8,x
  sta stackbase+8,x

  sec
  lda (stackaccess),y
  sbc #$30          ; turn from ascii digit into a number
  clc               ; add it to our partial result
  adc stackbase+5,x
  sta stackbase+5,x
  lda stackbase+6,x
  adc #0
  sta stackbase+6,x
  lda stackbase+7,x
  adc #0
  sta stackbase+7,x
  lda stackbase+8,x
  adc #0
  sta stackbase+8,x

bumpdigit
  iny               ; bump the character count
  bra nextdigit     ; and go around again
.)

donelastdigit
  ;; finalize the number. this code is the same regardless of base.
  ;; if we began with a minus, then calculate the two's complement
  ;; of the number we have read.
  lda SCRATCH
  beq finishmult    ; no minus flag set

  ;; first, calculate 1's complement -- flip all bits and add one
  clc
  lda stackbase+5,x
  eor #$ff
  adc #1
  sta stackbase+5,x
  lda stackbase+6,x
  eor #$ff
  adc #0
  sta stackbase+6,x
  lda stackbase+7,x
  eor #$ff
  adc #0
  sta stackbase+7,x
  lda stackbase+8,x
  eor #$ff
  adc #0
  sta stackbase+8,x

finishmult
.(
  ;; check, are we returning a double or a single celled value?
  lda SCRATCH+1
  cmp #4
  beq cleanup
  lda stackbase+5,x ; convert double back to a single
  sta stackbase+7,x
  lda stackbase+6,x
  sta stackbase+8,x

cleanup
  ;; if we need a double, we drop four bytes off the stack. if
  ;; we need a single, we drop six. that's why we use 4 and 6
  ;; as our signals in SCRATCH+1
  txa
  clc
  adc SCRATCH+1
  tax
  ply               ; restore y
.)
  clc               ; signal success
  rts

abortnumread
  clc
  txa
  adc #8
  tax
  ply
  sec               ; signal that we couldn't read a number
  rts
  

;;; read multiple-precision hexadecimal number from the string
;;; pointed to by (stackaccess). y indicates the first character
;;; we care about (potentially after a sign character).
readhex
  ;; if the first character is a hash, read as a decimal
  lda (stackaccess),y
  cmp #$23
  bne checkdollar
  iny
  jmp readdecimal
  
checkdollar
  ;; if this first character is a $, discard it
;  lda (stackaccess),y
  cmp #36
  bne nexthex
  iny
nexthex
.(
  lda (stackaccess),y
  beq doneread

  cmp #$2e          ; is it a "."?
  bne checkdigit

  lda #4            ; it was a dot, so make a note and move on
  sta SCRATCH+1
  iny
  bra nexthex

checkdigit
  ;; not actually doing the check.... oops...

  ;; there is a digit to process. shift our partial result up
  ;; four bits
  asl stackbase+5,x ; first shift
  rol stackbase+6,x
  rol stackbase+7,x
  rol stackbase+8,x
  asl stackbase+5,x ; second shift
  rol stackbase+6,x
  rol stackbase+7,x
  rol stackbase+8,x
  asl stackbase+5,x ; third shift
  rol stackbase+6,x
  rol stackbase+7,x
  rol stackbase+8,x
  asl stackbase+5,x ; fourth shift
  rol stackbase+6,x
  rol stackbase+7,x
  rol stackbase+8,x

  ;; convert digit
.(
  lda (stackaccess),y
  cmp #$60
  bcc isupper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra proceed
isupper
  cmp #$40
  bcc isnumber
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra proceed
isnumber
  ;; numeric character, so subtract $30
  sec
  sbc #$30
proceed
.)
  ;; sanity check?
  pha
  and #%11110000
  beq okay
  pla
  jmp abortnumread

okay
  pla
  ;; add
  clc
  adc stackbase+5,x
  sta stackbase+5,x
  lda stackbase+6,x
  adc #0
  sta stackbase+6,x
  lda stackbase+7,x
  adc #0
  sta stackbase+7,x
  lda stackbase+8,x
  adc #0
  sta stackbase+8,x

  iny
  bra nexthex
doneread
.)
  jmp donelastdigit


;;; this routine to set up the PADPTR is shared by all the
;;; printing routines
initpadptr
  ;; Initialize the PADPTR. We will assemble the string on the
  ;; pad. Leave one space for a count.
  lda #<PAD
  inc               ; space for the count
  sta PADPTR
  lda #>PAD         ; no carry; presume no page boundary
  sta PADPTR+1
  rts

;;; this routine to handle the sign of a 16-bit number is shared by
;;; print16s and rprint16s. similar to handlesign32 but for 16-bits.
handlesign16
.(
  ;; check the most significant bit of the number
  ;; to see if it's negative
  lda stackbase+2,x
  bit #%10000000
  beq nominus

  lda #$2d          ; minus sign
  sta (PADPTR)      ; add it to the string we're assembling
  inc PADPTR

  ;; now calculate the two's complement of the number we have.
  ;; flip all the bits and add one.
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
nominus
  rts
.)

;;; Print a 16-bit number, interpreted as signed, right-aligned in
;;; a field that is as wide as specified on the stack.
rprint16s
  jsr initpadptr
  jsr handlesign16
  bra sharedrprint16

;;; Print a 16-bit number, right-aligned, but unsigned. Most of
;;; the code is shared with rprint16s.
rprint16u
  jsr initpadptr
sharedrprint16
  jsr assemble16    ; assemble a 16-bit number on the pad
  jsr pop16         ; pull the field width (presume < 256)
  phy
  sec
.(
  lda stackaccess   ; load field width
  sbc PAD           ; subtract the the string length
  bmi printnum      ; skip spaces if number longer than field
  tay
  lda #$20
  cpy #0
  beq printnum
space
  jsr puta
  dey
  bne space
printnum
.)
  jsr prpadnum
  ply               ; restore Y
  rts

;;; Print a 16-bit number, bearing in mind that it might be negative.
;;; After the initial test for sign, this shares code with the
;;; unsigned print routine and with the right-aligned printing.
;;;
print16s
  jsr initpadptr
  jsr handlesign16
  bra sharedprint16

;;; Print a 16-bit quantity interpreted as an unsigned number.
;;; Most of the code here is shared with the signed printing
;;; routine too.
print16u
  jsr initpadptr
sharedprint16
  jsr assemble16    ; assemble a 16-bit number on the pad
  lda #$20
  jsr puta
  jsr prpadnum      ; print it
  rts


;;; assemble16 is shared by both the signed and unsigned printing
;;; routine. By the time we get here, we should already have
;;; printed a space and potentially a minus sign.
assemble16
.(
  lda BASE
  cmp #16
  bne continue
  jmp hassemble16
continue
.)
  dex               ; make working space on the stack
  dex
  dex
  
  ;; that leaves the data to be read at stackbase+4,x and stackbase+5,x
  
  stz stackbase+1,x ; These are the bytes in which we'll assemble
  stz stackbase+2,x ; up to five BCD digits. Initialize them to
  stz stackbase+3,x ; zero.

  phy               ; preserve Y
  lda #0
  sed
  ldy #16           ; count of bits we are processing

.(
loop
  asl stackbase+4,x
  rol stackbase+5,x
  lda stackbase+1,x
  adc stackbase+1,x
  sta stackbase+1,x
  lda stackbase+2,x
  adc stackbase+2,x
  sta stackbase+2,x
  rol stackbase+3,x
  dey
  bne loop
.)
  cld

  ;; we have the result in the temporary storage, as BCD. now print that as
  ;; a five-character string (since max is 65535).

  ;; first set a flag to signal whether we've printed anything non-zero
  stz SCRATCH

  txa               ; calculate base address we'll be using
  adc #<stackbase
  sta SCRATCH+2
  lda #>stackbase
  sta SCRATCH+3
  ldy #3

.(
nextbcd             ; go through this loop for each BCD digit
  ;; first, upper four bits
  lda (SCRATCH+2),y
  and #%11110000
  bne prupper       ; not zero, so we definitely print it
  cmp SCRATCH       ; check if we are still suppressing zeros
  beq dolower       ; yes, we are. move on.
prupper
  clc
  ror
  ror
  ror
  ror
  clc
  adc #'0
;  jsr puta          ; print the digit
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

dolower
  lda (SCRATCH+2),y
  and #%00001111
  bne prlower       ; non-zero so we definitely print it
  cmp SCRATCH       ; test for suppressing leading zeros
  beq skip
prlower
  clc
  adc #'0
;  jsr puta          ; print the digit
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

skip
  dey
  bne nextbcd
.)

.(
  lda SCRATCH      ; did we not print anything?
  bne finalize
  lda #$30         ; print a zero
  ;jsr puta
  sta (PADPTR)
  inc PADPTR

finalize
  sec               ; finalize the string count
  lda PADPTR
  sbc #<PAD
  dec               ; remove one
  sta PAD           ; that's the count
  ply               ; restore y

  txa               ; clear five bytes off the stack (three for
  clc               ; working space and two for the parameter)
  adc #5
  tax
.)
  rts

hassemble16
  phy
  ;; number is on the stack
  ;; output to PADPTR
  stz SCRATCH       ; signals if there has been any output yet

  inx               ; nasty stack hackery, watch out!
  jsr h8bits
  dex
  jsr h8bits

finalize
.(
  ;; if we get to the end and haven't outputted a digit, set 0
  lda SCRATCH
  bne done
  lda #'0
  sta (PADPTR)
  inc PADPTR
done
.)
  sec               ; finalize the string count
  lda PADPTR
  sbc #<PAD
  dec               ; remove one
  sta PAD           ; that's the count
  ply               ; restore y

  inx               ; assemble pops this from stack (a little weird)
  inx               ; this should happen in the print routine
  rts

hassemble32
  phy
  stz SCRATCH
  inx
  inx
  inx
  jsr h8bits
  dex
  jsr h8bits
  dex
  jsr h8bits
  dex
  jsr h8bits
  inx               ; pop one cell off the stack (finalize will do the
  inx               ; the other -- this is a mess, clean it up BUG)
  jmp finalize


h8bits
.(
  ;; first digit
  lda stackbase+1,x
  lsr
  lsr
  lsr
  lsr
  tay
  bne continue
  lda SCRATCH
  beq nextchar
continue
  lda hextable,y
  sta (PADPTR)
  inc PADPTR
  inc SCRATCH
nextchar
.)

.(
  ;; second digit
  lda stackbase+1,x
  and #15
  tay
  bne continue
  lda SCRATCH
  beq nextchar
continue
  lda hextable,y
  sta (PADPTR)
  inc PADPTR
  inc SCRATCH
nextchar
.)
  rts



;; print the counted string on the pad and clean up the stack after print
prpadnum
.(
  phy               ; preserve Y

  ldy #1
printnext
  lda PAD,y
  jsr puta
  cpy PAD
  beq cleanup
  iny
  bra printnext
  
cleanup
  ;; clean up -- reclaim our temporary space and also pop item from stack
  ply              ; restore Y
.)
  rts


;;; print the string pointed to at PRINTVEC
;;;
printvecstr
  ldy #0
.(
next_char
  lda #$10
wait_txd_empty  
  bit ACIA_STATUS
  beq wait_txd_empty
  lda (PRINTVEC),y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
.)
  rts



;;; this is just here because the stack code needs it... should
;;; reoganize my files...
putax
.(
  phy

  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  pha             ; put a copy back
  clc
  and #$f0
  ror
  ror
  ror
  ror
  tay
  lda hextable,y
  sta ACIA_DATA
wait_txd_empty2
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty2
  pla
  clc
  and #$0f
  tay
  lda hextable,y
  sta ACIA_DATA
.)
  ply
  rts


#ifdef DISKMAN
;;;
;;; *** DISK MANAGER
;;;
;;; This is a basic command line for when we start up in ROM. Instead
;;; of jumping directly to FORTH, we start off with a simple interaction
;;; loop that allows looking at disks and running programs.
;;;
;;; The disk manager offers a few basic disk utilities, an entry
;;; point to FORTH, and a load/run mechanism for executables. It
;;; isn't structured as a FORTH program, but it largely relies on
;;; FORTH run-time routines.
;;;

dmgreet    .byte "6502 Mite SD Disk Manager", $00

dmtable
  .word table1
  .byte "mount", $00
  .word dmmount
table1
  .word table2
  .byte "dir", $00
  .word dirsub
table2
  .word table3
  .byte "show", $00
  .word dmshow
table3
  .word table4
  .byte "xreceive", $00
  .word dmxr
table4
  .word table5
  .byte "go", $00
  .word dmgo
table5
  .word table6
  .byte "help", $00
  .word dmhelp
table6
  .word $0000       ; signals last entry in table
  .byte "forth", $00
  .word midway


startdiskman
.(
  jsr crlf
  jsr crlf
  jsr crlf
  lda #<dmgreet
  sta PRINTVEC
  lda #>dmgreet
  sta PRINTVEC+1
  jsr printvecstr
  jsr crlf

  ;; if there's an SD card present, mount it
  bit VIA_PORTB
  bvc cmdloop
  jsr dmmount


cmdloop
  lda #"=
  jsr puta
  jsr readtermline
  jsr crlf

  lda INPUT         ; if the line is empty then ignore it
  beq cmdloop

startmatch
  lda #<dmtable
  sta SCRATCH
  lda #>dmtable
  sta SCRATCH+1

matchloop
  ldy #1
  lda (SCRATCH)     ; copy pointer to next entry
  sta SCRATCH+2
  lda (SCRATCH),y
  sta SCRATCH+3

  clc               ; increment SCRATCH to point at command string
  lda SCRATCH
  adc #2
  sta SCRATCH
  bcc skip1
  inc SCRATCH+1
skip1

  ldy #0
charloop
  lda INPUT,y
  beq lastchar
  cmp #32
  beq lastchar
  cmp (SCRATCH),y
  bne matchfail
  iny
  bra charloop
lastchar
  lda (SCRATCH),y
  bne matchfail
success
  iny               ; add one to skip trailing NUL
  clc
  tya
  adc SCRATCH
  sta SCRATCH
  bcc skip2
  inc SCRATCH+1
skip2
  phy
  ldy #1            ; put destination address in SCRATCH+11,12
  lda (SCRATCH)
  sta SCRATCH+11
  lda (SCRATCH),y
  sta SCRATCH+12
  ply
  jsr indjsr        ; jsr indirectly to addr in SCRATCH+11,12
  bra cmdloop
matchfail
  lda SCRATCH+2
  bne nextcmd
  lda SCRATCH+3
  beq endoftable
nextcmd
  ldy #1  
  lda SCRATCH+2
  sta SCRATCH
  lda SCRATCH+3
  sta SCRATCH+1
  bra matchloop

endoftable
  ;; if there's no SD card present, quit
  bit VIA_PORTB
  bvc error

  ;; see if I can find a file to execute
  ;; first, copy into WORD, appending ".x65"
  ldy #0
copychar
  lda INPUT,y
  beq endword
  cmp #32
  beq endword
  iny
  sta WORD,y
  bra copychar
endword
  iny
  lda #".
  sta WORD,y
  iny
  lda #"x
  sta WORD,y
  iny
  lda #"6
  sta WORD,y
  iny
  lda #"5
  sta WORD,y
  sty WORD

  ;; put load address $0300 on the stack
  dex
  dex
  lda #3
  sta stackbase+2,x
  stz stackbase+1,x

  clc
  jsr loadfilesub
  bcs error
  phx               ; save the stack pointer
  jsr $0300         ; run the loaded code
  plx               ; restore the stack pointer
  jmp cmdloop

error
  lda #"?
  jsr puta
  jsr crlf
  jmp cmdloop
.)

indjsr
  jmp (SCRATCH+11)

dmmount
  lda #"S
  jsr puta
  lda #"D
  jsr puta
mountloop
  jsr mountsub
  bcc endmount      ; finish if all fine
  lda #<notinitmsg  ; otherwise, note that no disk mounted
  sta PRINTVEC
  lda #>notinitmsg
  sta PRINTVEC+1
  jsr printvecstr
endmount
  jmp crlf          ; JMP saves an RTS

detectedmsg .byte "SD card detected", $0d, $0a, $00
notinitmsg  .byte " not initialized", $00


dmshow
  jsr paramtoword
  jsr showsub
.(
  bcc continue      ; error reported?
  lda #<dmnofilestr
  sta PRINTVEC
  lda #>dmnofilestr
  sta PRINTVEC+1
  jmp printvecstr   ; jmp saves an rts
continue
.)
  rts

dmnofilestr .byte "No such file", $0a, $0d, $00

dmhelp
  lda #<dmhelpstr
  sta PRINTVEC
  lda #>dmhelpstr
  sta PRINTVEC+1
  jmp printvecstr   ; jmp saves an rts

dmhelpstr .byte "mount, dir, show <file>, xreceive <addr>, go <addr>, forth, help", $0a, $0d, $00


dmgo
  jsr paramtoword
  jsr wordtonum     ; leaves result on stack
go2
  jsr pop16         ; take address off stack and store in
  lda stackaccess   ; SCRATCH+11,12 (the indirect jsr address)
  sta SCRATCH+11
  lda stackaccess+1
  sta SCRATCH+12
  jmp indjsr        ; doing the jump saves us an RTS


XDESTADDR   = $0034 ; and $0035

dmxr
  jsr paramtoword
  jsr wordtonum
  jsr pop16
  lda stackaccess
  sta XDESTADDR
  lda stackaccess+1
  sta XDESTADDR+1
  jmp xmodemrecv


;;; copy the parameter into WORD
paramtoword
  phx
  ldx #1
copychar
  lda INPUT,y
  beq doneword
  cmp #32
  beq doneword
  sta WORD,x
  iny
  inx
  bra copychar
doneword
  dex
  stx WORD          ; character count  
  plx
  rts

;;; convert string in WORD to a number on the stack
wordtonum
  lda #0
  ldy WORD
  iny
  sta WORD,y
  clc
  lda #<WORD
  adc #1
  sta stackaccess
  lda #>WORD
  adc #0
  sta stackaccess+1
  jsr push16
  stz SCRATCH
  jsr readsign
  rts


;;;
;;; XMODEM RECEIVE CODE
;;;
;;; RAM-based FORTH depends on the monitor for this, but for
;;; ROM-based and the disk manager, we incorporate it here.
;;;

XBLOCKNO    = $0030
XBLOCKINV   = $0031
XBLOCKCOUNT = $0032
XCHKSUM     = $0033
;XDESTADDR   = $0034 ; and $0035
BUFFER      = $0036 ; and $0037


;; entry point
;;
xmodemrecv
  ;; first, print a message announcing that we're listening
  lda #<startstr
  sta PRINTVEC
  lda #>startstr
  sta PRINTVEC+1
  jsr printvecstr
  jsr crlf

.(
  phx               ; preserve operand stack pointer

  stz XBLOCKCOUNT
  ldy #$0
  ldx #0

  ;; okay, now we wait for transmission to start. the deal here is that
  ;; we are meant to listen with 10-second timeouts, and sent a NACK
  ;; every ten seconds, one of which will signal to the other end that
  ;; we are ready to go. However, we don't have a timer set up anywhere.
  ;; so I'm going to cheat -- we will basically listen for 256x256 loops,
  ;; and send an ACK after that. it will actually just be a second or two.
waitstart
  ldy #$0
  ldx #$0
.(
wait_rxd_full    
  inx               ; counting up to 256
  beq bumpy         ; count cycled, so increment Y
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
  jmp gotfirstchar
bumpy
  iny               ; counting up to 256
  beq sendnack      ; Y has cycled, so we've looped 256*256 times
  bra wait_rxd_full  
sendnack
  ;; send a nack
  lda #$15
  jsr puta
  bra wait_rxd_full
.)
gotfirstchar
  ldx #$0           ; reset X and Y
  ldy #$0

nextxblock
;; check header data and block number
processbuffer
  jsr getserial     ; get first character (if we don't already have it)
  cmp #$04          ; end-of-transmission?
  beq endoftransmission
  cmp #$01          ; start-of-header?
  beq processblock
  jsr headererror
  jmp xmerror

processblock
  ;; get block number and inverse block number
  jsr getserial
  sta XBLOCKNO
  jsr getserial
  sta XBLOCKINV
  sec
  lda #255
  sbc XBLOCKNO
  cmp XBLOCKINV     ; does block number match inverse block number?
  beq checkblockcount
  jsr blockcounterror
  jmp xmerror

checkblockcount
  inc XBLOCKCOUNT
  lda XBLOCKCOUNT
  cmp XBLOCKNO      ; does it match what we were expecting?
  beq processdata
  jsr blockcounterror
  jmp xmerror

processdata
  stz XCHKSUM
  ldy #0
nextbyte
  jsr getserial
  sta (XDESTADDR),y
  clc
  adc XCHKSUM
  sta XCHKSUM
  iny
  cpy #$80
  bne nextbyte
endofblock
  jsr getserial
  cmp XCHKSUM
  beq checksumok
  jsr putax
  lda XCHKSUM
  jsr putax
  jsr checksumerror
  jmp xmerror
checksumok
  ;; send an ACK
  lda #$06
  jsr puta

  ;; update the destination address by 128 ($80)
  clc
  lda XDESTADDR
  adc #$80
  sta XDESTADDR
.(
  bcc skip
  inc XDESTADDR+1
skip
.)
  ;; and loop for next block
  bra nextxblock

;; Send an ACK. Pause briefly to allow the connection to be torn down.
;; Then print a message to signal successful completion.
endoftransmission
  ;; send an ACK
  lda #$06
  jsr puta

.(
  ;; this is just to generate a pause. entirely arbitrary.
  ;; (had to make this longer after i upped the clock speed)
  ;; i've seen other code flush the buffer and just wait until there's
  ;; been no new transmission for a period of a second or so. that might
  ;; work better...
  ;;
  lda #$30
fullloop
  ldy #$0
busywait
  iny
  bne busywait
  dec
  bne fullloop
.)  

  jsr crlf
  lda #<recvdstr
  sta PRINTVEC
  lda #>recvdstr
  sta PRINTVEC+1
  jsr printvecstr
  jsr crlf
  jmp endxmodem
.)

xmerror
  ;; I'd like to report an error here but if the connection is still
  ;; open it will just go to that rather than to the screen!

endxmodem
  plx               ; restore operand stack pointer in x
  rts


;; get a character from the serial port
;;
getserial
  lda ACIA_STATUS
  and #$08
  beq getserial
  lda ACIA_DATA
  rts


checksumerror
  lda #<chksmerrstr
  sta PRINTVEC
  lda #>chksmerrstr
  sta PRINTVEC+1
  jsr printvecstr
  jsr crlf
  jmp endxmodem

headererror
  lda #<headerrstr
  sta PRINTVEC
  lda #>headerrstr
  sta PRINTVEC+1
  jsr printvecstr
  jsr crlf
  jmp endxmodem

blockcounterror
  lda #<blockerrstr
  sta PRINTVEC
  lda #>blockerrstr
  sta PRINTVEC+1
  jsr printvecstr
  jsr crlf
  jmp endxmodem

startstr:   .byte "xmodem listening", $00
recvdstr:   .byte "xmodem received", $00
blockerrstr:.byte "block count error", $00
chksmerrstr:.byte "checksum errror", $00
headerrstr: .byte "header error", $00


#endif



;;;
;;; *** STRING CONSTANTS
;;;


#ifdef ROM
greeting	 .byte "SECND 6502 Forth v09", $00
#else
greeting	 .byte "SECND 6502 Forth v09-RAM", $00
#endif
ok:		 .byte "  OK", $0d, $0a, $00
dots:		 .byte "   ...", $0d, $0a, $00
notdefinedmsg:   .byte ": not defined", $00
nestingmsg:	 .byte "  nesting mismatch", $00
compileerr:      .byte "  compile-only word", $00
exitmsg:	 .byte $0d, $0a, $0d, $0a, "Exiting.", $0d, $0a, $00
cardfailmsg:     .byte " couldn't initialize card", $00
initializedmsg:  .byte " initialized ", $00
usingerrormsg:   .byte " not USING block file", $00
diskerrormsg:    .byte " disk error", $00
nodiskmsg:       .byte " no disk present", $00
;readerrormsg:    .byte " read error", $0d, $0a, $00
;writeerrormsg:   .byte " write error", $0d, $0a, $00
dirofmsg:        .byte "Directory of ", $00
nofilemsg:       .byte " no such file", $00
blockcountmsg:   .byte " exceeds file block count", $00
generic:	 .byte " generic error",$00
existserr:	 .byte " file exists",$00
bytesfree:       .byte " bytes free", $00
stackerrstr:	 .byte " stack over/underflow", $00
hextable:	 .byte "0123456789ABCDEF"
