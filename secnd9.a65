
;;;
;;; SECND - A FORTH FOR 65C02
;;;
;;; Since "FORTH" is actually an abbreviation of "FOURTH", "SECND"
;;; is an abbreviation of "SECOND", it being my second FORTH
;;; implementation. The last one was over 30 years ago, but let's
;;; not worry about that now. This time, I'm sticking closer to
;;; standards, albeit outdated ones; the starting point for this
;;; is FigFORTH although it has become gradually ANSified along the
;;; way.
;;;
;;; I'm building this for my single-board 65C02 computer, the Mite.
;;; It can run in ROM or RAM; for now, the memory map is built
;;; for a RAM-resident configuration.
;;;
;;; More of this code than you would expect was written in the
;;; United Club at LAX Terminal 7.
;;;
;;; SECND is covered by the Creative Commons CC-BY-4.0 license.
;;; Code can be shared and adapted but authorship must be acknowledged.
;;;
;;; Paul Dourish, December 2017
;;;
;;; Version history:
;;; v01  first basic version of interpreter up and running
;;; v02  adding R-stack operators, variables, arrays, allot
;;; v03  first steps for compiler, basic lists, strings, loops, conditionals
;;; v04  rounding out vocabulary, linking more internal operations to
;;;      external words, adding nest checking
;;; v05  recursion, double-length arithmetic, pair operations, signed
;;;      arithmetic
;;; v06  cleaning up and debugging, various new words, more internal
;;;      elements available to Forth, performance improvements
;;; v07  SD card integration, block/buffer implementation, editor
;;; v08  string routines, cleanup, interpreter work, create/does>
;;; v09  ROMmable version
;;;

#ifdef ROM
  * = $C000
USERBASE=$0800
#else
  * = $0300
USERBASE=$3600
#endif

;;;
;;; Variables/space setup
;;;

SCRATCH    = $0010  ; through to $001F (adopted from monitor)
PRINTVEC   = $0042  ; and 0043 (borrowed from monitor)

;;; MEMORY MAP
;;;
;;; 0000 through 004F is reserved for the monitor (reusing SCRATCH)
;;; 0050 through 007F is available for variables (below)
;;; 0080 through 00FF is operand stack
;;; 0100 through 01FF is the hardware stack as usual
;;; 0200 through 02FF is the return stack (more space than needed)
;;; 0300 through 1FFF is the interpreter and compiler code (this file)
;;; 2000 through 63DF is user dictionary space
;;; 63E0 through 7BFF is I/O block space
;;; 7C00 through 7DFF is low-level SD I/O buffer space (512 byte block)
;;; 7E00 through 7EBF is the PAD (string assembly area)
;;; 7EC0 through 7EFF is temporary string processing space
;;; 7F00 through 7FFF is the input buffer (TIB)

;;; 
;;; KEY SYSTEM VARIABLES
;;;
;;; IP is the instruction pointer
;;; DT (dictionary top) pointer to start (actually, end) of dictionary
;;; RP is return stack pointer
;;; XT holds execution token of currently executing word
;;; CODEVEC holds the location of the code for the next instruction
;;; DP holds pointer to the next available dictionary space
;;; TPTR holds the offset of the most recently processed input character
;;; TCNT holds the number of characters held in the buffer
;;; DPTR is an internal variable for traversing the dictionary
;;; STATUS is the system status flags (e.g. compilation flag)
;;; CWORD holds a pointer to the word currently being compiled
;;; SOURCE indicates where input is coming from (0 for terminal)
;;; INPUT points to the input buffer
;;; WORD points to the temporary string processing space
;;; INBUFF points to the current non-terminal input area
;;; IOSPACE is the boundary into I/O buffer space
;;; 
;;;
BASE=$000E          ; and 000F (store two bytes but we only use lower)
IP=$0050            ; and 0051
RP=$0052            ; and 0053 (return stack pointer)
DT=$0054            ; and 0055 (ptr to top of dictionary)
; reserve 0056, 0057 (we need 0057 to store a JMP instruction)
XT=$0058            ; and 0059
TPTR=$005A
TCNT=$005B
DPTR=$005C          ; and 005D
DP=$005E            ; and 005F (dictionary pointer)
STATUS=$0060        ; status word
CWORD=$0061         ; and 0062 (word currently being compiled)
PADPTR=$0063        ; and 0064 (pointer to text area)
SOURCE=$0065
INBUFF=$0066        ; and 0067
CURSEC=$0068        ; through $006B (current loaded sector)
USEBASE=$006C       ; through $006F (base sector address for block file)
USE=$0070           ; and 0071
PREV=$0072          ; and 0073
    ;; 0074 through 007F are free

RBASE=$0200         ; base for R-stack
IOSPACE=$6000       ; start of buffer space
FIRST=$63E0         ; start of space for blocks/disk buffers
LBLOCK=$7C00        ; address of lower I/O data page
HBLOCK=$7D00        ; address of upper I/O data page
PAD=$7E00           ; PAD (string assembly area)
WORD=$7EC0          ; temporary space for parsing words (max 63 chars)
INPUT=$7F00         ; input space

XRECV=$C4DB         ; address of XMODEM subroutine from monitor
DUMP=$C396          ; address of DUMP subroutine from monitor

MBR=$0200           ; cache SD card master boot record in unused stack space
MBR_NFATS=$0210     ; address of FAT count within cache
MBR_LABEL=$022B     ; address of label within cache

;;; FLAGS AND CONSTANTS
;;;
COMPILE=%00000001   ; status flags
SPI_CMD=64

IMM=%00100000       ; flag for IMMEDIATE word (ie executed in compile mode)

;;; The flags below are left on the stack by the compiler to signal
;;; what sort of clean-up operation is needed at the end of a loop.
;;; They also ensure that nesting is correct.
IFELSEFLAG=$FF      ; left by IF and ELSE
LEAVEFLAG=$FE       ; left by LEAVE
DOFLAG=$FD          ; left by DO
BEGINFLAG=$FC       ; left by BEGIN
WHILEFLAG=$FB       ; left by WHILE

BLOCKSIZE=1024
BUFFERSIZE=BLOCKSIZE+4
BUFFERSPACE=BUFFERSIZE*6
LIMIT=FIRST+BUFFERSPACE

  jmp coldstart     ; jump past code defined in stack routines

#include "../mitemon/decl.a65"
#include "../mitemon/stack.a65"




;;;
;;; *** DICTIONARY
;;;
;;; Each entry in the dictionary comprises:
;;; - one byte that is both tags (three upper bits) and word length
;;;   five lower bits)
;;; - the characters making up the word definition name
;;; - pointer to next entry
;;; - the "code word" (address of code handling this instruction, which
;;;   will often be DOLIST for compiled words)
;;; - the parameter space (often the list of addresses for executing
;;;   this word, and often ending with EXIT)
;;;

d0entry
  .byte 4
  .byte "exit"
d0link
  .word $0000
exitcode
d0code
  .word exit

d1entry
  .byte 1
  .byte "+"
d1link
  .word d0entry
d1code
  .word doplus

d2entry
  .byte 1
  .byte "*"
d2link
  .word d1entry
d2code
  .word dotimes

d3entry
  .byte 7
  .byte "0branch"
d3link
  .word d2entry
zerobracode
d3code
  .word dozerobra

d4entry
  .byte 4
  .byte "true"
d4link
  .word d3entry
d4code
  .word dotrue

d5entry
  .byte 3
  .byte "lit"
d5link
  .word d4entry
dolitcode
d5code
  .word dolit

d6entry
  .byte 1
  .byte "."
d6link
  .word d5entry
d6code
  .word doprint16

d7entry
  .byte 2
  .byte "<>"
d7link
  .word d6entry
d7code
  .word donotequal

d8entry
  .byte %00100110   ; IMM + code for 6  ;; BUG? no need for immediate
  .byte "branch"
d8link
  .word d7entry
branchcode
d8code
  .word dobranch

d9entry
  .byte 3
  .byte "dup"
d9link
  .word d8entry
d9code
  .word dodup

d10entry
  .byte 4
  .byte "swap"
d10link
  .word d9entry
d10code
  .word doswap

d11entry
  .byte 4
  .byte "drop"
d11link
  .word d10entry
d11code
  .word dodrop

d12entry
  .byte 1
  .byte "/"
d12link
  .word d11entry
d12code
  .word dodiv

d13entry
  .byte 3
  .byte "mod"
d13link
  .word d12entry
d13code
  .word domod

d14entry
  .byte 1
  .byte "="
d14link
  .word d13entry
d14code
  .word doequal

d15entry
  .byte 5
  .byte "depth"
d15link
  .word d14entry
d15code
  .word dodepth

d16entry
  .byte 1
  .byte ">"
d16link
  .word d15entry
d16code
  .word dogreater

d17entry
  .byte 1
  .byte "<"
d17link
  .word d16entry
d17code
  .word doless

d18entry
  .byte 2
  .byte "cr"
d18link
  .word d17entry
crcode
d18code
  .word docr

d19entry
  .byte 4
  .byte "emit"
d19link
  .word d18entry
d19code
  .word doemit

d20entry
  .byte 4
  .byte "over"
d20link
  .word d19entry
d20code
  .word doover

d21entry
  .byte 3
  .byte "rot"
d21link
  .word d20entry
d21code
  .word dorot

d22entry
  .byte 5
  .byte "false"
d22link
  .word d21entry
d22code
  .word dofalse

d23entry
  .byte 1
  .byte "@"
d23link
  .word d22entry
d23code
  .word dofetch

d24entry
  .byte 2
  .byte "c@"
d24link
  .word d23entry
d24code
  .word docfetch

d25entry
  .byte 1
  .byte "!"
d25link
  .word d24entry
d25code
  .word dostore

d26entry
  .byte 2
  .byte "c!"
d26link
  .word d25entry
d26code
  .word docstore

d27entry
  .byte 5
  .byte "cells"
d27link
  .word d26entry
d27code
  .word docells

d28entry
  .byte 8
  .byte "variable"
d28link
  .word d27entry
d28code
  .word dovariable

d29entry
  .byte 1
  .byte "-"
d29link
  .word d28entry
minuscode
d29code
  .word dominus

d30entry
  .byte 4
  .byte "here"
d30link
  .word d29entry
herecode
d30code
  .word dohere

d31entry
  .byte 5
  .byte "allot"
d31link
  .word d30entry
d31code
  .word doallot

d32entry
  .byte 3
  .byte "bye"
d32link
  .word d31entry
d32code
  .word dobye

d33entry
  .byte 1
  .byte ":"
d33link
  .word d32entry
d33code
  .word docolon

d34entry
  .byte %00100001   ; set the immediate bit plus count of 1
  .byte ";"
d34link
  .word d33entry
d34code
  .word dosemic

d35entry
  .byte 2
  .byte ">r"
d35link
  .word d34entry
d35code
  .word dotor

d36entry
  .byte 2
  .byte "r>"
d36link
  .word d35entry
d36code
  .word dofromr

d37entry
  .byte 2
  .byte "r@"
d37link
  .word d36entry
d37code
  .word dorcopy

d38entry
  .byte 1
  .byte "i"
d38link
  .word d37entry
d38code
  .word dorcopy

d39entry
  .byte %00100010   ; IMM flag plus count of two
  .byte $2e, $22    ; dot, quote (.")
d39link
  .word d38entry
dotquotecode
d39code
  .word dodotqu

d40entry
  .byte %00100010   ; IMM flag plus count of two
  .byte "if"
d40link
  .word d39entry
d40code
  .word doif

d41entry
  .byte %00100100   ; IMM flag plus count of four
  .byte "then"
d41link
  .word d40entry
d41code
  .word dothen

d42entry
  .byte %00100101   ; IMM flag plus count of five
  .byte "begin"
d42link
  .word d41entry
d42code
  .word dobegin

d43entry
  .byte %00100101   ; IMM flag plus count of five
  .byte "until"
d43link
  .word d42entry
d43code
  .word dountil  

d44entry
  .byte %00100100   ; IMM plus count of four
  .byte "else"
d44link
  .word d43entry
d44code
  .word doelse

d45entry
  .byte 5
  .byte "words"
d45link
  .word d44entry
d45code
  .word dowords

d46entry
  .byte %00100010   ; IMM plus count of two
  .byte "do"
d46link
  .word d45entry
d46code
  .word dodo

d47entry
  .byte 4
  .byte "(do)"
d47link
  .word d46entry
parendocode
d47code
  .word doparendo

d48entry
  .byte %00100100   ; IMM plus count of four
  .byte "loop"
d48link
  .word d47entry
d48code
  .word doloop

d49entry
  .byte 6
  .byte "(loop)"
d49link
  .word d48entry
parenloopcode
d49code
  .word doparenloop

d50entry
  .byte %00100101   ; IMM plus count of five
  .byte "+loop"
d50link
  .word d49entry
d50code
  .word doplusloop

d51entry
  .byte 7
  .byte "(+loop)"
d51link
  .word d50entry
parplusloopcode
d51code
  .word doparplusloop

d52entry
  .byte 1
  .byte "j"
d52link
  .word d51entry
d52code
  .word doj

d53entry
  .byte 1
  .byte "k"
d53link
  .word d52entry
d53code
  .word dok

d54entry
  .byte 3
  .byte "max"
d54link
  .word d53entry
d54code
  .word domax

d55entry
  .byte 3
  .byte "min"
d55link
  .word d54entry
d55code
  .word domin

d56entry
  .byte 3
  .byte "key"
d56link
  .word d55entry
d56code
  .word dokey

d57entry
  .byte 3
  .byte "and"
d57link
  .word d56entry
d57code
  .word doand

d58entry
  .byte 2
  .byte "or"
d58link
  .word d57entry
d58code
  .word door

d59entry
  .byte 3
  .byte "xor"
d59link
  .word d58entry
d59code
  .word doxor

d60entry
  .byte 2
  .byte "0="
d60link
  .word d59entry
eqlzerocode
d60code
  .word doeqlzero

d61entry
  .byte 2
  .byte "1+"
d61link
  .word d60entry
d61code
  .word do1plus

d62entry
  .byte 2
  .byte "1-"
d62link
  .word d61entry
d62code
  .word do1minus

d63entry
  .byte 2
  .byte "2+"
d63link
  .word d62entry
d63code
  .word do2plus

d64entry
  .byte 2
  .byte "2-"
d64link
  .word d63entry
d64code
  .word do2minus

d65entry
  .byte %00100101   ; IMM plus count of 5
  .byte "leave"
d65link
  .word d64entry
d65code
  .word doleave

d66entry
  .byte 7
  .byte "(leave)"
d66link
  .word d65entry
parenleavecode
d66code
  .word doparenleave

d67entry
  .byte 6
  .byte "invert"
d67link
  .word d66entry
d67code
  .word doinvert

d68entry
  .byte %00100101   ; IMM plus count of five
  .byte "while"
d68link
  .word d67entry
d68code
  .word dowhile

d69entry
  .byte %00100110   ; IMM plus count of six
  .byte "repeat"
d69link
  .word d68entry
d69code
  .word dorepeat

d70entry
  .byte %00100111   ; IMM plus count of seven
  .byte "recurse"
d70link
  .word d69entry
d70code
  .word dorecurse

d71entry
  .byte %00100001   ; IMM plus count of one
  .byte $5c         ; backslash
d71link
  .word d70entry
d71code
  .word dobackslsh

d72entry
  .byte 8
  .byte "constant"
d72link
  .word d71entry
d72code
  .word doconstant

d73entry
  .byte %00100010   ; IMM flag plus count of two
  .byte $73, $22    ; "s", quote (.")
d73link
  .word d72entry
d73code
  .word dosquote

d74entry
  .byte 8
  .byte "sliteral"
d74link
  .word d73entry
sliteralcode
d74code
  .word dostrlit

d75entry
  .byte 4
  .byte "type"
d75link
  .word d74entry
d75code
  .word dotype

d76entry
  .byte 3
  .byte "s>d"
d76link
  .word d75entry
d76code
  .word dosgltodbl

d77entry
  .byte 2
  .byte "d+"
d77link
  .word d76entry
d77code
  .word doadd32

d78entry
  .byte 2
  .byte "d-"
d78link
  .word d77entry
d78code
  .word dosub32

d79entry
  .byte 2
  .byte "m+
d79link
  .word d78entry
d79code
  .word doaddmix

d80entry
  .byte 2
  .byte "d="
d80link
  .word d79entry
d80code
  .word doeql32

d81entry
  .byte 3
  .byte "d0="
d81link
  .word d80entry
d81code
  .word dozero32

d82entry
  .byte 2
  .byte "m*"
d82link
  .word d81entry
d82code
  .word domultmix

d83entry
  .byte 2
  .byte "d."
d83link
  .word d82entry
d83code
  .word doprint32

d84entry
  .byte 5
  .byte "2swap"
d84link
  .word d83entry
d84code
  .word do2swap

d85entry
  .byte 4
  .byte "2dup"
d85link
  .word d84entry
d85code
  .word do2dup

d86entry
  .byte 5
  .byte "2over"
d86link
  .word d85entry
d86code
  .word do2over

d87entry
  .byte 5
  .byte "2drop"
d87 link
  .word d86entry
d87code
  .word do2drop

d88entry
  .byte 6
  .byte "lshift"
d88link
  .word d87entry
d88code
  .word dolshift

d89entry
  .byte 6
  .byte "rshift"
d89link
  .word d88entry
d89code
  .word dorshift

d90entry
  .byte 2
  .byte "*/"
d90link
  .word d89entry
d90code
  .word dostardiv

d91entry
  .byte 3
  .byte "abs"
d91link
  .word d90entry
d91code
  .word doabs

d92entry
  .byte 6
  .byte "negate"
d92link
  .word d91entry
d92code
  .word donegate

d93entry
  .byte 4
  .byte "pick"
d93link
  .word d92entry
d93code
  .word dopick

d94entry
  .byte 4
  .byte "?dup"
d94link
  .word d93entry
d94code
  .word doquerydup

d95entry
  .byte 2
  .byte "+!"
d95link
  .word d94entry
d95code
  .word doplusstore

d96entry
  .byte 2
  .byte ".s"
d96link
  .word d95entry
d96code
  .word dodots

d97entry
  .byte %00100001   ; IMM plus count of 1
  .byte "("
d97link
  .word d96entry
d97code
  .word docomment

d98entry
  .byte 4
  .byte "/mod"
d98link
  .word d97entry
d98code
  .word dodivmod

d99entry
  .byte 6
  .byte "forget"
d99link
  .word d98entry
d99code
  .word doforget

d100entry
  .byte %00100001   ; IMMEDIATE
  .byte $27         ; tick
d100link
  .word d99entry
d100code
  .word dotick

d101entry
  .byte 9
  .byte "immediate"
d101link
  .word d100entry
d101code
  .word doimmed

d102entry
  .byte 7
  .byte "dnegate"
d102link
  .word d101entry
d102code
  .word donegate32

d103entry
  .byte 4
  .byte "fill"
d103link
  .word d102entry
d103code
  .word dofill

d104entry
  .byte 1
  .byte "0"
d104link
  .word d103entry
d104code
  .word doloadconst
d104param
  .word $0000

d105entry
  .byte 2
  .byte "u."
d105link
  .word d104entry
d105code
  .word douprint16

d106entry
  .byte 2
  .byte ".r"
d106link
  .word d105entry
d106code
  .word dorprint16

d107entry
  .byte 3
  .byte "d0<"
d107link
  .word d106entry
d107code
  .word dolesszero32

d108entry
  .byte 4
  .byte "dabs"
d108link
  .word d107entry
d108code
  .word doabs32

d109entry
  .byte 2
  .byte "d<"
d109link
  .word d108entry
d109code
  .word doless32

d110entry
  .byte 4
  .byte "dmax"
d110link
  .word d109entry
d110code
  .word dodmax

d111entry
  .byte 4
  .byte "dmin"
d111link
  .word d110entry
d111code
  .word dodmin

d112entry
  .byte 3
  .byte "d.r"
d112link
  .word d111entry
d112code
  .word dorprint32

d113entry
  .byte 5
  .byte "abort"
d113link
  .word d112entry
d113code
  .word abort

d114entry
  .byte 6
  .byte "upload"
d114link
  .word d113entry
d114code
  .word doupload

d115entry
  .byte 5
  .byte "cload"
d115link
  .word d114entry
d115code
docloadcode
  .word docload

d116entry
  .byte 4
  .byte "key?"
d116link
  .word d115entry
d116code
  .word dokeyqu

d117entry
  .byte 3
  .byte "nip"
d117link
  .word d116entry
d117code
  .word donip

d118entry
  .byte 4
  .byte "tuck"
d118link
  .word d117entry
d118code
  .word dotuck

d119entry
  .byte 4
  .byte "dump"
d119link
  .word d118entry
dumpcode
d119code
  .word dodump

d120entry
  .byte 5
  .byte "count"
d120link
  .word d119entry
d120code
  .word docount

d121entry
  .byte 5
  .byte "mount"
d121link
  .word d120entry
d121code
  .word domount

;d122entry
;  .byte 6
;  .byte "sendff"
;d122link
;  .word d121entry
;d122code
;  .word dosendff
;
;d123entry
;  .byte 4
;  .byte "cmd8"
;d123link
;  .word d122entry
;d123code
;  .word docmd8
;
;d124entry
;  .byte 6
;  .byte "acmd41"
;d124link
;  .word d123entry
;d124code
;  .word doacmd41
;
;d125entry
;  .byte 5
;  .byte "cmd55"
;d125link
;  .word d124entry
;d125code
;  .word docmd55
;
;d126entry
;  .byte 4
;  .byte "cmd0"
;d126link
;  .word d125entry
;d126code
;  .word docmd0
;
;d127entry
;  .byte 5
;  .byte "cmd58"
;d127link
;  .word d126entry
;d127code
;  .word docmd58
;
;d128entry
;  .byte 5
;  .byte "cmd17"
;d128link
;  .word d127entry
;d128code
;  .word docmd17
;
d129entry
  .byte 9
  .byte "loadblock"
d129link
  .word d121entry
loadblockcode
d129code
  .word doloadblock

;d130entry
;  .byte 9
;  .byte "dumpblock"
;d130link
;  .word d129entry
;d130code
;  .word dolist
;d130param
;  .word loadblockcode
;  .word crcode
;  .word dolitcode
;  .word 31744
;  .word dolitcode
;  .word 240
;  .word dumpcode
;  .word exitcode

d131entry
  .byte 3
  .byte "dir"
d131link
  .word d129entry
d131code
  .word dodir

d132entry
  .byte 4
  .byte "show"
d132link
  .word d131entry
d132code
  .word doshow

;d133entry
;  .byte 7
;  .byte "flookup"
;d133link
;  .word d132entry
;d133code
;  .word doflookup

d134entry
  .byte 5
  .byte "fload"
d134link
  .word d132entry
d134code
dofloadcode
  .word dofload

d135entry
  .byte 7
  .byte "include"
d135link
  .word d134entry
d135code
  .word dolist
d135param
  .word dofloadcode
  .word dolitcode
  .word IOSPACE
  .word docloadcode
  .word exitcode

;d136entry
;  .byte 9
;  .byte "saveblock"
;d136link
;  .word d135entry
;d136code
;  .word dosaveblock

d137entry
  .byte 5
  .byte "using"
d137link
  .word d135entry
d137code
  .word dousing

d138entry
  .byte 5
  .byte "block"
d138link
  .word d137entry
d138code
  .word doblock

d139entry
  .byte 6
  .byte "buffer"
d139link
  .word d138entry
d139code
  .word dobuffer

d140entry
  .byte 6
  .byte "update"
d140link
  .word d139entry
d140code
  .word doupdate

d141entry
  .byte 4
  .byte "prev"
d141link
  .word d140entry
d141code
  .word doprev

d142entry
  .byte 5
  .byte "flush"
d142link
  .word d141entry
d142code
  .word doflush

d143entry
  .byte 5
  .byte "first"
d143link
  .word d142entry
d143code
  .word dofirst

d144entry
  .byte 4
  .byte "edit"
d144link
  .word d143entry
d144code
  .word doedit

d145entry
  .byte 4
  .byte "list"
d145link
  .word d144entry
d145code
  .word dolistword

d146entry
  .byte 4
  .byte "load"
d146link
  .word d145entry
d146code
  .word doload

d147entry
  .byte 3
  .byte "use"
d147link
  .word d146entry
d147code
  .word douse

d148entry
  .byte 3
  .byte "sp@"
d148link
  .word d147entry
d148code
  .word dospat

d149entry
  .byte 2
  .byte ";s"
d149link
  .word d148entry
d149code
  .word dosemics

d150entry
  .byte 9
  .byte "-trailing"
d150link
  .word d149entry
d150code
  .word dodashtrail

d151entry
  .byte 7
  .byte "/string"
d151link
  .word d150entry
d151code
  .word doslashstr

d152entry
  .byte 7
  .byte "compare"
d152link
  .word d151entry
d152code
  .word docompare

d153entry
  .byte 4
  .byte "move"
d153link
  .word d152entry
d153code
  .word domove

d154entry
  .byte 5
  .byte "cmove"
d154link
  .word d153entry
d154code
  .word domoveup

d155entry
  .byte 6
  .byte "cmove>"
d155link
  .word d154entry
d155code
  .word domovedown

d156entry
  .byte 6
  .byte "accept"
d156link
  .word d155entry
d156code
  .word doaccept

d157entry
  .byte 5
  .byte "iobuf"
d157link
  .word d156entry
d157code
  .word doloadconst
  .word LBLOCK

d158entry
  .byte 12
  .byte "save-buffers"
d158link
  .word d157entry
d158code
  .word dosavebufs

d159entry
  .byte 4
  .byte "base"
d159link
  .word d158entry
d159code
  .word doloadconst
  .word USERBASE

d160entry
  .byte 3
  .byte "ud."
d160link
  .word d159entry
d160code
  .word doprint32u

d161entry
  .byte 3
  .byte "um*"
d161link
  .word d160entry
d161code
  .word doumstar

d162entry
  .byte 6
  .byte "um/mod"
d162link
  .word d161entry
d162code
  .word doumdivmod

d163entry
  .byte 6
  .byte "sm/rem"
d163link
  .word d162entry
d163code
  .word dosmdivrem

d164entry
  .byte 6
  .byte "create"
d164link
  .word d163entry
d164code
  .word docreate

d165entry
  .byte 1
  .byte ","
d165link
  .word d164entry
d165code
  .word docomma

d166entry
  .byte 7
  .byte "execute"
d166link
  .word d165entry
d166code
  .word doexecute

d167entry
  .byte 6
  .byte "unused"
d167link
  .word d166entry
d167code
  .word dounused

d168entry
  .byte 3
  .byte "hex"
d128link
  .word d167entry
d128code
  .word dohex

d169entry
  .byte 7
  .byte "decimal"
d169link
  .word d168entry
d169code
  .word dodecimal

d170entry
  .byte 4
  .byte "base"
d170link
  .word d169entry
d170code
  .word dobase

d171entry
  .byte 4
  .byte "char"
d171link
  .word d170entry
d171code
  .word dochar

d172entry
  .byte %00100110    ; IMM plus count of six
  .byte "[char]"
d172link
  .word d171entry
d172code
  .word dobrchar

d173entry
  .byte %00100101    ; IMM plus count of five
  .byte "does>"
d173link
  .word d172entry
d173code
  .word dodoes

d174entry
  .byte 6
  .byte "(does)"
d174link
  .word d173entry
dodoesrtcode
d174code
  .word dodoesrt

d175entry
  .byte 6
  .byte "dodoes"
d175link
  .word d174entry
dododoescode
d175code
  .word dododoes

d176entry
  .byte 2
  .byte "2/"
d176link
  .word d175entry
d176code
  .word dotwodiv

dtop
d177entry
  .byte 2
  .byte "2*"
d177link
  .word d176entry
d177code
  .word dotwotimes

;d101entry
;  .byte %00100011   ; IMM plus count of three
;  .byte "?do"
;d101llink
;  d100entry
;d101code
;  .word doqdo
;
;dtop
;d102entry
;  .byte 5
;  .byte "(?do)"
;d102link
;  .word d101entry
;parenqdocode
;d102code
;  .word doparenqdo

;; TOP OF DICTIONARY




;;;
;;; The words below are my experiment on calling things and getting
;;; back to the interpreter. Dummy is the word we'll enter in order to
;;; execute something; the point of it is to make sure that after we've
;;; executed what we want, we run "doquitword", which should take us
;;; back into the interpreter loop
;;;
;;; Once I have the interpreter loop running in a more standard way,
;;; this won't be needed.
;;;


doquitword
  .byte 0
doquitlink
  .word $0000
doquitcode
  .word interploop

;;; This needs to be in RAM, so for the ROM version we have to
;;; set it up.
setupdummy
#ifdef ROM
dummy=$0000         ; not using first few bytes BUG move this later!
dummycode=$0003
dummyparam=$0005
dummyexit=$0007
  stz dummy
  stz dummy+1
  stz dummy+2
  lda #<dolist
  sta dummy+3
  lda #>dolist
  sta dummy+4
  stz dummy+5
  stz dummy+6
  lda #<doquitcode
  sta dummy+7
  lda #>doquitcode
  sta dummy+8
#endif
  rts

#ifndef ROM
dummy
  .byte 0
dummylink
  .word $0000
dummycode
  .word dolist      ; won't actually run this, start with NEXT instead
dummyparam
  .word $0000       ; will write in the actual code link word here
dummyexit
  .word doquitcode
#endif



;;;
;;; *** COLD START
;;;
;;; Initialization and configuration. This version is running
;;; from RAM, so there's no need to initialize the ACIA. Set up
;;; the stack and the major variables.
;;;
coldstart
  ;; initialize stack...
  jsr initstack

  ;; initialize variables...

  ;; IP is the Forth instruction pointer
  stz IP
  stz IP+1

  lda #$6c          ; indirect jump instruction
  sta XT-1          ; to make NEXT work

  ;; Initialize the return stack. I'm just putting that on page 2, 
  ;; growing downwards, until I have a better idea; I should probably
  ;; combine with some other area because a whole page is much
  ;; more space than needed
  lda #$FF
  sta RP
  lda #>RBASE
  sta RP+1

  ;; Initialize DT to the last entry on the dictionary (below)
  lda #<dtop
  sta DT
  lda #>dtop
  sta DT+1  

  ;; Initialize DP to the first available dictionary space (USERBASE)
  lda #<USERBASE
  sta DP
  lda #>USERBASE
  sta DP+1

  ;; initialize BASE to 10
  lda #10
  sta BASE
  stz BASE+1

  ;; initialize pointers and memory for BLOCK code
  stz PREV
  stz PREV+1
  lda #<FIRST
  sta USE
  lda #>FIRST
  sta USE+1
  jsr zerobuffers

  ;; initialize the 6522 for the SD routines
  jsr setup6522

  ;; initialize the dummy word we use for execution
  jsr setupdummy

  ;; print a greeting
  ldy #0
.(
next_char
  lda greeting,y
  beq done
  jsr puta
  iny
  jmp next_char
done
.)

  ;; print the number of free bytes
  jsr unusedsub
  jsr print16u
  ldy #0
.(
next_char
  lda bytesfree,y
  beq done
  jsr puta
  iny
  jmp next_char
done
.)

  ;; jump to warm start address, which finishes the job and
  ;; starts the interpreter
  jmp warmstart




;;;
;;; *** INNER INTERPRETER
;;;
;;; The three routines below -- NEXT, DOLIST, and EXIT -- are the core
;;; of the inner interpreter, which executes stored words.
;;;
;;; NEXT moves from one instruction to the next inside a defined word.
;;; This code is included at the end of each assembly language routine
;;; (or rather, we jump to it).
;;;
;;; DOLIST begins the execution of a compiled word. It stores the IP
;;; on the return stack, resets the IP to the new word, and then calls
;;; NEXT to start on it.
;;;
;;; EXIT is compiled in as the last address of each compiled word. It
;;; undoes what DOLIST has done, and moves back to the earlier execution
;;; context.
;;;
;;; Note that none of these are subroutines -- everything is connected
;;; as direct jumps (actually, indirect jumps!) with the RSTACK used
;;; to keep track of what's going on.


;;; DOLIST is the executing code for a colon-defined word. Also
;;; known as ENTER in some implementations.
dolist
  ;; first, push the current instruction pointer onto the
  ;; return stack (subroutine unrolled)
  lda IP+1
  sta (RP)
  dec RP
  lda IP
  sta (RP)
  dec RP

  ;; next, grab the first address in the parameter block for this
  ;; colon-defined word. We know that XT points to the code word.
  ;; so we grab that address and then add one cell (two bytes)
  ;; store this in IP.
  clc
  lda XT
  adc #$2
  sta IP
  lda XT+1
  adc #0
  sta IP+1

  ;; IP now points to the next instruction we want to execute, in
  ;; this word. Proceed to execute it.
  ;jmp next         ; commented out because we can just fall through

;;; ** PUT NOTHING HERE... depending on fall-through from DOLIST to NEXT!

;;; NEXT executes the next word. Before it does the jump, it increments
;;; IP so that IP always designates the next word to be executed.
next
  ldy #1            ; IP points to the location storing the next
  lda (IP)          ; word we need to execute. fetch that location,
  sta XT            ; and store it in XT.
  lda (IP),y
  sta XT+1

  ;; increment IP by two bytes (one cell) and then move on.
  ;; we need to do a doubly-indirect jump through XT. by having
  ;; the instruction before XT be the instruction for an indirect
  ;; jump, we achieve that effect. XT-1 was set to $6C in the
  ;; cold start routine. the addition and jump are combined to save
  ;; a cycle in most cases.
  
  clc
  lda IP
  adc #2
  sta IP
  bcs addupper      ; no carry is the more common case
  jmp XT-1          ; two JMP instructions saves us a branch
addupper
  inc IP+1
  jmp XT-1

;  lda (XT),y        ; XT contains a pointer to a code word. Load
;  sta CODEVEC+1     ; the code address stored there into CODEVEC.
;  lda (XT)
;  sta CODEVEC

;  jmp (CODEVEC)     ; execute the code for this instruction/word


;;; EXIT is the routine that is called at the end of each colon-defined
;;; word (it's compiled in as the last address to be called). It undoes
;;; DOLIST... it removes an address from the return stack, puts it back
;;; as the instruction pointer, and calls next.
exit
  ;; formerly jsr rpull, now unrolled.
  inc RP            ; take value off return stack and put it in IP
  lda (RP)
  sta IP
  inc RP
  lda (RP)          ; and place it in the instruction pointer
  sta IP+1
null
  jmp next          ; go execute the next instruction




;;;
;;; *** PRIMITIVES
;;;
;;; Individual routines for each instruction. Most of these are
;;; regular words, whose run-time behaviour is specified here and
;;; at compile-time are simply written in as addresses to the code
;;; words in the dictionary. Some have separate compile-time and
;;; run-time components (e.g. DO and (DO)).
;;;

doplus
  jsr add16
  jmp next

dominus
  jsr sub16
  jmp next

dotimes
;  jsr mult16
  jsr multmixsub
  ;; that produces a 32-bit value, so ignore the upper bytes and
  ;; just copy lower bytes over them
  lda 1,x
  sta 3,x
  lda 2,x
  sta 4,x
  jmp drop1cell

;;; This routine is shared between /, MOD, and /MOD. All three use
;;; SM/REM to do the division, but SM/REM requires the dividend to
;;; be a double-value. This massages the input so that it's correct
;;; before doing the division.
divmodsub
.(
  dex               ; make space on the stack
  dex
  lda 3,x           ; copy 16-bit value into the new top of stack
  sta 1,x
  lda 4,x
  sta 2,x

  lda 5,x           ; now convert next-to-top to 32 bits. start
  sta 3,x           ; by copying the two bytes we have into the
  lda 6,x           ; new lower positions
  sta 4,x

  bit 4,x           ; test the sign bit and sign-extend into the
  bpl dozero        ; upper two bytes.
  lda #$ff          ; negative, so fill with ones.
  sta 5,x
  sta 6,x
  bra continue
dozero
  stz 5,x           ; positive, so fill with zeros
  stz 6,x
continue
  jsr smdivmodsub   ; actual division happens here
  rts
.)    

dodiv
  jsr divmodsub
  lda 1,x
  sta 3,x
  lda 2,x
  sta 4,x
  jmp drop1cell

domod
  jsr divmodsub
  jmp drop1cell

dodivmod
  jsr divmodsub
  jmp next

dotwotimes
.(
  asl stackbase+1,x ; shift the word left
  rol stackbase+2,x
  jmp next
.)

dotwodiv
  lda stackbase+2,x
  cmp #128          ; sets carry to top bit, for sign extension
  ror stackbase+2,x
  ror stackbase+1,x
  jmp next  

doprint16
  jsr print16s
  jmp next

douprint16
  jsr print16u
  jmp next

dorprint16
  jsr swap16        ; pull number to be printed to the top
  jsr rprint16s
  jmp next

doprint32
  jsr print32s
  jmp next

doprint32u
  jsr print32u
  jmp next

dorprint32
  ;; top cell is the field width. next two cells down are the
  ;; double-length number. Do a custom rotation.
  lda stackbase+2,x ; push top cell onto hardware stack, MSB first
  pha
  lda stackbase+1,x
  pha
  lda stackbase+3,x ; move double-word from +3 through +6 to
  sta stackbase+1,x ; +1 through +4
  lda stackbase+4,x
  sta stackbase+2,x
  lda stackbase+5,x
  sta stackbase+3,x
  lda stackbase+6,x
  sta stackbase+4,x
  pla               ; restore field width from hardware stack
  sta stackbase+5,x ; but tuck it under the double word
  pla
  sta stackbase+6,x
  jsr rprint32s
  jmp next

docr
  jsr crlf
  jmp next

dodup
  jsr dup16
  jmp next

dodrop
drop1cell
  inx
  inx
  jmp next

doswap
  jsr swap16
  jmp next

;;; Implements PICK. When given a parameter over, say, 64, this is
;;; likely to go very wrong.
dopick
  jsr pop16         ; pop value off the stack
  asl stackaccess   ; multiply by two to convert to bytes
  rol stackaccess+1
  clc
  lda stackaccess   ; add that to stackbase
  adc #<stackbase
  sta stackaccess
  lda stackaccess+1
  adc #>stackbase
  sta stackaccess+1
  clc
  txa               ; now add X + 1
  inc
  adc stackaccess
  sta stackaccess
  lda stackaccess+1
  adc #0
  sta stackaccess+1

  dex
  dex
  ldy #0
  lda (stackaccess),y
  sta stackbase+1,x
  iny
  lda (stackaccess),y
  sta stackbase+2,x

  jmp next 


doquerydup
.(
  lda stackbase+1,x
  ora stackbase+2,x
  beq done
  jsr dup16
done
  jmp next
.)

dorshift
.(
  jsr pop16         ; max is 32 by standard, so need just one byte
  ldy stackaccess
loop
  lsr stackbase+2,x ; going right, so start with MSB
  ror stackbase+1,x
  dey
  bne loop
.)
  jmp next

dolshift
.(
  jsr pop16         ; max is 32 by standard, so need just one byte
  ldy stackaccess
loop
  asl stackbase+1,x ; going left, so start with LSB
  rol stackbase+2,x
  dey
  bne loop
.)
  jmp next

doequal
.(
  lda stackbase+1,x
  cmp stackbase+3,x
  bne notequal
  lda stackbase+2,x
  cmp stackbase+4,x
  bne notequal
equal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp settrue
notequal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp setfalse
.)


donotequal
.(
  lda stackbase+1,x
  cmp stackbase+3,x
  bne notequal
  lda stackbase+2,x
  cmp stackbase+4,x
  bne notequal
equal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp setfalse
notequal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp settrue
.)


;;; No 16-bit comparisons, so for signed arithmetic, we basically
;;; have to do a subtraction and then test for overflow. this
;;; routine is borrowed from fig6502 and I'm still not sure what
;;; the EOR is for, if anything.
dogreater
.(
  sec
  lda stackbase+1,x
  sbc stackbase+3,x
  lda stackbase+2,x
  sbc stackbase+4,x
  bvc there
  eor #$80
there
  bpl here
  inx
  inx
  jmp settrue
here
  inx
  inx
  jmp setfalse
.)


;;; See dogreater above.
doless
.(
  sec
  lda stackbase+3,x
  sbc stackbase+1,x
  lda stackbase+4,x
  sbc stackbase+2,x
  bvc there
  eor #$80
there
  bpl here
  inx
  inx
  jmp settrue
here
  inx
  inx
  jmp setfalse
.)


dodepth
  stx SCRATCH
  lda #$ff
  sec
  sbc SCRATCH
  clc
  lsr               ; shift right to divide by two
  stz stackbase,x
  dex
  sta stackbase,x
  dex
  jmp next

doemit
  lda stackbase+1,x
  jsr puta
  jmp drop1cell

;;; Implements OVER. We do everything inline here rather than using
;;; push and poop.
doover
  dex
  dex
  lda stackbase+5,x
  sta stackbase+1,x
  lda stackbase+6,x
  sta stackbase+2,x
  jmp next

;;; Implements ROT. We do everything inline here rather than using
;;; push and pop.
dorot
  dex               ; make some new space on the stack temporarily
  dex
  lda stackbase+7,x ; first, copy the item from three down on the stack
  sta stackbase+1,x ; into the new space
  lda stackbase+8,x ; so, 7/8 -> 1/2
  sta stackbase+2,x

  lda stackbase+5,x ; now move everything back
  sta stackbase+7,x ; first, 5/6 -> 7/8
  lda stackbase+6,x
  sta stackbase+8,x
  lda stackbase+3,x ; then 3/4 -> 5/6
  sta stackbase+5,x
  lda stackbase+4,x
  sta stackbase+6,x
  lda stackbase+1,x ; then 1/2 -> 3/4
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x

  jmp drop1cell
;  inx               ; clean up
;  inx
;  jmp next


;;; DOLIT is the run-time code for literal values. Read the contents of
;;; the next parameter as a value to be pushed onto the stack.
;;; We enter with IP indicating the literal value; we increment IP
;;; by two bytes (one cell) so that skips to the next instruction to be
;;; executed. Since this is a very frequently executed routine, 
;;; the push is unrolled rather than doing a jsr push16.
;;; 
;;; (wouldn't "(literal)" be a more consistent name for this?)
dolit
  dex               ; make space on the stack
  dex
  lda (IP)          ; load the value at the instruction pointer
  sta stackbase+1,x
  ldy #1            ; and MSB
  lda (IP),y
  sta stackbase+2,x

incIPby2
.(
  clc
  lda IP            ; increment IP to next cell (which stores the value)
  adc #2
  sta IP
  bcc continue
  inc IP+1
continue
.)

  jmp next
  

;;; dostrlit is the run-time behaviour for S" (ie, string literal).
;;; However, strings are stored as counted-strings but will be processed
;;; as string-plus-count so we need to convert (basically by adding
;;; one to the strong address)
dostrlit
  lda (IP)        ; load the string count
  pha             ; cache it for the moment

  clc
  lda IP           ; IP points to the address of counted string
  adc #1           ; so add one
  sta stackaccess  ; before store in stackaccess
  lda IP+1
  adc #0
  sta stackaccess+1
  jsr push16       ; add to the data stack
  
  pla              ; recover the length count
  sta stackaccess
  stz stackaccess+1 ; max 255 characters in a string
  jsr push16

  lda (IP)         ; load the count again
  inc              ; add one to get number of bytes to skip
  clc              ; bump IP past the string constant
  adc IP
  sta IP
  lda IP+1
  adc #0
  sta IP+1

  jmp next         ; done

;;; dovaddr is the internal code for variables... look up the current
;;; XT and use it to find the address reserved for the variable, and
;;; push that. (Similarly this should perhaps be called "(VARIABLE)").
dovaddr
  dex               ; make space on the stack
  dex
  clc
  lda XT            ; find the param space, two bytes after the XT
  adc #2
  sta stackbase+1,x ; and store it on top of the stack
  lda XT+1          ; same for MSB
  adc #0
  sta stackbase+2,x
  jmp next

;;; As above, but for constants, so we don't load the address,
;;; but the value.
doloadconst
  dex               ; make some space on the stack
  dex
  ldy #2            ; looking at (XT)+2 (param space)
  lda (XT),y        ; load LSB
  sta stackbase+1,x ; straight onto the stack
  iny
  lda (XT),y        ; MSB
  sta stackbase+2,x
  jmp next          ; done
  


;;; dofetch is the code for "@". Pull an address off the stack and
;;; look up the 16-bit data stored at that address
dofetch
  lda stackbase+1,x ; don't actually pop the address, just grab it
  sta stackaccess
  lda stackbase+2,x
  sta stackaccess+1
  ldy #1
  lda (stackaccess)  ; load MSB and store on stack
  sta stackbase+1,x  ; store back on the stack
  lda (stackaccess),y  ; then LSB
  sta stackbase+2,x
  jmp next

;;; docfetch implements c@ -- same as dofetch but loads just one byte
docfetch
  lda stackbase+1,x ; don't actually pop the address, just grab it
  sta stackaccess
  lda stackbase+2,x
  sta stackaccess+1
  lda (stackaccess) ; grab single byte at the address
  sta stackbase+1,x ; and store in LSB
  jsr pop16         ; pop address into stackaccess
  dex               ; make space on the stack
  dex
  stz stackbase+2,x ; set MSB to zero
  jmp next


;;; dostore is the code for "!". Pull an address of the stack as in
;;; dofetch; but store the address pointed to by the next stack
;;; location in it.
dostore
  jsr pop16         ; put address into stackaccess
  ldy #1
  lda stackbase+1,x  ; load LSB off stack and
  sta (stackaccess)    ; store at location we popped
  lda stackbase+2,x    ; then for MSB
  sta (stackaccess),y  ; with y=1
;  inx               ; drop the value from the stack
;  inx
;  jmp next
  jmp drop1cell

;;; doplusstore is the code for +!
doplusstore
  jsr pop16         ; put address into stackaccess
  clc
  ldy #1
  lda stackbase+1,x  ; load LSB off stack and
  adc (stackaccess)
  sta (stackaccess)    ; store at location we popped
  lda stackbase+2,x    ; then for MSB
  adc (stackaccess),y
  sta (stackaccess),y  ; with y=1
;  inx               ; drop the value from the stack
;  inx
;  jmp next
  jmp drop1cell

;;; cstore implements "c!" - like store but just one byte (LSB from stack)
docstore
  jsr pop16         ; put address into stackaccess
  lda stackbase+1,x ; load LSB off stack and
  sta (stackaccess) ; store at location we popped
;  inx               ; drop the value from the stack
;  inx
;  jmp next
  jmp drop1cell

;;; Turn an integer count of cells into a count of bytes. Since
;;; my cells are two bytes, that means multiplying item on top of
;;; stack by two (shift left).
docells
  asl stackbase+1,x
  rol stackbase+2,x
  jmp next


;;; variable reads the next word from input and allocates space
;;; for it in the dictionary as a variable (ie with the "dovaddr"
;;; code).
dovariable
  clc               ; indicates we want create to update DT
  jsr createsub     ; use CREATE to set up new dictionary entry

  ldy #0

  ;; set code to dovaddr
  lda #<dovaddr
  sta (DP),y
  iny
  lda #>dovaddr
  sta (DP),y
  iny

  iny               ; bump twice more to allow parameter space
  iny               ; for storage

.(
  clc               ; update DP to next available space
  tya               ; by adding bytes consumed to DP
  adc DP
  sta DP
  bcc continue
  inc DP+1
continue
.)
 
  jmp next


;;; create a new entry in the dictionary using the next word given
;;; in the input stream. This relies on createsub to do much of the
;;; manipulation; that code is also shared with dovariable, doconstant,
;;; and docolon. The word returns the next available storage location.
docreate
  clc               ; indicates that create should update DT
  jsr createsub

  ldy #1
  lda #<dovaddr
  sta (DP)
  lda #>dovaddr
  sta (DP),y
  iny

.(
  clc
  tya
  adc DP
  sta DP
  bcc done
  inc DP+1
done
.)
  jmp next


;;; this subroutine adds a new entry to the dictionary. On exit,
;;; DT has been updated to the new entry, and DP points to the next
;;; available byte, which should be for the code field for the entry.
;;; Whatever calls createsub has to finish the job by adding a code
;;; field at DP.
;;;
;;; whether or not DT is updated depends on the carry flag (clear for
;;; yes and set for no).
createsub
  php               ; preserve the carry flag
  jsr readnext      ; get next word from input buffer into WORD
 
  ;; copy word from WORD
  lda WORD          ; first, copy the count
  sta (DP)
  tay               ; store count in Y
.(
copynext            ; now copy the rest of the word, backwards
  lda WORD,y        ; copy Yth letter
  sta (DP),y        ; store it in dictionary space
  dey               ; count down to 0
  bne copynext
.)

  lda (DP)          ; set Y to next available byte offset
  tay
  iny

  ;; set link to location pointed to by DT
  lda DT
  sta (DP),y
  iny
  lda DT+1
  sta (DP),y
  iny

.(
  plp               ; retreive the carry flag
  bcs continue      ; skip to end if carry is set
  ;; set DT to new top entry, the one we've just created here
  lda DP
  sta DT
  lda DP+1
  sta DT+1
continue
.)

.(
  ;; inc DP by Y
  clc
  tya
  adc DP
  sta DP
  bcc done
  inc DP+1
done
.)
  rts


;;; constant reads the next word from input and allocates space
;;; for it in the dictionary as a constant (just like variable
;;; above, except that the code will do something different).
doconstant
  clc               ; signals that create should update DT
  jsr createsub     ; use CREATE to set up new dictionary entry

  ldy #0

  ;; set code to doloadconst
  lda #<doloadconst ; one of only two lines different from above
  sta (DP),y
  iny
  lda #>doloadconst ; and this is the other one
  sta (DP),y
  iny

  ;; now load a word from the stack and copy it into the
  ;; space for the constant value
  lda stackbase+1,x
  sta (DP),y
  iny
  lda stackbase+2,x
  sta (DP),y
  iny
  inx               ; drop two bytes (one cell) from the stack
  inx               

.(
  clc               ; update DP to next available space
  tya               ; by adding bytes consumed to DP
  adc DP
  sta DP
  bcc continue
  inc DP+1
continue
.)
 
  jmp next


;;; dohere implements "HERE" and just returns the pointer to the next
;;; available dictionary spot.
dohere
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16
  jmp next


;;; ALLOT takes a number of bytes and bumps DP, which makes that many
;;; bytes available to whatever is at the top of the dictionary. It's
;;; used to allocate array space to variables.
doallot
  jsr pop16
  clc
  lda DP
  adc stackaccess
  sta DP
  lda DP+1
  adc stackaccess+1
  sta DP+1
  jmp next


;;; Leave the system after printing a termination message. This
;;; just ends with an RTS, which should take us back to the monitor
;;; if we were called that way, or will crash things if we weren't,
;;; which has the same effect!
dobye
  lda #<exitmsg
  sta PRINTVEC
  lda #>exitmsg
  sta PRINTVEC+1
  jsr printvecstr
;  ldy #0
;.(
;next_char
;wait_txd_empty  
;  lda ACIA_STATUS
;  and #$10
;  beq wait_txd_empty
;  lda exitmsg,y
;  beq done
;  sta ACIA_DATA
;  iny
;  jmp next_char
;done
;.)
  rts

;;; rcopy (for the Forth word "R") -- copy top of R stack onto data stack
;;; this code also implements I (since it's the same thing).
dorcopy
  dex               ; make space on user stack
  dex
  ldy #1
  lda (RP),y        ; LSB of top value on return stack
  sta stackbase+1,x ; add to user stack
  iny
  lda (RP),y        ; and then again for MSB
  sta stackbase+2,x
  jmp next


;;; j copies immediately outer loop value (basically, third item down
;;; on the return stack)
doj
  dex               ; make space on user stack
  dex
  ldy #5            ; get data from bytes 5 and 6 (third value down)
  lda (RP),y        ; LSB of value on return stack
  sta stackbase+1,x ; add to user stack
  iny
  lda (RP),y        ; and then again for MSB
  sta stackbase+2,x
  jmp next


;;; k copies second outer loop value (basically, fifth item down
;;; on the return stack)
dok
  dex               ; make space on user stack
  dex
  ldy #9            ; get data from bytes 9 and 10 (fifth value down)
  lda (RP),y        ; LSB of value on return stack
  sta stackbase+1,x ; add to user stack
  iny
  lda (RP),y        ; and then again for MSB
  sta stackbase+2,x
  jmp next


;; dotor (for the Forth word ">R" -- move from top of stack onto r-stack
;;;
dotor
  ;jsr pop16
  ;jsr rpush
  lda stackbase+2,x
  sta (RP)
  dec RP
  lda stackbase+1,x
  sta (RP)
  dec RP            ; BUG presumes that RP doesn't roll over page boundary
  jmp drop1cell
;  inx
;  inx
;  jmp next


;; dofromr (for Forth word "R>" -- move from r-stack to top of stack
;;;
dofromr
;  jsr rpull
  dex
  dex
  inc RP
  lda (RP)
  sta stackbase+1,x
  inc RP
  lda (RP)
  sta stackbase+2,x
  jmp next

;;; docolon implements the colon-word... basically, acts like
;;; variable in that it opens up a dictionary word, althogh this
;;; time for a dolist definition. Also, it sets the compile flag.
;;;
;;; NB things will go wrong if we enconter a colon inside a colon
;;; definition or start to process variables or something. We presume
;;; that nothing is going to mess with DP while compilation is in
;;; progress.
;;;
docolon
  ;; first, set the compiler flag
  lda STATUS
  ora #COMPILE
  sta STATUS

  lda DP            ; cache the address of the word we're now compiling
  sta CWORD         ; we wait until we're done (dosemic) before we update
  lda DP+1          ; the top-of-dictionary pointer
  sta CWORD+1

  ;; use CREATE to add a new entry to the dictionary
  sec               ; signals that create shouldn't update DT
  jsr createsub

  ldy #0

  ;; set code to dolist
  lda #<dolist
  sta (DP),y
  iny
  lda #>dolist
  sta (DP),y
  iny

  clc               ; update DP to next available space
  tya               ; by adding bytes consumed to DP
  adc DP
  sta DP
  lda DP+1
  adc #0
  sta DP+1
 
  jmp next           ; not sure which of these is right...


;;; do-semi-colon, ie, tidy up when we're finishing compiling a word
;;;
dosemic
  ;; turn off the compiler
  lda STATUS
  and #%11111110
  sta STATUS

  ;; add call to exit at the end of the entry
  ldy #0
  lda #<exitcode
  sta (DP),y
  iny
  lda #>exitcode
  sta (DP),y

  ;; update DP for those two last bytes
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  ;; set DT to new top entry, the word we've just finished compiling
  ;; BUG this may be unnecessary now, handled by CREATE?
  lda CWORD
  sta DT
  lda CWORD+1
  sta DT+1

  jmp next


;;; docomma is the basic compilation mechanism.
docomma
  jsr commasub
  jmp next

;;; add value from the stack to the dictionary at DP and inc DP
commasub
  ldy #0
  lda stackbase+1,x
  sta (DP),y
  iny
  lda stackbase+2,x
  sta (DP),y
  iny

.(
  clc
  tya
  adc DP
  sta DP
  bcc done
  inc DP+1
done
.)

  inx
  inx
  rts

;;; Do dot-quote. I'm not entirely happy with my solution for this yet.
;;; This word has three different context-dependent behaviors:
;;; 1. when we are compiling (determined by compiler flag), assemble
;;;    string from the text stream and compile it into the word.
;;; 2. when we are called as part of a regular execution cycle, print
;;;    the word that's compiled in following this instruction.
;;; 3. when we are running in the interpreter, as determined by IP
;;;    pointing to the dummy word, assemble the string that follows
;;;    in the input buffer and print it.
dodotqu
.(
  ;; are we compiling?
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; Yes. compile it (case 1)
  ;; first, add in the execution word
  lda #<dotquotecode
  sta (DP)
  ldy #1
  lda #>dotquotecode
  sta (DP),y

  ;; then update DP by 2, to account for that word
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  ;; next, assemble the string on the PAD
  jsr assemblestr

  ;; now we copy it into space where we are comping, pointed to by DP.
  lda PAD           ; first, copy the length
  sta (DP)

.(
  tay               ; now copy the rest of the string (backwards)
charloop
  lda PAD,y
  sta (DP),y
  dey
  bne charloop
.)

  ;; now update DP to account for the string
  clc
  lda PAD           ; that's the length count for the string
  inc               ; add one for the count byte
  adc DP            ; bump DP by that many bytes
  sta DP
  lda DP+1
  adc #$0
  sta DP+1

  jmp next          ; and proceed. we're done.

nocompile
  ;; are we interactive?
  ;; we can tell if IP points to dummyexit
  lda IP
  cmp #<dummyexit
  bne nointerp
  lda IP+1
  cmp #>dummyexit
  bne nointerp

  ;; Yes, so we need the interactive behaviour (case 3)

  ;; first. assemble the string to be printed
  jsr assemblestr

  ;; now print it
  ;; but first, write in a space over the length indicator,
  ;; which we don't need because it's null-terminated
  lda #$20
  sta PAD

  ldy #0
.(
next_char
;wait_txd_empty  
;  lda ACIA_STATUS
;  and #$10
;  beq wait_txd_empty
  lda PAD,y
  beq done
  jsr puta
;  sta ACIA_DATA
  iny
  bra next_char
done
.)

  jmp next          ; we're done so proceed to next instruction

nointerp
  ;; Finally, this is the regular behavior (case 2). We're executing
  ;; from a compiled word. So IP points to a counted string. Print
  ;; it, and increment the instruction pointer appropriately.

;.(
;wait_txd_empty  
;  lda ACIA_STATUS
;  and #$10
;  beq wait_txd_empty
;  lda #$20          ; print a space to begin
;  sta ACIA_DATA
;.)
  lda #$20
  jsr puta

  phx               ; save X, since we're about to use it
  lda (IP)          ; load the string length
  tax               ; transfer to X. X counts down as Y counts up
  ldy #1

  ;; now print X characters 
.(
next_char
;wait_txd_empty  
;  lda ACIA_STATUS
;  and #$10
;  beq wait_txd_empty
  lda (IP),y
;  sta ACIA_DATA
  jsr puta
  iny
  dex
  bne next_char
done
.)

  plx               ; restore X

  ;; finally, update the instruction pointer
  ;; Y is the number of characters plus one (because of the last iny)
  ;; so that's actually just the right number to add to the IP.
.(
  tya               ; transfer Y to A and add it to IP
  clc
  adc IP            ; LSB
  sta IP
  bcc continue
  inc IP+1          ; MSB in case of carry
continue
.)
.)

  jmp next          ; continue to the next instruction


;;; This is the compiler behavior for S"; it compiles dostrlit
;;; and an inline string constant. (do-s-quote)
dosquote
  ldy #1
  lda #<sliteralcode
  sta (DP)
  lda #>sliteralcode
  sta (DP),y

  ;; then update DP by 2, to account for that word
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  jsr assemblestr   ; read and assemble string from input

  ;; now we copy it into space where we are comping, pointed to by DP.
  ;; BUG this is technically $,"... yeah?
  ldy PAD           ; first, copy the length
  sta (DP)

.(
  tay               ; now copy the rest of the string (backwards)
charloop
  lda PAD,y
  sta (DP),y
  dey
  bne charloop
.)

  ;; now update DP to account for the string
  clc
  lda PAD           ; that's the length count for the string
  inc               ; add one for the count byte
  adc DP            ; bump DP by that many bytes
  sta DP
  lda DP+1
  adc #$0
  sta DP+1

  jmp next          ; done


;;; Read text from the input buffer up until a single quote mark
;;; and assemble it onto the PAD. At the end, we'll have a string
;;; that is both counted and null-terminated. This is used in both
;;; compile mode and run mode of dotquote and in S".
assemblestr

  ;; first, set up the PAD ptr
  lda #<PAD
  sta PADPTR
  lda #>PAD
  sta PADPTR+1

.(
  ;; read the next word into WORD
continue
  jsr readnext

  ;; is it a closing quote? count of 1, char is $22
  lda WORD
  cmp #$01          ; check the string length
  bne assemble
  lda WORD+1        ; we know it's a single-character string
  cmp #$22          ; check the single character
  beq finished

assemble
  ;; concatenate onto the string we're assembling at PAD
  lda #$20          ; space
  sta (PADPTR)
  ldy WORD          ; the character count
.(
nextchar
  lda WORD,y
  sta (PADPTR),y    ; Y is off-by-one but it's okay (leading space)
  dey
  bne nextchar
.)

  ;; update PADPTR
.(
  lda WORD          ; length of this most recent word
  inc               ; plus leading space
  clc
  adc PADPTR
  sta PADPTR        ; update the pointer
  bcc skipmsb
  inc PADPTR+1      ; in case we generated a carry...
skipmsb
.)

  ;; update count
  sec               ; BUG this will stop working if PAD crosses word boundary
  lda PADPTR
  sbc #<PAD
  dec               ; subtract one (don't count the count byte itself)
  sta PAD

  ;; if the word ended with a quote mark, then remove it and
  ;; finish. otherwise, loop
  ldy WORD
  lda WORD,y
  cmp #$22
  bne continue

  sec               ; move PADPTR back by one character
  lda PADPTR        ; to remove the quote mark
  sbc #1
  sta PADPTR
  lda PADPTR+1
  sbc #0
  sta PADPTR+1
.)
finished
  ;; add a null at the end of the string
  lda #$00
  sta (PADPTR)

  rts


;;; discardcomment reads from the input buffer until it finds
;;; the end-of-comment marker. Somewhat like assemblestr except
;;; that there is no assembly.
discardcomment
.(
continue
  jsr readnext

  lda WORD
  cmp #$01
  bne continue
  lda WORD+1
  cmp #$29          ; 0x29 is closing parenthesis
  bne continue

  rts
.)


;;; dotype implements TYPE. Reads a count and a string address from the
;;; stack and prints the number of characters indicated in the count.
dotype
  jsr pop16
  lda stackaccess
  sta SCRATCH       ; put count in SCRATCH
  jsr pop16         ; fetch the string address
  lda SCRATCH
  beq endtype       ; stop now if the count was 0

  ldy #0
typenext
  lda (stackaccess),y
  jsr puta
  iny
  cpy SCRATCH
  bne typenext

endtype
  jmp next


;;; doaccept implements ACCEPT
;;; ( caddr n1 -- n2 )
;;; n1 is the maximum number of characters to read; n2 is the number
;;; actually read
;;; BUG fix this wrt readtermline...
doaccept
.(
  lda stackbase+3,x
  sta SCRATCH
  lda stackbase+4,x
  sta SCRATCH+1
nextchar
  jsr readchar
  cmp #$08
  beq backspace
  cmp #$0D
  beq newline
  sta (SCRATCH)
  jsr puta
  clc
  lda SCRATCH
  adc #1
  sta SCRATCH
  bcc doneadd
  inc SCRATCH+1
doneadd
  lda SCRATCH       ; if char limit not reached, then
  cmp stackbase+1,x ; branch back to fetch next character
  bne nextchar
  lda SCRATCH+1
  cmp stackbase+2,x
  bne nextchar
  ;; otherwise, hit limit so fall through
newline
  jsr swap16        ; swap parameters
  sec               ; calculate length of string read, and store it
  lda SCRATCH       ; over input length as return value on stack
  sbc stackbase+1,x
  sta stackbase+3,x
  lda SCRATCH+1
  sbc stackbase+4,x
  sta stackbase+2,x
  inx               ; clean up the stack
  inx
  jmp next
backspace
  lda SCRATCH       ; are we still at the start of the string?
  cmp stackbase+3,x
  bne continue
  lda SCRATCH+1
  cmp stackbase+4,x
  beq nextchar      ; if so, ignore the backspace
continue
  lda #$08
  jsr puta
  sec
  lda SCRATCH
  sbc #1
  sta SCRATCH
  lda SCRATCH+1
  sbc #0
  sta SCRATCH+1
  bra nextchar
.)


;;; 0branch is an internal word used for conditionals. Test top of stack,
;;; and if false, add the next parameter (ie instruction offset) to the
;;; IP. When we come in, the IP is pointing to the branch address,
;;; so that is the position from which the offset is to be calculated.
dozerobra
  jsr pop16         ; pull value off the top of the stack
  lda stackaccess   ; test for zero
  ora stackaccess+1
  beq dobranch      ; if it's zero, then jump to branch code

nonzero
  ;; otherwise we will continue with processing, but first,
  ;; increment IP to skip the branch offset.
;.(
;  clc
;  lda IP
;  adc #2
;  sta IP
;  bcc skipmsb
;  inc IP+1
;skipmsb
;.)
;
;  jmp next          ; all done, proceed to next instruction
  jmp incIPby2

;;; dobranch is used by ELSE; does an immediate branch. So, it's just
;;; like 0branch if the top stack value is 0; in fact, 0branch calls
;;; this code in that case
dobranch
  ldy #1  
  lda (IP),y        ; load offset and cache it on the stack
  pha               ; do MSB first because we want to pull
  lda (IP)          ; LSB first
  pha

  clc               ; now add the cached offset to the IP
  pla
  adc IP
  sta IP
  pla
  adc IP+1
  sta IP+1

  jmp next


;;; doif is an immediate word that compiles IF.
;;; compile it into a 0bra, and put the address of the branch word
;;; onto the stack. Pesume that THEN will later come back
;;; and fix up the address
;;;
doif
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  lda #<zerobracode
  sta (DP)
  ldy #1
  lda #>zerobracode
  sta (DP),y

  ;; bump DP by two (to move on to the branch address location)
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  ;; put that on the stack so that ELSE or THEN can find it later
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  ;; add the IFELSEFLAG to the stack
  lda #IFELSEFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

  ;; bump DP by two again (to move to next instruction space)
  jmp incDPby2

nocompile
  jmp abortcompile
.)


;;; This is the compiler behavior for THEN. We look on the stack for
;;; address of the branch offset, then calculate the offset and
;;; write it in.
;;;
dothen
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; pop the flag from the stack and make sure it's an IFELSEFLAG
  jsr pop16
  lda stackaccess
  cmp #IFELSEFLAG
  beq thenproceed

  jmp abortnest

thenproceed
  ;; take the current DP pointer, and subtract from it the value on
  ;; the stack. The result is the offset that should be stored in
  ;; the word pointed to by the item on the stack. Pop it from the stack.

  jsr pop16         ; pop branch address into stackaccess

  sec               ; calculate offset
  lda DP
  sbc stackaccess
  sta SCRATCH
  lda DP+1
  sbc stackaccess+1
  sta SCRATCH+1

  lda SCRATCH       ; write it into the branch instruction
  sta (stackaccess)
  ldy #1
  lda SCRATCH+1
  sta (stackaccess),y
  bra done

nocompile
  jmp abortcompile

done
  jmp next          ; done. proceed to next instruction.
.)


;;; doelse is the compiler behavior for ELSE. Like THEN, it updates
;;; the prior branch address that's been left on the stack. Like IF,
;;; it compiles in a branch (not 0branch this time) and leaves an address
;;; on the stack for THEN to fill in.
;;;
doelse
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; First, pop the flag off the stack and ensure it's the IFELSEFLAG.
  jsr pop16
  lda stackaccess
  cmp #IFELSEFLAG
  beq elseproceed
  jmp abortnest
  
elseproceed

  ;; Next, compile in the branch instruction and keep a copy of
  ;; the branch address to be put on the stack in a moment.
  ;; this way, a successful IF clause should hit a branch that causes
  ;; it to jump to the end (skipping the ELSE clause)
  lda #<branchcode
  sta (DP)
  ldy #1
  lda #>branchcode
  sta (DP),y

.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  lda DP            ; cache this address for a moment
  sta SCRATCH+2
  lda DP+1
  sta SCRATCH+3

.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  ;; Next, do the THEN-like behavior and update the address left by IF.
  ;; Take the current DP pointer, and subtract from it the value on
  ;; the stack. The result is the offset that should be stored in
  ;; the word pointed to by the item on the stack. Pop it from the stack.

  jsr pop16         ; pop branch address into stackaccess

  sec               ; calculate offset
  lda DP
  sbc stackaccess
  sta SCRATCH
  lda DP+1
  sbc stackaccess+1
  sta SCRATCH+1

  lda SCRATCH       ; write it into the branch instruction
  sta (stackaccess)
  ldy #1
  lda SCRATCH+1
  sta (stackaccess),y

  ;; Finally, put that deferred branch instruction address onto
  ;; the stack
  lda SCRATCH+2
  sta stackaccess
  lda SCRATCH+3
  sta stackaccess+1
  jsr push16

  ;;; and replace the flag.
  lda #IFELSEFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

  jmp next

nocompile
  jmp abortcompile
.)

;;; dobegin is compiler behavior for BEGIN. It simply pushes the current
;;; DP onto the user stack, so that UNTIL can find it later and use it
;;; to calculate the offset.
dobegin
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; add the current instruction location to the stack
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  ;; add a flag to signal that this is for a BEGIN
  lda #BEGINFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

nocompile
  jmp next
.)

;;; dountil is the compiler behaviour for UNTIL. It compiles a 0branch
;;; with the offset calculated from the value left on the stack by
;;; dobegin.
dountil
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; pop the flag off the stack to make sure it's a BEGINFLAG
  jsr pop16
  lda stackaccess
  cmp #BEGINFLAG
  beq proceed
  jmp abortnest
  
proceed
  ;; compile the zerobranch and update DP.
  lda #<zerobracode
  sta (DP)
  ldy #1
  lda #>zerobracode
  sta (DP),y

.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; pull the address at the start of the loop
  jsr pop16

  ;; now calculate the offset. Subtract current DP from the value
  ;; on the stack. Result is negative number (the branch backwards).
  sec
  lda stackaccess
  sbc DP
  sta SCRATCH
  lda stackaccess+1
  sbc DP+1
  sta SCRATCH+1

  ;; now write that in as a parameter to the branch.
  ;; BUG lots of needless reads and writes going on here
  lda SCRATCH
  sta (DP)
  ldy #1
  lda SCRATCH+1
  sta (DP),y

  ;; increment DP again
;.(
;  clc
;  lda DP
;  adc #2
;  sta DP
;  bcc skipmsb
;  inc DP+1
;skipmsb
;.)
;  jmp next
  jmp incDPby2

nocompile
  jmp next
.)


;;; dodo is the compiler behavior for DO (the runtime behavior is
;;; doparendo). It compiles in (do) and then pushes the next instruction
;;; address (the loop target) onto the stack along with a flag.
dodo
  ;; test if we're compiling
  lda STATUS
  bit #COMPILE
  beq nocompiledo

  ;; compile (do)
  lda #<parendocode
  sta (DP)
  ldy #1
  lda #>parendocode
  sta (DP),y

doshared            ; entry point for do-query-do below

  ;; increment DP
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; push this address on the stack as the loop target address
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  ;; push a flag to contextualize the item on the stack. LOOP will
  ;; need this in order to distinguish between a DO and a LEAVE.
  lda #DOFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

  jmp next          ; done!

nocompiledo
  jmp abortcompile

;;; doqdo is the compile-time code for ?DO, much of which is shared with
;;; do above.
;doqdo
;.(
;  ;; test if we're compiling
;  lda STATUS
;  bit #COMPILE
;  beq nocompiledo
;
;  ;; compile (do)
;  lda #<parenqdocode
;  sta (DP)
;  ldy #1
;  lda #>parenqdocode
;  sta (DP),y
;
;  jmp doshared
;
; realized that this is wrong. i need a forward branch in the case of
; the null loop. maybe make it look like a leave?


;;; doparendo is the implementation of (DO), the run-time behavior for
;;; DO. It pulls two values off the data stack (the loop limit and the
;;; loop index) and places them on the return stack (in inverted order).
doparendo
  lda stackbase+4,x ; MSB of limit
  sta (RP)
  dec RP
  lda stackbase+3,x ; LSB of limit
  sta (RP)
  dec RP
  lda stackbase+2,x ; MSB of index
  sta (RP)
  dec RP
  lda stackbase+1,x ; LSB of index
  sta (RP)
  dec RP
  clc               ; pop two cells (four types) off stack
  txa
  adc #4
  tax
  jmp next          ; done  


;;; doloop is the compiler behavior for LOOP. It compiles (LOOP) and a
;;; branch address to the address left on the stack.
doloop
  lda STATUS
  bit #COMPILE
  beq nodocompile

  lda #<parenloopcode
  sta (DP)
  ldy #1
  lda #>parenloopcode
  sta (DP),y

looptest
  ;; pop the flag off the stack and check DOFLAG or LEAVEFLAG
  jsr pop16
  lda stackaccess
  cmp #LEAVEFLAG
  beq fixleave
  cmp #DOFLAG
  beq loopcompile
  jmp abortnest

fixleave
  ;; there's a LEAVEFLAG on the stack, so update the address there
  ;; it should point to the instruction two cells (four bytes) after
  ;; this one, so first, calculate that.
  clc
  lda DP
  adc #4
  sta SCRATCH
  lda DP+1
  adc #0            ; in case of carry
  sta SCRATCH+1

  jsr pop16         ; get the address from the stack
  sec               ; substract from SCRATCH to get the offset
  lda SCRATCH
  sbc stackaccess
  pha               ; cache LSB
  lda SCRATCH+1
  sbc stackaccess+1
  ldy #1
  sta (stackaccess),y ; and write it back into stackaccess
  pla               ; pull the LSB
  sta (stackaccess)

  ;; there may be multiple LEAVEs, so loop around
  jmp looptest

;; we get here when we have found a DOFLAG on the stack
loopcompile
  ;; increment DP
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; now compile in the branch offset. first,
  ;; pull the address at the start of the loop
  jsr pop16

  ;; now calculate the offset. Subtract current DP from the value
  ;; on the stack. Result is negative number (the branch backwards).
  sec
  lda stackaccess
  sbc DP
  sta SCRATCH
  lda stackaccess+1
  sbc DP+1
  sta SCRATCH+1

  ;; now write that in as a parameter to the branch.
  ;; BUG lots of needless reads and writes going on here
  lda SCRATCH
  sta (DP)
  ldy #1
  lda SCRATCH+1
  sta (DP),y

  ;; increment DP again
incDPby2
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  jmp next
;  jmp incDPby2

nodocompile
  jmp abortcompile


;;; doplusloop implements the compiler behavior for +LOOP. Basically,
;;; it writes in a differnt code address but then jumps into the LOOP
;;; code to do all the calculations of offsets, etc.
doplusloop
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  lda #<parplusloopcode
  sta (DP)
  ldy #1
  lda #>parplusloopcode
  sta (DP),y
  bra looptest

  jmp next

nocompile
  jmp abortcompile
.)

;;; doparplusloop implements (+LOOP), the runtime code for +LOOP.
;;; much of this will be shared with (LOOP), except that we start
;;; by pulling a value from the stack to do increment.
doparplusloop
  jsr pop16         ; pull the increment value
  ldy #1
  clc               ; and add it to the value at top of r-stack
  lda (RP),y
  adc stackaccess
  sta (RP),y
  iny
  lda (RP),y
  adc stackaccess+1
  sta (RP),y

  ;; for a positive loop increment, we can just use the
  ;; same code as (LOOP). Check the sign of the increment

  bit stackaccess+1 ; test top bit of increment value
  bpl testandloop   ; branch when N=0 to shared code with (LOOP)

  ;; it's negative, so we have to do our own test
  ;; grab the loop limit and stash it in SCRATCH+2/3.
  ldy #3
  lda (RP),y
  sta SCRATCH+2
  iny
  lda (RP),y
  sta SCRATCH+3

  ;; compare index to the loop limit
.(
  ldy #1
  sec
  lda (RP),y        ; LSB of index
  sbc SCRATCH+2     ; LSB of limit
  iny
  lda (RP),y        ; MSB
  sbc SCRATCH+3
  sbc (RP),y
;  bmi noloop        ; minus if limit > index
  bpl takeloop
.)
  jmp noloop


;;; doparenloop implements (LOOP), which is the run-time code for LOOP.
;;; increment and test index and optionally branch back to address
;;; provided.
doparenloop
  ;; increment the loop index in-place
.(
  ldy #1
  clc
  lda (RP),y        ; no (),y mode for INC, sadly!
  adc #1
  sta (RP),y
  bcc continue
  iny
  lda (RP),y
  adc #0
  sta (RP),y
continue
.)

testandloop         ; also entry point for (+LOOP)
  ;; grab the loop limit and stash it in SCRATCH+2/3.
  ldy #3
  lda (RP),y
  sta SCRATCH+2
  iny
  lda (RP),y
  sta SCRATCH+3

  ;; compare index to the loop limit
.(
  ldy #1
  sec
  lda (RP),y        ; LSB, index
  sbc SCRATCH+2     ; compared to LSB, limit
  iny
  lda (RP),y
  sbc SCRATCH+3
  bpl noloop
.)

takeloop
  ;; grab the branch address from (IP) and add it to IP
  ldy #1
  lda (IP),y        ; load MSB
  pha               ; stash it
  clc
  lda (IP)          ; load LSB
  adc IP            ; add
  sta IP            ; update
  pla               ; recover stashed MSB
  adc IP+1          ; add
  sta IP+1          ; update

  jmp next

noloop
  ;; drop values from the return stack by adding 4 (4 bytes, 2 cells)
  ;; to the RP. We assume RP is all on the same page and ignore MSB.
  clc
  lda RP
  adc #4
  sta RP
;.(
;  clc
;  lda IP
;  adc #2
;  sta IP
;  bcc skipmsb
;  inc IP+1
;skipmsb
;.)
;
;  jmp next
  jmp incIPby2


;;; Doleave implements the compile-time of LEAVE. It compiles
;;; a branch, leaving an offset to be resolved later by LOOP.
doleave
  lda #<parenleavecode
  sta (DP)
  ldy #1
  lda #>parenleavecode
  sta (DP),y

  ;; increment DP to point to branch address location
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  ;; we want to push this onto the stack BUT we need to "tuck" it
  ;; under any interleaved IF/ELSE loops. so we need to look down
  ;; the stack until we find the right place to put it, copy everything
  ;; else, and then insert the address and the flag.
  dex               ; first, make space for two new cells on the stack
  dex               ; two cells equals four bytes, so four dex
  dex
  dex

  txa               ; copy X into Y. we'll use Y as the index
  tay               ; for looping down the stack

  ;; BUG BUG BUG this loop is unbounded if we don't find a flag!
lookforflag
  lda stackbase+5,y ; is top item a DOFLAG?
  cmp #DOFLAG
  beq foundflag     ; yes
  lda stackbase+5,y ; no, so we copy two cells up and try again
  sta stackbase+1,y
  lda stackbase+6,y
  sta stackbase+2,y
  lda stackbase+7,y
  sta stackbase+3,y
  lda stackbase+8,y
  sta stackbase+4,y
  iny               ; skip Y ahead to the next pair of cells
  iny
  iny
  iny
  bra lookforflag

foundflag
  ;; we have found the DOFLAG. use the two cells "above" this for our
  ;; address and flag
  lda DP            ; DP goes onto the stack
  sta stackbase+3,y
  lda DP+1
  sta stackbase+4,y
  lda #LEAVEFLAG
  sta stackbase+1,y
  lda #0
  sta stackbase+2,y

;  ;; increment DP to point to next instruction address
;.(
;  clc
;  lda DP
;  adc #2
;  sta DP
;  bcc continue
;  inc DP+1
;continue
;.)
;
;  jmp next
  jmp incDPby2


;;; doparenleave is the implementation of (leave), the run-time behavior
;;; for LEAVE. It basically just does a branch, but first, it pops
;;; some values off the return stack.
doparenleave
  clc
  lda RP
  adc #4
  sta RP
  jmp dobranch


;;; dowords. Print out the words defined in the dictionary (including
;;; variables).
dowords
.(
  jsr crlf

  ;; set up search by initializing dictionary pointer. reuse the
  ;; same pointer (DPTR) used in matching (tick).
  lda DT
  sta DPTR
  lda DT+1
  sta DPTR+1

nextentry
  ;; have we run out of dictionary entries? (when DPTR is $0000)
  lda DPTR
  bne printit
  lda DPTR+1
  beq done

printit
  ldy #0
  lda (DPTR),y
  and #%00011111    ; mask off the tags
  phx
  tax
  ldy #1
nextchar
  lda (DPTR),y
  jsr puta
  iny
  dex
  bne nextchar

  lda #$20          ; end with a space
  jsr puta
  plx

  ;; move on to the next entry
  ;;
  lda (DPTR)        ; get word length...
  and #%00011111    ; mask off the tags
  tay               ; store in Y, and add one...
  iny               ; for the pointer to the next entry
  lda (DPTR),y      ; update DPTR to point to next entry
  pha
  iny
  lda (DPTR),y  
  sta DPTR+1
  pla
  sta DPTR
  bra nextentry

done
  jmp next
.)


;;; implements MAX (16-bit)
domax
.(
  ;; compare most significant bytes
  lda stackbase+2,x
  cmp stackbase+4,x
  beq testother
  bpl topofstack
  bra nextonstack
  
  ;; only in the case where they were equal, test less significant
testother
  lda stackbase+1,x
  cmp stackbase+3,x
  bmi nextonstack

  ;; item on the top of the stack was larger. copy it over
  ;; lower item, and pop top item off
topofstack
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  ;; and just fall through to the pop below

  ;; lower item on stack is max. just pop off the top.
nextonstack
  inx
  inx
.)

donemax
  jmp next


;;; implements MIN (16-bit)
domin
.(
  ;; compare most significant bytes
  lda stackbase+2,x
  cmp stackbase+4,x
  beq testother
  bmi topofstack
  bra nextonstack
  
  ;; only in the case where they were equal, test less significant
testother
  lda stackbase+1,x
  cmp stackbase+3,x
  bpl nextonstack

  ;; item on the top of the stack was larger. copy it over
  ;; lower item, and pop top item off
topofstack
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  ;; and just fall through to the pop below

  ;; lower item on stack is max. just pop off the top.
nextonstack
  inx
  inx
.)

donemin
  jmp next


;;; implements KEY -- read a character from the terminal and
;;; leave its ascii value on the stack
dokey
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA

  sta stackaccess
  stz stackaccess+1
  jsr push16

  jmp next

;;; implements KEY? -- returns true/false signalling whether there
;;; is keyboard input waiting to be read.
dokeyqu
  dex
  dex
  lda ACIA_STATUS
  and #$08
  beq nokey
  jmp settrue
nokey
  jmp setfalse


;;; AND, OR, XOR
;;;
doand
  lda stackbase+1,x
  and stackbase+3,x
  sta stackbase+3,x
  lda stackbase+2,x
  and stackbase+4,x
  sta stackbase+4,x
;  inx
;  inx
;  jmp next
  jmp drop1cell

door
  lda stackbase+1,x
  ora stackbase+3,x
  sta stackbase+3,x
  lda stackbase+2,x
  ora stackbase+4,x
  sta stackbase+4,x
;  inx
;  inx
;  jmp next
  jmp drop1cell

doxor  
  lda stackbase+1,x
  eor stackbase+3,x
  sta stackbase+3,x
  lda stackbase+2,x
  eor stackbase+4,x
  sta stackbase+4,x
;  inx
;  inx
;  jmp next
  jmp drop1cell


;;; implements 0=. Faster than "0 =" and works in place.
;;; uses setfalse and settrue for result, which requires that X
;;; be set appropriately for the result before we jump
doeqlzero
.(
  lda stackbase+1,x ; test for zero
  ora stackbase+2,x
  beq iszero        ; yes?
notzero
  jmp setfalse
iszero              ; yes it's zero
  jmp settrue
.)

;;; implements TRUE
dotrue
  dex
  dex
settrue
  lda #$ff
  sta stackbase+1,x
  sta stackbase+2,x
  jmp next


;;; implements FALSE
dofalse
  dex
  dex
setfalse
  stz stackbase+1,x
  stz stackbase+2,x
  jmp next


;;; 1+, 1-, 2+, 2-
;;;
do1plus
.(
  clc
  inc stackbase+1,x
  bne done
  inc stackbase+2,x
done
  jmp next
.)

do1minus
.(
  sec
  lda stackbase+1,x
  sbc #1
  sta stackbase+1,x
  bcs done
  dec stackbase+2,x
done
  jmp next
.)

do2plus
.(
  clc
  lda stackbase+1,x
  adc #2
  sta stackbase+1,x
  bcc done
  inc stackbase+2,x
done
  jmp next
.)

do2minus
.(
  sec
  lda stackbase+1,x
  sbc #2
  sta stackbase+1,x
  bcs done
  dec stackbase+2,x
done
  jmp next
.)

doinvert
  lda stackbase+1,x
  eor #$ff
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  sta stackbase+2,x
  jmp next

;;; Implements compile-time behaviour for WHILE (inside BEGIN/REPEAT).
;;; Compiles to 0branch and then leaves offset address on the stack.
dowhile
  lda #<zerobracode ; compile 0branch
  sta (DP)
  ldy #1
  lda #>zerobracode
  sta (DP),y

  ;; increment DP past the instruction and on to offset location
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  lda DP            ; push the address of the branch offset
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  lda #WHILEFLAG    ; push a flag to contextualize that address
  sta stackaccess
  stz stackaccess+1
  jsr push16

  jmp incDPby2
;  ;; increment DP once more
;.(
;  clc
;  lda DP
;  adc #2
;  sta DP
;  bcc continue
;  inc DP+1
;continue
;.)
;
;  jmp next


;;; compile-time behaviour for repeat is to fix up any stacked
;;; WHILE calls and branch back to the last BEGIN
dorepeat
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  lda #<branchcode
  sta (DP)
  ldy #1
  lda #>branchcode
  sta (DP),y

reptest
  ;; pop the flag off the stack and check DOFLAG or LEAVEFLAG
  jsr pop16
  lda stackaccess
  cmp #WHILEFLAG
  beq fixwhile
  cmp #BEGINFLAG
  beq bracompile
  jmp abortnest

fixwhile
  ;; there's a LEAVEFLAG on the stack, so update the address there
  ;; it should point to the instruction two cells (four bytes) after
  ;; the current DP, so first, calculate that.
  ;; NB this code is shared with LOOP so integrate
  clc
  lda DP
  adc #4
  sta SCRATCH
  lda DP+1
  adc #0            ; in case of carry
  sta SCRATCH+1

  jsr pop16         ; get the address from the stack
  sec               ; substract from SCRATCH to get the offset
  lda SCRATCH
  sbc stackaccess
  pha               ; cache LSB
  lda SCRATCH+1
  sbc stackaccess+1
  ldy #1
  sta (stackaccess),y ; and write it back into stackaccess
  pla               ; pull the LSB
  sta (stackaccess)

  ;; may be multiple WHILEs so loop around
  jmp reptest

bracompile
  ;; we get here when we finally hit the BEGIN flag
  ;; increment DP
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; now compile in the branch offset. first,
  ;; pull the address at the start of the loop
  jsr pop16

  ;; now calculate the offset. Subtract current DP from the value
  ;; on the stack. Result is negative number (the branch backwards).
  sec
  lda stackaccess
  sbc DP
  sta SCRATCH
  lda stackaccess+1
  sbc DP+1
  sta SCRATCH+1

  ;; now write that in as a parameter to the branch.
  ;; BUG lots of needless reads and writes going on here
  lda SCRATCH
  sta (DP)
  ldy #1
  lda SCRATCH+1
  sta (DP),y

  ;; increment DP again
;.(
;  clc
;  lda DP
;  adc #2
;  sta DP
;  bcc skipmsb
;  inc DP+1
;skipmsb
;.)
;
;  jmp next
  jmp incDPby2

nocompile
  jmp abortcompile
.)


;;; Implement RECURSE. This is an immediate word, and uses CWORD
;;; (plus an offset) to insert the code address of the word currently
;;; being defined).
dorecurse
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  clc
  lda CWORD         ; put word address into SCRATCH
  sta SCRATCH
  lda CWORD+1
  sta SCRATCH+1

  lda (CWORD)       ; load length of word string
  inc               ; add one for the length byte
  inc               ; and another two for the link
  inc
  clc
  adc SCRATCH       ; add to address. now scratch will contain
  sta SCRATCH       ; the address of the code word (cfa).
.(
  bcc continue
  inc SCRATCH+1
continue
.)
  lda SCRATCH       ; write the address it at compiler location
  sta (DP)
  ldy #1
  lda SCRATCH+1
  sta (DP),y

;  ;; increment DP
;.(
;  clc
;  lda DP
;  adc #2
;  sta DP
;  bcc continue
;  inc DP+1
;continue
;.)
;
;  jmp next          ; we're done
  jmp incDPby2

nocompile
  jmp abortcompile
.)

;;; backslash -- ignore the rest of the line
dobackslsh
  stz TCNT          ; flush the input buffer
  stz TPTR
  jmp next


;;; do comment. this is called as an immediate word. it basically
;;; skips ahead in the input buffer until it reads a word that is
;;; a singular closing parenthesis by itself.
docomment
  jsr discardcomment
  jmp next


doabs
.(
  lda stackbase+2,x ; is number on stack negative?
  bit #%10000000
  beq endabs        ; no it's not, so we're done

  jmp donegate      ; otherwise, negate it
endabs
.)
  jmp next


donegate
  clc               ; flip bits and add one to form two's complement
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  jmp next

;;; Implements .S, which prints the stack, mainly for debugging.
;;; Can't mess with X because we need to keep it as a working stack
;;; pointer ('cos we need to put numbers on the top of the stack
;;; to print them!
dodots
.(
  ;; first, cache a copy of the stack pointer
  txa
  sta SCRATCH+8
  ;; then set Y to the bottom of the stack
  ldy #$ff
loop
  cpy SCRATCH+8     ; when we hit the saved stack pointer, stop
  beq done
  dey               ; move to next stack location
  dey
  dex               ; make space on the top of the stack
  dex
  lda stackbase+1,y ; copy from location pointed to by Y
  sta stackbase+1,x ; into new top-of-stack position
  lda stackbase+2,y
  sta stackbase+2,x
  jsr print16s      ; that will also pop the copy from the stack
  bra loop
done
.)
  jmp next

;;; dotick implements TICK ('). Grabs a word and looks is up in the
;;; dictionary. In the interpreter, leaves the xt on the stack; in
;;; the compiler, compiles it in to the current definition.
dotick
.(
  jsr readnext
  jsr dictmatch

  lda DPTR+1
  bne continue
  lda #$20
  jsr puta
  jsr printword
  jmp abortnotdef

continue
  clc               ; calculate xt. Add length of word, plus one for
  lda (DPTR)        ; the length byte and two for the link
  and #%00011111    ; mask off the status bits
  adc #3            ; max count value is 32, so this won't cause carry
  adc DPTR
  sta stackaccess
  lda DPTR+1
  adc #0            ; in case of carry
  sta stackaccess+1

  ;; now check -- are we compiling? If so, then compile a literal
  ;; with that value. If not, push it on the stack.
  lda STATUS
  beq nocompile

  ;; compiling (note code shared with interpreter BUG COMBINE)
  ldy #0
  lda #<dolitcode
  sta (DP),y
  iny
  lda #>dolitcode
  sta (DP),y
  iny
  lda stackaccess
  sta (DP),y
  iny
  lda stackaccess+1
  sta (DP),y
  iny

  ;; add Y to DP
  clc
  tya
  adc DP
  sta DP
  lda DP+1
  adc #0
  sta DP+1
  bra done

nocompile
  jsr push16
done
  jmp next
.)

;;; doforget implements FORGET. Uses the same dictionary matching
;;; routine as the text interpreter (I'm gradually breaking this stuff
;;; out so that it can be used more generically).
doforget
.(
  jsr readnext      ; read next word from input stream
  jsr dictmatch     ; look for a match
  lda DPTR+1        ; no words on zero page, so only need to check this
  beq nomatch

  ;; first, reset DP to this location
  lda DPTR
  sta DP
  lda DPTR+1
  sta DP+1

  ;; next, grab the link pointer in order to reset DT
  lda (DPTR)        ; load the word count for this entry
  inc               ; and add one for the count byte
  clc               ; and add to DPTR, so that it points to the link
  adc DPTR
  sta DPTR
  lda DPTR+1
  adc #0
  sta DPTR+1

  ldy #1            ; reset top of dictionary to the word preceeding
  lda (DPTR)        ; the word we are forgetting
  sta DT
  lda (DPTR),y
  sta DT+1
  bra done  
  ;; BUG reset DP in here too to reuse space? not sure how safe.

nomatch
  ;; issue an error

done
  jmp next
.)

;;; doimmediate implements IMMEDIATE, which sets the IMMEDIATE flag
;;; for the most recently defined word. Not sure if it should be
;;; immediate itself! Most recently defined word is the one at the
;;; top of the dictionary, ie at DT.
doimmed
  lda (DT)
  ora #IMM
  sta (DT)
  jmp next          ; shortest instruction yet?


;;; dofill implements FILL.
dofill
  lda stackbase+5,x ; copy base address into stackaccess
  sta stackaccess
  lda stackbase+6,x
  sta stackaccess+1

.(
outerloop
  lda stackbase+4,x ; MSB of count
  beq lessthanpage  ; if zero, there's less than a page to copy

  lda stackbase+1,x ; the value to copy in
  ldy #$ff
innerloop
  sta (stackaccess),y
  dey
  bne innerloop
  sta (stackaccess),y
  inc stackaccess+1 ; add one to MSB of our base
  dec stackbase+4,x ; count off one page
  bne outerloop     ; until MSB of count is zero
.)

lessthanpage
.(
  lda stackbase+1,x ; we might be coming from before we loaded this
  ldy stackbase+3,x ; remaining count
  beq done
finalloop
  dey
  sta (stackaccess),y
  cpy #0
  bne finalloop
done
.)
  clc               ; pop three cells off the stack
  txa
  adc #6
  tax
  jmp next


;;; Call into the xmodem upload code from the monitor
doupload
  jsr crlf
  jsr XRECV
  jmp next


;;; Temporarily switch input to region at location specified on
;;; the stack.
;;; BUG shouldn't flush input. can we preserve the current buffer
;;; location on the stack and restore it at the end of the load?
docload
  jsr pop16         ; load address from the stack and set it
  lda stackaccess   ; as the memory region from which to read
  sta INBUFF        ; input text.
  lda stackaccess+1
  sta INBUFF+1
  stz TCNT          ; flush pending input
  stz TPTR
  inc SOURCE        ; 0 is terminal, non-zero is memory
  jmp next

donip
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
;  inx
;  inx
;  jmp next
  jmp drop1cell

;;; ( x1 x2 -- x2 x1 x2)
;;;            +5 +3 +1
dotuck
  dex
  dex
  lda stackbase+3,x
  pha
  sta stackbase+1,x
  lda stackbase+4,x
  pha
  sta stackbase+2,x

  lda stackbase+5,x
  sta stackbase+3,x
  lda stackbase+6,x
  sta stackbase+4,x

  pla
  sta stackbase+6,x
  pla
  sta stackbase+5,x
  jmp next

;;; Implement DUMP command by calling dump routine from the monitor.
;;; In Forth, the byte count is on the top of the stack and the base
;;; address underneath; the monitor looks for them the other way around.
;;; So to a swap before calling the routine.
dodump
  jsr crlf
  jsr swap16
  jsr DUMP
  jmp next


;;; implements COUNT -- take a pointer to a counted string on the stack,
;;; and turn it into a pointer to the characters and the count.
docount
  clc
  lda stackbase+1,x ; LSB of counted string address
  sta SCRATCH       ; cache it
  adc #1            ; add one (to get address of characters)
  sta stackbase+1,x ; put back
  lda stackbase+2,x ; now same for MSB
  sta SCRATCH+1
  adc #0
  sta stackbase+2,x
  lda (SCRATCH)     ; load character count from cached address
  sta stackaccess
  stz stackaccess+1
  jsr push16
  jmp next

  

;;;
;;; DOUBLE-LENGTH ARITHMETIC
;;;
;;; These routines are all for double-length (ie, 32-bit
;;; rather then 16-bit) arithmetic, although for the moment,
;;; I'm entirely ignoring issues about signed vs unsigned.
;;;

;;; promote a single-lenth value to a double-legnth value (S>D).
dosgltodbl
.(
  dex               ; add space on the stack
  dex
  lda stackbase+3,x ; copy the single-length cell down
  sta stackbase+1,x
  lda stackbase+4,x
  sta stackbase+2,x

  ;; extend whatever the sign bit is of this word into the
  ;; larger word. so check if it's one or zero
  lda stackbase+4,x
  bit #%10000000
  beq zerobits      ; it's zero
  lda #$ff          ; it's one, so load FF into each byte
  sta stackbase+3,x
  sta stackbase+4,x
  bra end
zerobits
  stz stackbase+3,x ; zero out the upper cell
  stz stackbase+4,x
end
.)
  jmp next

;;; double-length addition
doadd32
  clc
  lda stackbase+1,x ; byte #1
  adc stackbase+5,x
  sta stackbase+5,x ; leaves result in lower area on stack
  lda stackbase+2,x ; byte #2
  adc stackbase+6,x
  sta stackbase+6,x
  lda stackbase+3,x ; byte #3
  adc stackbase+7,x
  sta stackbase+7,x
  lda stackbase+4,x ; byte #4
  adc stackbase+8,x
  sta stackbase+8,x
drop2cells
  inx               ; drop the upper two-cell number
  inx
  inx
  inx
  jmp next          ; done


;;; mixed-length addition. Add a 16-bit wide number on the top of
;;; the stack to a 32-bit wide number below it.
doaddmix
  clc
  lda stackbase+1,x ; byte #1
  adc stackbase+3,x
  sta stackbase+3,x ; leaves result in lower area on stack
  lda stackbase+2,x ; byte #2
  adc stackbase+4,x
  sta stackbase+4,x
  lda stackbase+5,x ; byte #3
  adc #0
  sta stackbase+5,x
  lda stackbase+6,x ; byte #4
  adc #0
  sta stackbase+6,x
;  inx               ; drop the single-length number
;  inx
;  jmp next          ; done
  jmp drop1cell


;;; double-length subtraction
dosub32
  sec                        ; set the carry
  lda stackbase+5,x ; byte #1
  sbc stackbase+1,x
  sta stackbase+5,x ; leaves result in lower area on stack
  lda stackbase+6,x ; byte #2
  sbc stackbase+2,x
  sta stackbase+6,x
  lda stackbase+7,x ; byte #3
  sbc stackbase+3,x
  sta stackbase+7,x
  lda stackbase+8,x ; byte #4
  sbc stackbase+4,x
  sta stackbase+8,x
;  inx               ; drop the upper two-cell number
;  inx
;  inx
;  inx
;  jmp next          ; done
  jmp drop2cells

donegate32
  clc
  lda stackbase+1,x ; add one and flip bits to calculate two's complement
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  eor #$ff
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x
  jmp next


;;; test for equality for 32-bit numbers
doeql32
.(
  lda stackbase+1,x
  cmp stackbase+5,x
  bne notequal
  lda stackbase+2,x
  cmp stackbase+6,x
  bne notequal
  lda stackbase+3,x
  cmp stackbase+7,x
  bne notequal
  lda stackbase+4,x
  cmp stackbase+8,x
  bne notequal
equal
  clc               ; clean up stack before setting result
  txa
  adc #6
  tax
  jmp settrue
notequal
  clc               ; clean up stack before setting result
  txa
  adc #6
  tax
  jmp setfalse
.)


;;; compare a 32-bit number to zero
dozero32
.(
  lda stackbase+1,x ; or all the bytes together
  ora stackbase+2,x
  ora stackbase+3,x
  ora stackbase+4,x
  beq zero          ; zero?
notzero
  inx               ; clean up stack before setting result
  inx
  jmp setfalse
zero
  inx               ; clean up stack before setting result
  inx
  jmp settrue
.)

;;; implements D0<
dolesszero32
.(
  lda stackbase+4,x
  bit #%1000000
  bne yes
  inx
  inx
  jmp setfalse
yes
  inx
  inx
  jmp settrue
.)

;;; implements DABS
doabs32
.(
  lda stackbase+4,x
  bit #%1000000
  beq done
  jmp donegate32
done
  jmp next
.)

;;; implements D<
doless32
.(
  sec
  lda stackbase+5,x
  sbc stackbase+1,x
  lda stackbase+6,x
  sbc stackbase+2,x
  lda stackbase+7,x
  sbc stackbase+3,x
  lda stackbase+8,x
  sbc stackbase+4,x
  bpl no
  clc
  txa
  adc #6
  tax
  jmp settrue
no
  txa
  adc #6
  tax
  jmp setfalse
.)

;;; implements DMIN
dodmin
.(
  sec
  lda stackbase+5,x
  sbc stackbase+1,x
  lda stackbase+6,x
  sbc stackbase+2,x
  lda stackbase+7,x
  sbc stackbase+3,x
  lda stackbase+8,x
  sbc stackbase+4,x
  bpl no
yes
  clc               ; min value is lower on stack, so drop
  txa               ; the upper one
  adc #4
  tax
  jmp next
no
  jsr swap32
  bra yes
.)

;;; implements DMAX
dodmax
.(
  sec
  lda stackbase+5,x
  sbc stackbase+1,x
  lda stackbase+6,x
  sbc stackbase+2,x
  lda stackbase+7,x
  sbc stackbase+3,x
  lda stackbase+8,x
  sbc stackbase+4,x
  bpl no
yes
  jsr swap32        ; swap and proceed with "no"
no
  clc               ; min value is lower on stack, so drop
  txa               ; the upper one
  adc #4
  tax
  jmp next
.)



;;; domultmix -- multiply two 16-bit numbers, giving a 32-bit result
domultmix
  jsr multmixsub
  jmp next

;;; test the signs of two 16-bit operands. After this, each operand
;;; is on the stack in its absolute value, and SCRATCH is either 0
;;; (if the signs were the smae) or 128 if not.
testsigns16
.(
  lda stackbase+2,x
  eor stackbase+4,x
  and #128
  sta SCRATCH       ; scratch is 0 if numbers have same sign, 128 otherwise

  ;; BUG can't the flips and the addition be combined, saving load/saves?

  ;; if n1 is negative, make a note and invert it
  lda stackbase+2,x
  bit #128
  beq checkother
  eor #$ff
  sta stackbase+2,x
  lda stackbase+1,x
  eor #$ff
  clc
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  adc #0
  sta stackbase+2,x

checkother
  lda stackbase+4,x
  bit #128
  beq done
  eor #$ff
  sta stackbase+4,x
  lda stackbase+3,x
  eor #$ff
  clc
  adc #1
  sta stackbase+3,x
  lda stackbase+4,x
  adc #0
  sta stackbase+4,x
done
  rts
.)

;;; as testsigns16, but this time, presume that there is a 16-bit
;;; value on the top of the stack and a 32-bit value below it.
testsignsmix
  lda stackbase+2,x
  eor stackbase+6,x
  and #128
  sta SCRATCH       ; scratch is 0 if numbers have same sign, 128 otherwise

  ;; BUG can't the flips and the addition be combined, saving load/saves?

absmix              ; alternative entry point
.(
  ;; if n1 is negative, make a note and invert it
  lda stackbase+2,x
  bit #128
  beq checkother
  eor #$ff
  sta stackbase+2,x
  lda stackbase+1,x
  eor #$ff
  clc
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  adc #0
  sta stackbase+2,x

checkother
  lda stackbase+6,x
  bit #128
  beq done
  eor #$ff
  sta stackbase+6,x
  lda stackbase+5,x
  eor #$ff
  sta stackbase+5,x
  lda stackbase+4,x
  eor #$ff
  sta stackbase+4,x
  lda stackbase+3,x
  eor #$ff
  clc
  adc #1
  sta stackbase+3,x
  lda stackbase+4,x
  adc #0
  sta stackbase+4,x
  lda stackbase+5,x
  adc #0
  sta stackbase+5,x
  lda stackbase+6,x
  adc #0
  sta stackbase+6,x
done
  rts
.)

;;; Fix up the signs after a signed arithmetic operation if
;;; the flag in SCRATCH signals that it's needed.
fixsigns16
.(
  lda SCRATCH
  beq done
  jmp flipsign16
done
  rts
.)

flipsign16          ; broken out so it can be called separately
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  rts


;;; Fix up the signs after a signed arithmetic operation if
;;; the flag in SCRATCH signals that it's needed.
fixsigns32
.(
  lda SCRATCH
  beq done
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  eor #$ff
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x
done
  rts
.)

multmixsub
  jsr testsigns16
  jsr umstarsub
  jsr fixsigns32
  rts

doumstar
  jsr umstarsub
  jmp next

;;; This version of UM* is based on one contributed by Dr Jeffyll
;;; to the 6502.org forum. See the thread at
;;; forum.6502.org/viewtopic.php?f=9&t=689
;;; The same code is also the basis of the UM* routine in Tali Forth.
umstarsub
  CLC 
  LDA 3,X    ;Copy TOS value to N+2,N+3. To eliminate CLC inside the loop, the
  SBC #0
  STA SCRATCH+3    ;special accommodation is mandatory for the case of TOS = 0.
  LDA 4,X
  SBC #0
  BCC UST_Z  ;TOS = 0? Mandatory special treatment for this
  STA SCRATCH+4
  LDA #0
  STA SCRATCH+1      ;16 bits of zero in A, N
  STX SCRATCH+5    ;tested later for exit from outer loop
  DEX        ;bias applied to X
  DEX
UST_OUTLP
  LDY #8     ;count for inner loop
  LSR 3,X    ;think "2,x" then later "3,X"
UST_INLP
  BCC UST_NOADD
  STA SCRATCH+2    ;Save time, don't CLC. Value in N+2,N+3 is reduced by 1 to allow this
  LDA SCRATCH+1
  ADC SCRATCH+3
  STA SCRATCH+1
  LDA SCRATCH+2
  ADC SCRATCH+4
UST_NOADD
  ROR
  ROR SCRATCH+1
  ROR 3,X    ;think "2,x" then later "3,X"
  DEY
  BNE UST_INLP  ;go back for 1 more shift?
  INX
  CPX SCRATCH+5
  BNE UST_OUTLP ;go back for 8 more shifts?
  STA 4,X       ;ms byte of hi-word of result
  LDA SCRATCH+1
  STA 3,X       ;ls byte of hi-word of result
UST_EXIT
  RTS
UST_Z
  STZ 1,X
  STZ 2,X
  BCC UST_EXIT


dosmdivrem
  jsr smdivmodsub
  jmp next

smdivmodsub
.(
  ;; unfortunately, signs are weird here, so I have to do this
  ;; by hand here rather than using the usual routines.
  lda stackbase+2,x ; check divisor MSB
  lsr               ; moves sign bit into bit 6
  and #64           ; mask off other bits
  sta SCRATCH       ; stash it
  lda stackbase+6,x ; check dividend MSB
  and #128          ; grab sign bit
  ora SCRATCH       ; combine it with other bit
  sta SCRATCH       ; SCRATCH is 0 when both are positive
  jsr absmix        ; invert both if needed

  jsr umdivmodsub

  ;; now fix up the signs

  lda SCRATCH       ; short circuit fixsigns if nothing to be done
  beq done

  ;; if the dividend is negative, then flip the remainder
  bit SCRATCH
  bpl testmixed
  inx
  inx
  jsr flipsign16
  dex
  dex

testmixed
  ;; if mixed signs (ie, not 0 and not not 192), flip the quotient
  ;; we've already tested for 0
  lda SCRATCH
  cmp #192
  beq done    

  ;; flip the quotient
  jsr flipsign16

done
  rts
.)

;;; Mixed-length division. Divide a 32-bit number by a 16-bit number,
;;; giving a 16-bit result. This is used as part of */.
;;; on entry, the 16-bit divisor is on the top of the stack (ie
;;; at stackbase+1 and +2), and the 32-bit divisand is lower (ie
;;; at stackbase+3 through +6)
divmixsub
  jsr smdivmodsub
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  inx
  inx
  rts

olddivmixsub
.(
  phy               ; preserve Y

  ;; handle negative numbers. we convert everything to positive and
  ;; keep a note of whether we need to negate the result. this is
  ;; kinda a crappy way to do this but will get me through for now.
  ;; BUG BETTER NEGATIVE DIVISION
  stz SCRATCH

  lda stackbase+6,x ; test top bit of divisand
  bit #%10000000
  beq testdivisor
  eor #$ff          ; negative, so negate it
  sta stackbase+6,x
  
  clc               ; flip bits and add one to generate two's complement
  lda stackbase+3,x
  eor #$ff
  adc #1
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x
  lda stackbase+5,x
  eor #$ff
  adc #0
  sta stackbase+5,x
  lda stackbase+6,x
  adc #0            ; already EOR'd this byte up top
  sta stackbase+6,x
  inc SCRATCH

testdivisor
  lda stackbase+2,x ; now do the same to the divisor
  bit #%10000000
  beq continue      ; not negative
  eor #$ff          ; flip bits and add one to generate two's complement
  sta stackbase+2,x
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  adc #0
  sta stackbase+2,x
  inc SCRATCH

continue
  ;; make some working space on the stack. two 16-bit values needed.
  dex
  dex
  dex
  dex

  ;; zero out those spaces
  stz stackbase+1,x ; stackbase+1 and +2 are remainlsb, remainmsb
  stz stackbase+2,x
  stz stackbase+3,x ; stackbase+3 and +4 are resultlsb, resultmsb
  stz stackbase+4,x

  ; divisor (n1) is now stackbase+5 and +6
  ; divisand (n2) is npw stackbase+7 through +10

  ldy #$20          ; loop count, going 32 times (one per divisand bit)
nextbit
  ; shift n2 (divisand) left, rotating top bit into temp
  asl stackbase+7,x
  rol stackbase+8,x
  rol stackbase+9,x
  rol stackbase+10,x
  rol stackbase+1,x
  rol stackbase+2,x
  ; is temp larger than/equal to n1?
  lda stackbase+2,x       ; msb first -- does that resolve it?
  cmp stackbase+6,x
  bcc shift0
  bne subtract
  lda stackbase+1,x
  cmp stackbase+5,x
  bcs subtract
  bra shift0
  ; yes so subtract divisor from temp
subtract
  sec
  lda stackbase+1,x
  sbc stackbase+5,x
  sta stackbase+1,x
  lda stackbase+2,x
  sbc stackbase+6,x
  sta stackbase+2,x
  ; shift and test
shift1
  ; shift result one place left, shifting in a 1 at the bottom
  sec
  rol stackbase+3,x
  rol stackbase+4,x
  bra test
shift0
  ; shift result one place left, shifting in a 1 at the bottom
  clc
  rol stackbase+3,x
  rol stackbase+4,x
test
  ; test-- are we done (all 32 bits)?
  dey
  bne nextbit
  ;; we are now done.
  ;; remainder is in stackbase+1 and +2; quotient is in stackbase+3 and +4
enddiv
.)

  lda stackbase+3,x ; put result in right place
  sta stackbase+9,x
  lda stackbase+4,x
  sta stackbase+10,x
  clc               ; clean up the stack
  txa
  adc #8
  tax

  ;; if the lowest bit of SCRATCH is set, then negate the result
  lda SCRATCH
  bit #1
  beq donemixdiv
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
donemixdiv
  ply               ; restore y
  rts

doumdivmod
  jsr umdivmodsub
  jmp next

;;; This implementation of UM/MOD is from Garth Wilson on 6502.org.
umdivmodsub
.(
  SEC             ; Detect overflow or /0 condition.
  LDA 5,X         ; Divisor must be more than high cell of dividend.  To
  SBC 1,X         ; find out, subtract divisor from high cell of dividend;
  LDA 6,X         ; if carry flag is still set at the end, the divisor was
  SBC 2,X         ; not big enough to avoid overflow. This also takes care
  BCS overflow    ; of any /0 condition.  Branch if overflow or /0 error.
                  ; We will loop 16 times; but since we shift the dividend
  LDY     #$11    ; over at the same time as shifting the answer in, the
                  ; operation must start AND finish with a shift of the
                  ; low cell of the dividend (which ends up holding the
                  ; quotient), so we start with 17 (11H) in X.
loop
  ROL 3,X         ; Move low cell of dividend left one bit, also shifting
  ROL 4,X         ; answer in. The 1st rotation brings in a 0, which later
                  ; gets pushed off the other end in the last rotation.
  DEY
  BEQ done        ; Branch to the end if finished.

  ROL 5,X         ; Shift high cell of dividend left one bit, also
  ROL 6,X         ; shifting next bit in from high bit of low cell.
  STZ SCRATCH+1   ; Zero old bits of CARRY so subtraction works right.
  ROL SCRATCH+1   ; Store old high bit of dividend in CARRY.  (For STZ
                  ; one line up, NMOS 6502 will need LDA #0, STA CARRY.)
  SEC             ; See if divisor will fit into high 17 bits of dividend
  LDA 5,X         ; by subtracting and then looking at carry flag.
  SBC 1,X         ; First do low byte.
  STA SCRATCH+2   ; Save difference low byte until we know if we need it.
  LDA 6,X
  SBC 2,X         ; Then do high byte.
  STA SCRATCH+3   ; Save difference high byte until we know if we need it.
  LDA SCRATCH+1   ; Bit 0 of CARRY serves as 17th bit.
  SBC #0          ; Complete the subtraction by doing the 17th bit before
  BCC loop        ; determining if the divisor fit into the high 17 bits
                  ; of the dividend.  If so, the carry flag remains set.
  LDA SCRATCH+2   ; If divisor fit into dividend high 17 bits, update
  STA 5,X         ; dividend high cell to what it would be after
  LDA SCRATCH+3
  STA 6,X         ; subtraction
  BRA     loop    ; Always branch.

overflow
  LDA #$FF        ; If overflow occurred, put FF
  STA 5,X         ; in remainder low byte
  STA 6,X         ; and high byte,
  STA 3,X         ; and in quotient low byte
  STA 4,X         ; and high byte.

done
  INX
  INX
  RTS
.)



dostardiv
  jsr pop16         ; temporarily move divisor out of the way
  lda stackaccess
  pha
  lda stackaccess+1
  pha
  jsr multmixsub    ; do the multiplication
  dex
  dex
  pla               ; put the divisor back
  sta stackbase+2,x
  pla
  sta stackbase+1,x
  ;jsr push16
  jsr divmixsub     ; do the division
  jmp next


;;; BUG there is an awful lot of code shared between rprint32
;;; and print32. Can all the setup stuff be broken out?
rprint32s
  ;; Initialize the PADPTR. We will assemble the string on the
  ;; pad. Leave one space for a count.
  lda #<PAD
  inc               ; space for the count
  sta PADPTR
  lda #>PAD         ; no carry; presume no page boundary
  sta PADPTR+1

.(
  ;; next, check the most significant bit of the number
  ;; to see if it's negative
  lda stackbase+4,x
  bit #%10000000
  beq nominus

  lda #$2d          ; minus sign
  sta (PADPTR)      ; add it to the string we're assembling
  inc PADPTR

  ;; now calculate the two's complement of the number we have.
  ;; flip all the bits and add one.
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  eor #$ff
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x

nominus
.)
  jsr assemble32    ; assemble the 32-bit number on the pad
  jsr pop16         ; pull the field width (presume < 256)
  phy
  sec
.(
  lda stackaccess   ; load field width
  sbc PAD           ; subtract the the string length
  bmi printnum      ; skip spaces if number longer than field
  tay
  lda #$20
  cpy #0
  beq printnum
space
  jsr puta
  dey
  bne space
printnum
.)
  jsr prpadnum
  ply               ; restore Y
  rts



;;; Print a 32-bit decimal number. This is kinda awful. The technique
;;; I used for 16-bits was messy enough, but this is messier now that
;;; I've extended it. (Updated to handle negative numbers.)
print32s
  ;; Initialize the PADPTR. We will assemble the string on the
  ;; pad. Leave one space for a count.
  lda #<PAD
  inc               ; space for the count
  sta PADPTR
  lda #>PAD         ; no carry; presume no page boundary
  sta PADPTR+1

.(
  ;; next, check the most significant bit of the number
  ;; to see if it's negative
  lda stackbase+4,x
  bit #%10000000
  beq nominus

  lda #$2d          ; minus sign
  sta (PADPTR)      ; add it to the string we're assembling
  inc PADPTR

  ;; now calculate the two's complement of the number we have.
  ;; flip all the bits and add one.
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  eor #$ff
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x

nominus
  jsr assemble32
  lda #$20
  jsr puta
  jsr prpadnum
.)
  rts

;;; unsigned version
print32u
  lda #<PAD
  inc               ; space for the count
  sta PADPTR
  lda #>PAD         ; no carry; presume no page boundary
  sta PADPTR+1
  jsr assemble32
  lda #$20
  jsr puta
  jsr prpadnum
  rts



assemble32
.(
  lda BASE
  cmp #16
  bne continue
  jmp hassemble32
continue
.)
  ;; Open five bytes of storage on the stack. These will be
  ;; ten nybbles each holding a single binary-coded decimal
  ;; digit (since 32 bytes stores a max of a ten-digit decimal).
  dex
  dex
  dex
  dex
  dex
  
  ;; that leaves the data to be read at stackbase+6,x through
  ;; stackbase+9,x
  
  stz stackbase+1,x ; dec0
  stz stackbase+2,x ; dec1
  stz stackbase+3,x ; dec2
  stz stackbase+4,x ; dec3
  stz stackbase+5,x ; dec4

  phy               ; preserve Y
  lda #0
  sed
  ldy #32           ; count of bits we are processing

.(
loop
  asl stackbase+6,x ; roll bits out of the data values
  rol stackbase+7,x ; and into the carry, one by one
  rol stackbase+8,x
  rol stackbase+9,x
  lda stackbase+1,x ; and then use carry to add into the
  adc stackbase+1,x ; decimal space
  sta stackbase+1,x
  lda stackbase+2,x
  adc stackbase+2,x
  sta stackbase+2,x
  lda stackbase+3,x
  adc stackbase+3,x
  sta stackbase+3,x
  lda stackbase+4,x
  adc stackbase+4,x
  sta stackbase+4,x
  lda stackbase+5,x
  adc stackbase+5,x
  sta stackbase+5,x
  dey
  bne loop
.)
  cld
  ;; we have the result in the temporary storage, as BCD. now print
  ;; that as a ten-character string. do this as five loops of
  ;; an upper and lower nybble.

  ;; set a flag to determine whether we've printed anything non-zero
  stz SCRATCH

  txa
  adc #<stackbase
  sta SCRATCH+2
  lda #>stackbase
  sta SCRATCH+3
  ldy #5

.(
nextbcd             ; go through this loop for each BCD digit
  ;; first, upper four bytes
  lda (SCRATCH+2),y
  and #%11110000
  bne prupper       ; non-zero
  cmp SCRATCH       ; if it's zero, check if we're printing zeros
  beq lower         ; if we're not, then skip this one
prupper
  clc               ; shift the top four bits down to the bottom
  ror
  ror
  ror
  ror
  clc
  adc #'0
;  jsr puta
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

lower
  ;; next, lower four bytes
  lda (SCRATCH+2),y
  and #%00001111
  bne prlower       ; non-zero
  cmp SCRATCH       ; if it's zero, check if we're printing zeros
  beq skip          ; if we're not, then skip this one
prlower
  clc
  adc #'0
;  jsr puta
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

skip
  dey
  bne nextbcd
.)

.(
  ;; check -- if we never printed anything, output a zero
  lda SCRATCH
  bne finalize
  lda #$30          ; add a zero
  ;jsr puta
  sta (PADPTR)
  inc PADPTR

finalize
  sec
  lda PADPTR        ; calculate string length
  sbc #<PAD
  dec
  sta PAD           ; update string count
  ply               ; restore Y

  clc               ; clear bytes off the stack (five for
  txa               ; working space and four for 32-bit number).
  adc #9
  tax
.)
  rts




;;;
;;; DOUBLE CELL STACK ROUTINES
;;;

do2dup
  dex
  dex
  dex
  dex
  lda stackbase+5,x
  sta stackbase+1,x
  lda stackbase+6,x
  sta stackbase+2,x
  lda stackbase+7,x
  sta stackbase+3,x
  lda stackbase+8,x
  sta stackbase+4,x
  jmp next

do2drop
;  inx
;  inx
;  inx
;  inx
;  jmp next
  jmp drop2cells

do2over
  dex
  dex
  dex
  dex
  lda stackbase+9,x
  sta stackbase+1,x
  lda stackbase+10,x
  sta stackbase+2,x
  lda stackbase+11,x
  sta stackbase+3,x
  lda stackbase+12,x
  sta stackbase+4,x
  jmp next

do2swap
  jsr swap32
  jmp next

;;; this routine is broken out because we use it in some other
;;; places too
swap32
  lda stackbase+1,x ; cache two cells from top of stack
  pha               ; on the processor's hardware stack
  lda stackbase+2,x
  pha
  lda stackbase+3,x
  pha
  lda stackbase+4,x
  pha

  lda stackbase+5,x ; copy two lower cells into the two cells
  sta stackbase+1,x ; on the top of the stack
  lda stackbase+6,x
  sta stackbase+2,x
  lda stackbase+7,x
  sta stackbase+3,x
  lda stackbase+8,x
  sta stackbase+4,x

  pla               ; restore the cached values and place them
  sta stackbase+8,x ; in the two lower cells
  pla
  sta stackbase+7,x
  pla
  sta stackbase+6,x
  pla
  sta stackbase+5,x

  rts


;;; BUG not at all sure about this yet... in particular, it might
;;; work from the interpreter but entirely fail inside a defined
;;; word
doexecute
  lda stackbase+1,x ; reset XT (W) to the address signalled on the stack
  sta XT
  lda stackbase+2,x
  sta XT+1
  inx
  inx
  jmp XT-1
;  ldy #1
;  lda (XT),y        ; XT contains a pointer to a code word. Load
;  sta CODEVEC+1     ; the code address stored there into CODEVEC.
;  lda (XT)
;  sta CODEVEC

;  jmp (CODEVEC)     ; execute the code for this instruction/word

dounused
  jsr unusedsub
  jmp next

unusedsub
  dex
  dex
  sec
  lda #<IOSPACE
  sbc DP
  sta stackbase+1,x
  lda #>IOSPACE
  sbc DP+1
  sta stackbase+2,x
  rts

dohex
  lda #16
  sta BASE
  jmp next

dodecimal
  lda #10
  sta BASE
  jmp next

dobase
  lda #<BASE
  sta stackaccess
  lda #>BASE
  sta stackaccess+1
  jsr push16
  jmp next

dochar
  jsr readnext
  ldy #1
  lda WORD,y
  dex
  dex
  sta stackbase+1,x
  stz stackbase+2,x
  jmp next  
  
dobrchar
  jsr readnext
  ldy #0
  lda #<dolitcode
  sta (DP),y
  iny
  lda #>dolitcode
  sta (DP),y
  lda WORD,y        ; Y is currently 1
  iny
  sta (DP),y
  iny
  lda #0
  sta (DP),y

.(
  clc
  lda DP
  adc #4
  sta DP
  bcc skip
  inc DP+1
skip
.)
  jmp next

;;; dodoes is the compile-time behaviour for DOES>. This is an immediate
;;; word, so this code runs when a word using DOES> is being compiled.
;;; It compiles in the run-time code (DOES) and a copy of the current
;;; next compilation address (which will shortly contain the start of
;;; the code that was compiled after "DOES>".
dodoes
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  ldy #0
  lda #<dodoesrtcode  ; first, compile in the code address
  sta (DP),y
  iny
  lda #>dodoesrtcode
  sta (DP),y
  iny

  clc                 ; and the parameter address is DP
  lda DP              ; plus two cells
  adc #4              ; ie four bytes
  sta (DP),y
  iny
  lda DP+1
  adc #0
  sta (DP),y
  iny

  tya
  clc
  adc DP
  sta DP
  bcc skip
  inc DP+1
skip
  jmp next

nocompile
  jmp abortcompile
.)


;;; dodoesrt is the run-time behaviour for (DOES), which is
;;; compiled by DOES>. This runs when the defining word, which
;;; creates a word whose behavior is defined using DOES> runs.
;;; it resets the XT of the most recent word, and then takes
;;; the  parameter that DOES> compiled in, and recodes
;;; the most recent word to begin execution there (by compiling
;;; it into the start of the parameter space).
dodoesrt
  ;; find the code field address of the most recently defined
  ;; word (designated by DT). I think I do this often enough that
  ;; perhaps it should be a subroutine?
  lda DT
  sta DPTR
  lda DT+1
  sta DPTR+1
.(
  clc
  lda DPTR
  adc (DPTR)        ; add the word length
  inc               ; plus one byte for the length count
  inc               ; and two more for the link
  inc
  sta DPTR
  bcc skip
  inc DPTR+1
skip
.)

  ;; we are going to set that address to the code for dodoes, which
  ;; will necessitate moving any already-allocated storage. however,
  ;; we don't need to do that if XT is already set to dododoes. so,
  ;; first check and then jump to either setit or alreadyset.
  ldy #1
  lda (DPTR)  
  cmp #<dododoes
  bne setit
  lda (DPTR),y
  cmp #>dododoes
  beq alreadyset  

setit
  ;; not yet set to dododoes, so set and do the copy
  lda #<dododoes
  sta (DPTR)
  lda #>dododoes
  sta (DPTR),y      ; y is still 1 here

  ;; we need to copy all the allocated space ahead by two bytes.
  ;; calculate the parameters for the copy.
  clc               ; first, the base address for copy, 
  lda DPTR          ; which is the parameter space
  adc #2
  sta SCRATCH
  lda DPTR+1
  adc #0
  sta SCRATCH+1

  clc               ; second, the destination for copy, which
  lda SCRATCH       ; is source address plus two
  adc #2
  sta SCRATCH+2
  lda SCRATCH+1
  adc #0
  sta SCRATCH+3

  sec               ; third, number of bytes to copy, which is
  lda DP            ; found via DP
  sbc SCRATCH
  sta SCRATCH+4
  lda DP+1
  sbc SCRATCH+1
  sta SCRATCH+5

  jsr movedownsub   ; copy in a downward direction (ie going high to low)

alreadyset
  ;; compile in the parameter that we stored before. this should go
  ;; into the first parameter space, ie right after that code address
  ldy #0
  lda (IP)
  ldy #2
  sta (DPTR),y
  ldy #1
  lda (IP),y
  ldy #3
  sta (DPTR),y

.(
  ;; bump the IP since we've just consumed a value
  clc
  lda IP
  adc #2
  sta IP
  bcc skip
  inc IP+1
skip
.)

  ;; increment DP by two to account for the extra cell of storage
  ;; that we just used at the start
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skip
  inc DP+1
skip
.)

  ;; we don't execute the rest of the word, because it's actually
  ;; just compiled code to be executed later. Jump straight to exit.
  jmp exit
  

;;; dododoes is the run-time behaviour inserted by (DOES) and
;;; used to execute words constructed using DOES>. dododoes is rather
;;; like dolist; we will return from it using EXIT, so we need to 
;;; set up the return stack appropriately. unlike dolist, it takes
;;; a parameter and starts execution there (which is the compiled
;;; code from the word in which DOES> was originally used).
dododoes
  ;; first, push the current instruction pointer onto the
  ;; return stack (subroutine unrolled)
  lda IP+1
  sta (RP)
  dec RP
  lda IP
  sta (RP)
  dec RP

  ;; next, push the address of the storage area on the stack
  ;; that's not the usual parameter space, but one value after that
  ;; since the first slot in the parameter space is being used for
  ;; the instruction pointer (two cells so four bytes)
  dex
  dex
  clc
  lda XT
  adc #4
  sta stackbase+1,x
  lda XT+1
  adc #0
  sta stackbase+2,x

  ;; now reset IP from the parameter stored here
  ldy #2
  lda (XT),y
  pha
  iny
  lda (XT),y
  sta IP+1
  pla
  sta IP

  jmp next




;;;
;;; *** TEXT INTERPRETER
;;;
;;; For the moment, this is a basically a stopgap. The real FORTH
;;; text interpreter has many individual components that manifest
;;; themselves as words in the dictionary, and we'll get there.
;;; (The fact that the text interpreter is called QUIT in true Forth
;;; is the ultimate testement to Chuck Moore's twisted nature.)
;;; This is just something to get us going. Again, much borrowed here
;;; from the code of the monitor.
;;;

;;; This is the warm start address, which does some more setup.
;;; This updates the highly fluid variables; in fact, this warm-
;;; start routine is also called by ABORT to reset stacks and
;;; initiate interpreter interaction.
warmstart
  ;; turn off the compiler
  lda STATUS
  and #%11111110
  sta STATUS

  lda #$FF
  sta RP            ; reset return stack
  tax               ; reset user stack
  stz TCNT          ; reset text buffer
  stz TPTR
  stz SOURCE        ; return control to terminal

  ;; no jump... we call straight through to interploop below.

;;; This is the main loop of the interpreter -- which also includes
;;; hooks to the compiler, because in Forth those are deeply
;;; conjoined.
;;;
interploop

  ;; get the next input word into WORD, potentially refilling
  ;; the text buffer in the process
  jsr readnext

  ;; search for a match in the dictionary
  jsr dictmatch
  lda DPTR+1        ; no words on zero page, so this indicates failure
  beq nomatch

  ;; we found a match for a word to execute. Set up the context
  ;; and call NEXT to get started.
gotmatch
  ;; DPTR currently indicates the matching dictionary entry.
  ;; update it so that it points to the code word.
  ldy #1
.(
  clc
  lda (DPTR)        ; load the word length
  sta SCRATCH       ; save a copy
  and #%00011111    ; mask off tag bits
  adc #3            ; one byte for length, two more for link word
  adc DPTR          ; add to address and store in dummy word entry
  sta DPTR
  bcc done
  inc DPTR+1
done
.)

  ;; next, check if we're compiling. if we are not, then we can continue
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; now check if the word is immediate... because if it is, we should
  ;; go ahead and execute it, even if we're compiling
  lda SCRATCH
  bit #IMM
  bne nocompile

  ;; compile this into the currently-compiling word. that means we
  ;; should add the address of the code word into the location
  ;; pointed to by DP and increment DP.
  ;; DPTR stores the start of the entry for the word to execute.
  ;; So its code word is at (DPTR) + wordlength + 1 (len) + 2 (link)
  ldy #1
  lda DPTR
  sta (DP)
  lda DPTR+1
  sta (DP),y

  ;; increment DP by 2
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; proceed with the interpreter loop
  jmp interploop

nocompile
  lda DPTR          ; add to address and store in dummy word entry
  sta dummyparam
  lda DPTR+1
  sta dummyparam+1

execdummy
  ;; put the dummy parameter address into IP.
  lda #<dummyparam
  sta IP
  lda #>dummyparam
  sta IP+1

  ;; jump to NEXT to start running it
  jmp next


  ;; we didn't find a match in the dictionary, so see if we can parse
  ;; it as a number.
nomatch

  ;; attempt to convert word to number and put it on the stack
  ;; my routines for this us a null-terminated string, so add a null
  ldy WORD
  iny
  lda #0
  sta WORD,y        ; add a null
  lda #<WORD        ; put address on the stack threshold
  sta stackaccess
  lda #>WORD
  sta stackaccess+1
.(
  inc stackaccess   ; bump it by one to avoid the count
  bne done
  inc stackaccess+1
done
.)
  jsr push16
  jsr readsign      ; read a signed number
  bcs nointerpret   ; carry signals failure to read a number


  ;; if we are compiling, we need to take it off the stack again
  ;; and compile it into the word.
  lda STATUS
  bit #COMPILE
  beq normal

  ;; we are compiling. so we need to add this to the current
  ;; word as a literal. that means adding the code for DOLIT
  ;; and then the number.
  jsr pop16
  ldy #0
  lda #<dolitcode
  sta (DP),y
  iny
  lda #>dolitcode
  sta (DP),y
  iny
  lda stackaccess
  sta (DP),y
  iny
  lda stackaccess+1
  sta (DP),y
  iny

  ;; add Y to DP
  clc
  tya
  adc DP
  sta DP
  lda DP+1
  adc #0
  sta DP+1

normal
  jmp interploop
  
  ;; if we get here, we couldn't find a match, nor could we read it as
  ;; a number. there's no interpretation, so issue an error, flush
  ;; the input, and loop
nointerpret  

  ;; turn off the compiler, if we were compiling
  stz STATUS

  ;; print an error, in three stages. first, a space; then, the
  ;; undefined word; finally, the error message.

  lda #$20
  jsr puta
  jsr printword
  jmp abortnotdef

;;; print the word in WORD
printword
  ldy #1
.(
next_char
  lda WORD,y
  jsr puta
  iny
  cpy WORD
  bcc next_char
  beq next_char
.)

  rts

;;; dictmatch looks up a word in the dictionary. The word being
;;; matched is indicated by WORD, which holds a pointer to a
;;; counted string. On exist, DPTR either points to the entry
;;; for the word, or 0000 in case of no match.
dictmatch
  ;; set up search by initializing dictionary pointer
  lda DT
  sta DPTR
  lda DT+1
  sta DPTR+1

nextentry
  ;; have we run out of dictionary entries? (when DPTR is $0000)
  lda DPTR
  bne compareentry
  lda DPTR+1
  beq return

compareentry
  ;; compare words. counted strings can be compared directly;
  ;; byte by byte will compare counts first. But we need to
  ;; mask out the tags in the count.

  ldy #0
  lda (DPTR),y
  and #%00011111    ; mask off the tags
  cmp WORD,y        ; compare word lengths
  bne trynext       ; no match

  ;; now compare words. do this from the end (for easier testing)
  ldy WORD
.(
nextchar
  lda (DPTR),y
  cmp WORD,y
  bne trynext
  dey
  bne nextchar
.)
  ;; successful match!
  bra return
  
  ;; loop to next entry
trynext
  lda (DPTR)        ; get word length...
  and #%00011111    ; mask off the tags
  tay               ; store in Y, and add one...
  iny               ; for the pointer to the next entry
  lda (DPTR),y      ; update DPTR to point to next entry
  sta SCRATCH
  iny
  lda (DPTR),y  
  sta DPTR+1
  lda SCRATCH
  sta DPTR
  bra nextentry
return
  rts


;;; readnext
;;; read the next word into the area at WORD, potentially refilling
;;; the entire buffer in the process. this is a subroutine so that
;;; I can also use it in several other places.
readnext
  ;; if no more input, ->nomoreinput

  lda TPTR          ; current pointer
  cmp TCNT          ; is that as much text as was read?
  beq nomoreinput   ; if yes, print prompt and get more

  tay               ; put TPTR into Y
interpword
  ;; begin loop

.(
  ;; look for next word
  lda INPUT,y
  cmp #$20          ; space
  beq nextchar
  cmp #$09          ; tab
  beq nextchar
  bne readword      ; not white space, so go and read a word

  ;; continue skipping past space
nextchar
  iny
  cpy TCNT
  beq nomoreinput
  bra interpword
.)

  ;; no more input -- we have exhausted the text buffer. refill.
nomoreinput
.(
  lda SOURCE        ; where are we reading from?
  beq terminal      ; terminal
  jsr readbufline   ; buffer
  bra finishedread
terminal
  ;; are we compiling?
  lda STATUS
  beq usualprompt   ; not compiling so say "OK" as usual
  jsr cprompt       ; different prompt to say we're still compiling
  bra refill
usualprompt
  jsr okcrlf        ; signal completion
refill
  jsr readtermline  ; read another line of text
finishedread
  stz TPTR          ; reset the pointer
  bra readnext      ; loop around
.)

  ;; we have detected the start of a non-space sequence. read a word
  ;; into a counted string at WORD.
readword
.(
  stz WORD
  phx
  ldx #1            ; X starts at 1 because 0 is the count
nextchar
  lda INPUT,y
  beq doneword      ; done if we hit NULL
  cmp #$20
  beq doneword      ; done if we hit space
  cmp #$09
  beq doneword      ; done if we hit tab
  sta WORD,x        ; X starts at 1 because 0 is the count
  stx WORD
  iny
  cpy TCNT          ; run off the end of the buffer?
  beq doneword
  inx
  bra nextchar
doneword
  plx
  sty TPTR          ; update the pointer (and free up Y)
.)
  rts



;;; Read a new line into the INPUT buffer. This reads from the
;;; terminal; readbufline will read from a buffer.
readtermline
  ldy #0
  stz TCNT          ; reset the counter
readone
  jsr readchar
  cmp #$08           ; check for backspace
  beq backspace
  cmp #$0D           ; check for newline (carriage return)
  beq doneline
  cmp #$0A           ; also allow line feed to terminate line
  beq doneline
  sta INPUT,y        ; track the input
  iny
  jsr puta           ; echo the typed character
  jmp readone        ; loop to repeat
backspace
  cpy #0             ; beginning of line?
  beq readone
  dey                ; if not, go back one character
  jsr puta           ; move cursor back
  lda #$20           ; output a space
  jsr puta
  lda #$08           ; and then another backspace
  jsr puta
  jmp readone

  ;; this is where we land if the line input has finished
  ;;
doneline
  lda #0
  sta INPUT,y       ; add a null terminator
  sty TCNT          ; update character count
  rts


readchar
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA
  rts

;;; Read a new line into the INPUT buffer, taking our input from
;;; an area of memory. This is a bit of a hack, but allows other
;;; code to process the input buffer with no knowledge of where
;;; the text comes from. When the buffer is exhausted (signaled
;;; by reading either a nul or the XMODEM buffer data, switch
;;; back to terminal input.
readbufline
.(
  ldy #0
  stz TCNT
readloop
  lda (INBUFF),y
  beq endofbuffer   ; null indicates end of the buffer
  cmp #$1A          ; XMODEM padding character too
  beq endofbuffer
  cmp #$0A
  beq endofline
  cmp #$0D
  beq endofline
  sta INPUT,y
  iny
  bra readloop
endofbuffer
  stz SOURCE        ; set SOURCE back to 0 (ie, read from terminal)
  ; continue to end of line
endofline
  lda #0
  sta INPUT,y
  sty TCNT
  iny               ; move past the end of line character
  tya               ; and update the buffer pointer
  clc
  adc INBUFF
  sta INBUFF
  lda INBUFF+1
  adc #0
  sta INBUFF+1
  rts  
.)


;;; Implements ABORT. On error, resets and returns to interpreter.
;;; BUG doesn't reset DP if we were in the process of compiling, so
;;; leave a mess in the user space.
;;; warm-start routine.
abort
  jsr crlf          ; print newline
  jmp warmstart     ; reset variables and return to interpreter loop


;;; ABORT with a message about nesting
abortnest
  lda #<nestingmsg
  sta PRINTVEC
  lda #>nestingmsg
  sta PRINTVEC+1
  jsr printvecstr
  jmp abort

;;; ABORT with a message about nesting
abortcompile
  lda #<compileerr
  sta PRINTVEC
  lda #>compileerr
  sta PRINTVEC+1
  jsr printvecstr
  jmp abort
  
;;; ABORT with a message about an undefined word
abortnotdef
  lda #<notdefinedmsg
  sta PRINTVEC
  lda #>notdefinedmsg
  sta PRINTVEC+1
  jsr printvecstr
  jmp abort


;;; LIST prints a disk block to the screen
dolistword
.(
  jsr blocksub
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1
  stz SCRATCH+2
  inx               ; clean up stack
  inx

  jsr crlf

startrow
  ldy #0
nextchar
  lda (SCRATCH),y
  bne print
  jsr crlf
  bra nextline
print
  jsr puta
  cmp #$0a
  bne nocr
  lda #$0d
  jsr puta
  bra nextline
nocr
  iny
  cpy #64
  bne nextchar
nextline
  clc
  lda SCRATCH
  adc #64
  sta SCRATCH
  bcc doneadd
  inc SCRATCH+1  
doneadd
  inc SCRATCH+2
  lda SCRATCH+2
  cmp #16
  bne startrow
.)
  jmp next

;;; load input from a disk block
doload
  jsr blocksub      ; find/load the block, leave address on stack
  jmp docload       ; do regular character load with address

douse
  dex
  dex
  lda USE
  sta stackbase+1,x
  lda USE+1
  sta stackbase+2,x
  jmp next

dospat
  dex
  dex
  txa
  sta stackbase+1,x
  stz stackbase+2,x
  jmp next

dosemics
  stz SOURCE
  stz TPTR
  jmp next

;doconvert
;  jsr buffersub
;  lda stackbase+1,x
;  sta TEXTBASE
;  lda stackbase+2,x
;  sta TEXTBASE+1
;  jsr nulltospace
;  jmp next


;;; implements MOVE
;;; ( srcaddr destaddr u )
;;; if dest > src, then high-to-low, otherwise copy low-to-high.
;;; this should avoid conflicts in case of overlapping segments.
domove
  jsr movesetup

  sec
  lda stackbase+3,x
  sbc stackbase+5,x
  lda stackbase+4,x
  sbc stackbase+6,x
  bvc there
  eor #$80          ; what is this FOR? to do with BPL somehow...
there
  bpl here
  ; dest < src
  jsr moveupsub
  jmp next
here
  ; dest > src
  jsr movedownsub
  jmp next


domoveup
  jsr movesetup
  jsr moveupsub
  clc               ; clean up the stack
  txa
  adc #6
  tax
  jmp next

domovedown
  jsr movesetup
  jsr movedownsub
  clc               ; clean up the stack
  txa
  adc #6
  tax
  jmp next

movesetup
  lda stackbase+1,x
  sta SCRATCH+4
  lda stackbase+2,x
  sta SCRATCH+5
  lda stackbase+3,x
  sta SCRATCH+2
  lda stackbase+4,x
  sta SCRATCH+3
  lda stackbase+5,x
  sta SCRATCH
  lda stackbase+6,x
  sta SCRATCH+1
  rts

;;; move memory from source to destination, copying from low to high
;;; on input, SCRATCH+0/1 are source address, SCRATCH+2/3 are destination
;;; address, and SCRATCH+4/5 are byte count
moveupsub
.(
  phx
  ldy #0
  ldx SCRATCH+5     ; X is # full pages to move
  beq lastblock
pageloop
  lda (SCRATCH),y
  sta (SCRATCH+2),y
  iny
  bne pageloop
  inc SCRATCH+1
  inc SCRATCH+3
  dex
  bne pageloop
lastblock
  cpy SCRATCH+4     ; we know Y=0 at this point
  beq finish
  lda (SCRATCH),y
  sta (SCRATCH+2),y
  iny
  bra lastblock
finish
  plx
  rts
.)

;;; move memory from source to destination, copying from high to low
;;; on input, SCRATCH+0/1 are source address, SCRATCH+2/3 are destination
;;; address, and SCRATCH+4/5 are byte count
;;; BUG there must be a better way to do this! Perhaps the other way
;;; around -- start with the less-than-page segment and then do
;;; full pages?
movedownsub
.(
  phx

  clc               ; update source pointer to END of block
  lda SCRATCH
  adc SCRATCH+4
  sta SCRATCH
  lda SCRATCH+1
  adc SCRATCH+5
  sta SCRATCH+1
  dec SCRATCH+1     ; move back by one page

  clc               ; now do same with destination pointer
  lda SCRATCH+2
  adc SCRATCH+4
  sta SCRATCH+2
  lda SCRATCH+3
  adc SCRATCH+5
  sta SCRATCH+3
  dec SCRATCH+3

  ldx SCRATCH+5     ; this is the number of full pages to copy
  beq lastblock
movepage
  ldy #255
innerloop
  lda (SCRATCH),y
  sta (SCRATCH+2),y
  dey
  bne innerloop
  lda (SCRATCH)     ; copy the zero-byte
  sta (SCRATCH+2)
  dec SCRATCH+1     ; decrement both pointers by one page
  dec SCRATCH+3
  dex               ; decrement page-copy count by one
  bne movepage
lastblock
  ldy #255
  ldx SCRATCH+4
  beq done
lastloop
  lda (SCRATCH),y
  sta (SCRATCH+2),y
  dex
  beq done
  dey
  bne lastloop
done
  plx
  rts  
.)

;;; implements -TRAILING (removes trailing spaces from string)
;;; ( c-addr u1 -- c-addr u2 )
dodashtrail
.(
  ;; if u1 is zero, we're done
  lda stackbase+1,x
  ora stackbase+2,x
  beq finish
setup
  sec               ; set up SCRATCH+4/5 as sentinel value (c-addr - 1)
  lda stackbase+3,x
  sbc #1
  sta SCRATCH+4
  lda stackbase+4,x
  sbc #0
  sta SCRATCH+5
  clc               ; now add string count to that
  lda SCRATCH+4     ; creating pointer to end of string
  adc stackbase+1,x ; and store at SCRATCH and SCRACH+1
  sta SCRATCH
  lda SCRATCH+5
  adc stackbase+2,x
  sta SCRATCH+1
  stz SCRATCH+2     ; finally, use SCRATCH+2/3 as count of spaces
  stz SCRATCH+3
loop
  lda (SCRATCH)     ; look at current character
  cmp #32           ; is it a space?
  bne nospace
  clc               ; yes, so bump counter
  lda SCRATCH+2
  adc #1
  sta SCRATCH+2
  bcc doneadd
  inc SCRATCH+3
doneadd
  sec               ; dec pointer by one byte
  lda SCRATCH
  sbc #1
  sta SCRATCH
  lda SCRATCH+1
  sbc #0
  sta SCRATCH+1
  lda SCRATCH       ; compare pointer to start-of-string ptr
  cmp SCRATCH+4
  bne loop          ; loop if LSB not equal to sentinel
  lda SCRATCH+1
  cmp SCRATCH+5
  bne loop          ; loop if MBS not equal
nospace
  ;; we get here if (1) we have encountered a non-space, or (2) we
  ;; have exhausted the string. either way, the behaviour is the
  ;; same; subtract the counter from the length value on the
  ;; stack.
  sec
  lda stackbase+1,x
  sbc SCRATCH+2
  sta stackbase+1,x
  lda stackbase+2,x
  sbc SCRATCH+3
  sta stackbase+2,x
finish
  jmp next
.)


;;; implement /STRING
;;; adjust left-hand of string by n chars
;;; ( c-addr1 u1 n -- c-addr2 u2 )
doslashstr
  ;; first, substract n from u1
  sec
  lda stackbase+3,x
  sbc stackbase+1,x
  sta stackbase+3,x
  lda stackbase+4,x
  sbc stackbase+2,x
  sta stackbase+4,x
  ;; then, add n to c-addr2
  clc
  lda stackbase+5,x
  adc stackbase+1,x
  sta stackbase+5,x
  lda stackbase+6,x
  adc stackbase+2,x
  sta stackbase+6,x
  ;; drop n
  inx
  inx
  ;; done
  jmp next


;;; implement COMPARE
;;; ( c-addr1 u1 c-addr2 u2 -- n )
;;; BUG limits string length to 255
docompare
.(
  lda stackbase+7,x
  sta SCRATCH
  lda stackbase+8,x
  sta SCRATCH+1
  lda stackbase+3,x
  sta SCRATCH+2
  lda stackbase+4,x
  sta SCRATCH+3
  lda stackbase+1,x
  sta SCRATCH+4
  lda stackbase+5,x
  sta SCRATCH+5

  ldy #0
loop
  lda (SCRATCH),y
  cmp (SCRATCH+2),y
  bne endmatch
  iny
  cpy #0            ; looped around?
  beq ident
  ; compare to string lengths
  cpy SCRATCH+4     ; stackbase+1,x
  beq hitu2
  cpy SCRATCH+5     ; stackbase+5,x
  beq hitu1
  bra loop
hitu2
  cpy SCRATCH+5     ; stackbase+5,x
  beq ident
  ;; otherwise, not ident but str2 shorter than str1
  bra return1
hitu1
  cpy SCRATCH+4     ; stackbase+1,x
  beq ident
  ;; otherwise, not ident but str1 shorter than str2
  bra returnm1
endmatch
  bmi returnm1      ; minus if c2 > c1 so return -1
  bra return1       ; otherwise c1 < c2 so return 1
ident
return0
  clc               ; drop three cells from the stack
  txa
  adc #6
  tax
  stz stackbase+1,x
  stz stackbase+2,x
  jmp next
return1
  clc               ; drop three cells from the stack
  txa
  adc #6
  tax
  lda #1
  sta stackbase+1,x
  stz stackbase+2,x
  jmp next
returnm1
  clc               ; drop three cells from the stack
  txa
  adc #6
  tax
  lda #$ff
  sta stackbase+1,x
  sta stackbase+2,x
  jmp next
.)
  
  


;;;
;;; *** SD CARD SUPPORT
;;;
;;; I have an SD breakout card attached to Port B on the 6522. These
;;; routines are the drivers to initialize, read, and write, as
;;; well (later) as navigating the FAT16 filesystem.
;;; 
;;; Wiring details:
;;;   CLK is PB0, ie 1
;;;   MOSI is PB1, ie 2
;;;   CS is PB2, ie 4
;;;   MISO is PB7, which maps onto S flag on BIT (test with BPL and BMI)
;;; MISO, MOSI, and CS all have pull-up resisters, so they are high in
;;; the idle/unused state, except when pulled low by active circuitry.
;;;
;;; SD card support code is organized into roughly three layers. The
;;; lowest is the signalling layer that uses the 6522 to implement the
;;; SPI protocol. The thin middle layer is a basic layer for reading
;;; and writing data blocks. The upper layer implements (a subset of)
;;; the FAT16 filesystem.
;;;
SD_CLK  = 1
SD_MOSI = 2
SD_CS   = 4
SD_MISO = 128

;;; LOWEST LAYER (SPI PROTOCOL)
;;;

;;; set up data direction for PORTB -- lower four bits are outputs
;;; and upper four bits are inputs. This is called from FORTH startup.
setup6522
  lda #15
  sta VIA_DDRB
  rts

;;; Forth word to initialize the SD card and read the boot block.
;;; all the actual work is in mountsub, though. (This lets me call
;;; it from other places too.)
domount
.(
  jsr mountsub
  beq done
  jmp abortcardfail
done
  jmp next
.)

;;; do the work of mounting a new card. carry on exit signals
;;; an error.
mountsub
.(
  clc
  stz CURSEC
  stz CURSEC+1
  stz CURSEC+2
  stz CURSEC+3

  ;; BUG should test for card present
  jsr resetsd
  jsr cmd0
  cmp #1
  beq continue
  sec
  bra donemount
continue

  jsr sendff
  jsr cmd8
  ;; BUG test the response

  lda #100           ; going to try this up to 100 times
  sta SCRATCH

repeat55
  jsr sendff
  jsr cmd55
  jsr sendff
  jsr acmd41
  cmp #0            ; loop until we get a 0 response
  beq success

  dec SCRATCH
  bne repeat55
  sec
  bra donemount

success
  jsr sendff
  jsr cmd17

  jsr gettoken
  jsr getblock

.(

  ;; copy first 64 bytes into MBR area
  ldy #0
loop
  lda LBLOCK,y
  sta MBR,y
  iny
  cpy #64
  bne loop
.)

  ;; print a message with the card name
  ldy #0
.(
next_char
  lda initializedmsg,y
  beq done
  jsr puta
  iny
  jmp next_char
done
.)

.(
  ldy #0
next_char
  lda MBR_LABEL,y
  jsr puta
  iny
  cpy #11
  bne next_char
.)

donemount
  rts
.)


;;; ABORT with a message about card not initializing
abortcardfail
  lda #<cardfailmsg
  sta PRINTVEC
  lda #>cardfailmsg
  sta PRINTVEC+1
  jsr printvecstr
  jmp abort

;;; ABORT with a disk error
abortdiskerror
  lda #<diskerrormsg
  sta PRINTVEC
  lda #>diskerrormsg
  sta PRINTVEC+1
  jsr printvecstr
  ;; invalidate the sector number cache
  lda #$ff
  sta CURSEC+3
  jmp abort

;;; ABORT with a file error
abortnofile
  lda #<nofilemsg
  sta PRINTVEC
  lda #>nofilemsg
  sta PRINTVEC+1
  jsr printvecstr
  jmp abort



docmd0
  jsr resetsd
  jsr cmd0
  ;; push whatever came back onto the stack
  sta stackaccess
  stz stackaccess+1
  jsr push16
  jmp next

;;; initialize the SD card and set it to SPI mode.
resetsd
  lda #SD_CS+SD_MOSI  ; set MOSI and CS to 1
  sta PORTB

  ;; toggle CLK at least 74 times (ie do 80, for 10 bytes of FF)
  ;;
  ldy #80
.(
initloop
  inc PORTB
  dec PORTB
  dey
  bne initloop
.)
  rts

cmd0
  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd0 (01+6*0 + 24*0 + 10010101)
  lda #SPI_CMD+0
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #%10010101    ; CRC plus end bit
  jsr sendbyte

  jsr setidle       ; set to idle to await input
  jsr getresponse   ; get single byte response

  ldy #SD_CS+SD_MOSI ; set CS and MOSI high to release card
  sty PORTB
  rts

setidle
  ldy #%00000010    ; CLK off, MOSI high, CS low
  sty PORTB
  rts  

;; send an $ff... this is basically just about creating delays
;; between commands
sendff
  ;; set cs to 1
  lda #SD_CS
  tsb PORTB
  lda #$ff
  jsr sendbyte
  rts

;; the forth word version
;dosendff
;  jsr sendff
;  jmp next

;; forth word version for cmd8
;docmd8
;.(
;  jsr sendff
;  jsr cmd8
;
;  ;; if any bit other that the low order bit is set
;  ;; on the response, then return that.
;  lda SCRATCH
;  and #254
;  beq returndata
;
;  ;; we got a signal of an illegal command. return it
;  lda SCRATCH
;  sta stackaccess
;  stz stackaccess+1
;  bra end
;
;returndata
;  ;; push lower 16 bits of what we get back onto the stack
;  lda SCRATCH+4
;  sta stackaccess
;  lda SCRATCH+3
;  sta stackaccess+1
;end
;  jsr push16
;  jmp next
;.)

cmd8
  ;; set cs to 0
  lda #4
  trb PORTB

  ;; send cmd8 with parameter 0x000001aa
  lda #SPI_CMD+8
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  lda #1
  jsr sendbyte
  lda #$aa
  jsr sendbyte
  lda #$87          ; crc
  jsr sendbyte

  jsr setidle
  jsr await40bits

  lda #SD_CS+SD_MOSI  ; release card (CS and MOSI high)
  sta PORTB

  rts

;;; do cmd58, which gets a long response
;docmd58
;  jsr sendff
;  jsr cmd58
;  lda SCRATCH+1
;  sta stackaccess+1
;  lda SCRATCH+2
;  sta stackaccess
;  jsr push16
;  lda SCRATCH+3
;  sta stackaccess+1
;  lda SCRATCH+4
;  sta stackaccess
;  jsr push16
;  lda SCRATCH
;  sta stackaccess
;  stz stackaccess+1
;  jsr push16
;  jmp next

cmd58
  ;; set cs to 0
  lda #4
  trb PORTB

  ;; send cmd58
  lda #SPI_CMD+58
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #%01110101
  jsr sendbyte

  jsr setidle
  jsr await40bits

  lda #SD_CS+SD_MOSI  ; release card (CS and MOSI high)
  sta PORTB

  rts



;;; do cmd55... that will allow acmd 41...
;docmd55
;.(
;  jsr sendff
;  jsr cmd55
;  sta stackaccess
;  stz stackaccess+1
;  jsr push16
;  jmp next
;.)

cmd55
  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd55 with parameter 0
  lda #SPI_CMD+55
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; crc
  jsr sendbyte

  jsr setidle
  jsr getresponse
  ldy #6
  sty PORTB
  rts

  
;doacmd41
;.(
;  jsr sendff
;  jsr acmd41
;  sta stackaccess
;  stz stackaccess+1
;  jsr push16
;  jmp next
;.)

acmd41
  ;; set cs to 0
  lda #4
  trb PORTB

  lda #SPI_CMD+41
  jsr sendbyte
  lda #%01000000    ; bit 30 is HCS flag
  jsr sendbyte
  lda #16           ; bit 20 selects 3.2-3.3V
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; checksum, but doesn't matter in SPI mode?
  jsr sendbyte

  jsr setidle
  jsr getresponse

  ldy #6
  sty PORTB
  rts

;docmd17
;  jsr sendff
;  jsr cmd17
;  sta stackaccess
;  stz stackaccess+1
;  jsr push16
;  jmp next  

cmd17
  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd17 with parameter 0
  lda #SPI_CMD+17
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; crc, doesn't matter
  jsr sendbyte

  jsr setidle
  jsr getresponse
  rts

;dogetblock
;  jsr gettoken
;  jsr getblock
;  jmp next

gettoken
  ; listen until we hear %11111110 (254/$FE)
  jsr recv8bits
  cmp #$FE
  bne gettoken
  rts

getblock
.(
  ;; get 256 bytes at LBLOCK
  stz SCRATCH+8
  lda #>LBLOCK
  sta SCRATCH+9
loop
  jsr recv8bits
  sta (SCRATCH+8)
  inc SCRATCH+8
  bne loop
.)
.(
  ;; get 256 bytes at HBLOCK
  stz SCRATCH+8
  lda #>HBLOCK
  sta SCRATCH+9
loop
  jsr recv8bits
  sta (SCRATCH+8)
  inc SCRATCH+8
  bne loop
.)
  ; get CRC but ignore it. 16 bits, so two byte reads.
  jsr recv8bits
  jsr recv8bits

  jsr sendff        ; eight clock ticks to let SD card finish up
  rts


doloadblock
.(
  jsr sdloadblock
  bcc done
  jmp abortdiskerror
done
  jmp next
.)

;dosaveblock
;.(
;  jsr sdsaveblock
;  bcc done
;  jmp abortdiskerror
;done
;  jmp next
;.)


;;; Load block specified by double on the stack, translating between
;;; number formats.
sdloadblock

  ;; check if this block is already loaded.
  lda stackbase+1,x
  cmp CURSEC
  bne startload
  lda stackbase+2,x
  cmp CURSEC+1
  bne startload
  lda stackbase+3,x
  cmp CURSEC+2
  bne startload
  lda stackbase+4,x
  cmp CURSEC+3
  bne startload
  clc               ; make sure carry is clear (error signal)
  bra finishload    ; jump to end, clean up stack
  
startload
  jsr sendff

  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd17 with parameter from the stack
  lda #SPI_CMD+17
  jsr sendbyte
  lda stackbase+4,x
  jsr sendbyte
  lda stackbase+3,x
  jsr sendbyte
  lda stackbase+2,x
  jsr sendbyte
  lda stackbase+1,x
  jsr sendbyte
  lda #$95          ; crc, doesn't matter
  jsr sendbyte

  jsr setidle
  jsr getresponse
  cmp #0
  bne abortread

  jsr gettoken
  jsr getblock

  ;; update cache of current sector number
  lda stackbase+1,x
  sta CURSEC
  lda stackbase+2,x
  sta CURSEC+1
  lda stackbase+3,x
  sta CURSEC+2
  lda stackbase+4,x
  sta CURSEC+3

finishload
  inx               ; clean up the stack
  inx
  inx
  inx

  clc               ; operation successful, so clear carry
  rts

abortread
  inx               ; clean up the stack
  inx
  inx
  inx

  sec               ; set carry to signal failure
  rts


sdloadnext
  ;; copy cached block number onto the stack, adding one
  dex
  dex
  dex
  dex
  clc
  lda CURSEC
  adc #1
  sta stackbase+1,x
  lda CURSEC+1
  adc #0
  sta stackbase+2,x
  lda CURSEC+2
  adc #0
  sta stackbase+3,x
  lda CURSEC+3
  adc #0
  sta stackbase+4,x

  ;; now jump to regular block load code, skipping cache check
  ;; (because we know it's different, clearly).
  jmp startload


;;; Save to block specified by double on the stack, translating between
;;; number formats.
sdsaveblock
.(
  jsr sendff

  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd24 with parameter from the stack
  lda #SPI_CMD+24
  jsr sendbyte
  lda stackbase+4,x
  jsr sendbyte
  lda stackbase+3,x
  jsr sendbyte
  lda stackbase+2,x
  jsr sendbyte
  lda stackbase+1,x
  jsr sendbyte
  lda #$95          ; crc, doesn't matter
  jsr sendbyte

.(
  jsr setidle
  jsr getresponse
  cmp #0            ; other things might have messed with Z lately
  beq continue

;  sta stackaccess   ; print the response code (remove after debugging)
;  stz stackaccess+1
;  jsr push16
;  jsr print16u
  
;  lda #$20
;  jsr puta
;  lda #$31          ; error code 8
;  jsr puta
  bra abortsave
continue
.)

  jsr sendff
  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  jsr sendtoken
  jsr sendblock
  jsr setidle

.(
  jsr getresponse
  and #%00001110
  cmp #4
  beq continue

;  sta stackaccess   ; print the response code (remove after debugging)
;  stz stackaccess+1
;  jsr push16
;  jsr print16u

  lda #$20
  jsr puta
  lda #$32          ; error code 2
  jsr puta
  bra abortsave
continue
.)

  ;; now wait until the card is ready again. card will hold the data
  ;; line low while it is processing.
.(
busywait
  jsr recv8bits
  beq busywait
.)

  ;; update the cache of the current sector number
  lda stackbase+1,x
  sta CURSEC
  lda stackbase+2,x
  sta CURSEC+1
  lda stackbase+3,x
  sta CURSEC+2
  lda stackbase+4,x
  sta CURSEC+3

finishsave
  inx               ; clean up the stack
  inx
  inx
  inx  
  clc               ; all okay, clear error flag
  rts

abortsave
  inx               ; clean up the stack
  inx
  inx
  inx
  sec               ; set flag to signal error
  rts
.)

sdsavenext
  ;; copy cached block number onto the stack, adding one
  dex
  dex
  dex
  dex
  clc
  lda CURSEC
  adc #1
  sta stackbase+1,x
  lda CURSEC+1
  adc #0
  sta stackbase+2,x
  lda CURSEC+2
  adc #0
  sta stackbase+3,x
  lda CURSEC+3
  adc #0
  sta stackbase+4,x

  ;; now jump to regular block save code
  jmp sdsaveblock


sendtoken
  lda #254
  jsr sendbyte
  rts

sendblock
  phx
  ;; send the first 256 bytes from LBLOCK
  ldx #0
.(
sendloop
  lda LBLOCK,x
  jsr sendbyte
  inx
  bne sendloop
.)

  ;; send the second 256 bytes from HBLOCK
  ldx #0
.(
sendloop
  lda HBLOCK,x
  jsr sendbyte
  inx
  bne sendloop
.)
  lda #0
  jsr sendbyte      ; types for CRC
  jsr sendbyte
  plx
  rts


;; load the root directory
sdloadroot
  dex
  dex
  dex
  dex
  lda #1            ; sector 513 == 0x00000201
  sta stackbase+1,x
  lda #2
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x
  jmp sdloadblock
  

;;; List files from the root directory
;;;
dodir
  ;; BUG should check that there's a disk mounted and present
  ;; load the root directory -- just hardcoding location for now
  ;; BUG calculate this properly
  stz stackaccess
  stz stackaccess+1
  jsr push16
  lda #2            ; block 513 = 2 in MSB and 1 in LSB
  sta stackaccess+1
  lda #1
  sta stackaccess
  jsr push16
  jsr sdloadblock
  bcc header
  jmp abortdiskerror

header
  jsr crlf
  lda #<dirofmsg
  sta PRINTVEC
  lda #>dirofmsg
  sta PRINTVEC+1
  jsr printvecstr

  ldy #0
.(
loop
  lda MBR_LABEL,y
  cmp #$20
  beq done
  jsr puta
  iny
  cpy #11
  beq done
  bra loop
done
.)
  jsr crlf
  
startdir
  ;; set pointer to first entry
  lda #<LBLOCK
  sta SCRATCH+6
  lda #>LBLOCK
  sta SCRATCH+7

printdirent         ; print the entry pointed to by SCRATCH+6

  lda (SCRATCH+6)
  beq endofdir      ; if it's null, we're done
  cmp #$e5          ; $e5 indicates file is deleted, so skip it
  beq nextdirent

  ldy #11           ; check for hidden file
  lda (SCRATCH+6),y
  and #2
  bne nextdirent    ; skip hidden files

  ;; print two spaces
  lda #$20
  jsr puta
  jsr puta

  ;; print the file name (and then extension)
  ;; we always print eight characters for the filename because
  ;; they are padded with spaces
  ldy #0
.(
nextchar
  lda (SCRATCH+6),y
  jsr puta
  iny
  cpy #8            ; stop after eight characters
  bne nextchar
.)

  lda #"."
  jsr puta

printext            ; now print extension, if there is one
  lda (SCRATCH+6),y
  jsr puta
  iny
  lda (SCRATCH+6),y
  jsr puta
  iny
  lda (SCRATCH+6),y
  jsr puta

  lda #8            ; set up field size parameter for rprint
  sta stackaccess
  stz stackaccess+1
  jsr push16

  ldy #28           ; bytes 28-31 are the filesize in bytes
  dex
  dex
  dex
  dex
  lda (SCRATCH+6),y
  sta stackbase+1,x
  iny
  lda (SCRATCH+6),y
  sta stackbase+2,x
  iny
  lda (SCRATCH+6),y
  sta stackbase+3,x
  iny
  lda (SCRATCH+6),y
  sta stackbase+4,x
  jsr rprint32s
  jsr crlf

nextdirent
.(
  clc               ; add 32 to skip to next entry
  lda SCRATCH+6
  adc #32
  sta SCRATCH+6
bcc done
  inc SCRATCH+7
done

  ;; check if we have run off the end of the input buffer space
  ;; (by comparing to the MSB of PAD, which is the space right after).
  ;; if so, load the next block.
  ;; BUG there are 32 blocks allocated to the root directory. should
  ;; count to make sure that we don't exceed that. but I'm presuming
  ;; for the moment that we'll hit a null entry before then.
  lda SCRATCH+7
  cmp #>PAD
  bne endnext       ; still fine, continue
  jsr sdloadnext
  lda #<LBLOCK      ; reset pointer to the start of the buffer
  sta SCRATCH+6
  lda #>LBLOCK
  sta SCRATCH+7
endnext
.)
  bra printdirent

endofdir
  jsr crlf

  jmp next


;; NOTE this uses SCRATCH+4,5,12,13,14,15
doshow

  jsr readnext      ; get next word and put it into input buffer
  jsr matchname     ; see what we get

.(
  bcc continue
  jmp abortnofile

continue
.)
  ;; now, SCRATCH+6/7 points to directory entry

  ;; first, grab the block number and push onto stack as a double
  dex
  dex
  dex
  dex
  ldy #26
  lda (SCRATCH+6),y ; LSB
  sta stackbase+1,x
  iny
  lda (SCRATCH+6),y ; MSB
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  ;; grab the file size and stash it
  iny
  lda (SCRATCH+6),y
  sta SCRATCH+12
  iny
  lda (SCRATCH+6),y
  sta SCRATCH+13
  iny
  lda (SCRATCH+6),y
  sta SCRATCH+14
  iny
  lda (SCRATCH+6),y
  sta SCRATCH+15

  ;; turn block count on stack into sector count, and load the sector
  jsr cltosector
  jsr sdloadblock

  ;; now type what's in the block, up to the file size. we print in
  ;; blocks of 256 bytes, but we do so twice because the buffer is
  ;; actually 512 bytes.
  ;; BUG we ignore anything over 32k for the file size

  jsr crlf

typeblock
.(
  ;; by default, print 256 characters
  lda #255
  sta SCRATCH
  ;; are there fewer than 256 characters to process?
  lda SCRATCH+13
  beq under256
  dec SCRATCH+13    ; we will print 256 characters, take 256 off the count
  bra first256
under256
  lda SCRATCH+12    ; < 256, so lowest byte is # of chars to print
  beq endshow       ; if it's zero, we're done
  dec               ; range from 0 rather than 1
  sta SCRATCH
  stz SCRATCH+12
.)

first256
  ldy #0
.(
typechar
  lda LBLOCK,y
  jsr puta
  cmp #10           ; in the case of an LF, add a CR too
  bne nextchar
  lda #13
  jsr puta
nextchar
  cpy SCRATCH
  beq done
  iny
  bra typechar
done
.)

  ;; now consider the second 256 characters in the sector
.(
  ;; by default, print 256 characters
  lda #255
  sta SCRATCH
  ;; are there fewer than 256 characters to process?
  lda SCRATCH+13
  beq under256
  dec SCRATCH+13    ; update count for the end of the print
  bra second256
under256
  lda SCRATCH+12    ; < 256, so lowest byte is # of chars to print
  beq endshow       ; if it's zero, we're done
  dec               ; re-range to zero-index
  sta SCRATCH
  stz SCRATCH+12    ; after which, there will be none left
.)

second256
  ldy #0
.(
typechar
  lda HBLOCK,y
  jsr puta
  cmp #10           ; in the case of an LF, add a CR too
  bne nextchar
  lda #13
  jsr puta
nextchar
  cpy SCRATCH
  beq done
  iny
  bra typechar
done
.)

  ;; if there is more data, load the next block and repeat
  lda SCRATCH+13
  bne nextblock
  lda SCRATCH+12
  beq endshow

nextblock
  jsr sdloadnext
  jmp typeblock

endshow
  jsr crlf
  jmp next


;;; USING specifies the block file from which subsequent block
;;; operations should load and save.
dousing
  jsr readnext      ; get next word and put it into input buffer
  jsr matchname     ; see what we get

.(
  bcc continue
  jmp abortnofile

continue
.)
  ;; now, SCRATCH+6/7 points to directory entry

  ;; first, grab the block number and push onto stack as a double
  dex
  dex
  dex
  dex
  ldy #26
  lda (SCRATCH+6),y ; LSB
  sta stackbase+1,x
  iny
  lda (SCRATCH+6),y ; MSB
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  ;; turn block count on stack into sector count, and stash
  ;; it for future reference
  jsr cltosector
  lda stackbase+1,x
  sta USEBASE
  lda stackbase+2,x
  sta USEBASE+1
  lda stackbase+3,x
  sta USEBASE+2
  lda stackbase+4,x
  sta USEBASE+3

  ;; clean up the stack
  inx  
  inx
  inx
  inx

  ;; the old buffers are no longer useful. zero them out
  ;; and reset the pointers.
  stz PREV
  stz PREV+1
  lda #<FIRST
  sta USE
  lda #>FIRST
  sta USE+1
  jsr zerobuffers

  jmp next


;; NOTE this uses SCRATCH+4,5,10,11,12,13,14,15. getblock uses 8,9.
;; match uses +6 and +7.
dofload

  jsr readnext      ; get next word and put it into input buffer
  jsr matchname     ; see what we get

.(
  bcc continue
  jmp abortnofile

continue
.)
  ;; now, SCRATCH+6/7 points to directory entry

  ;; first, grab the block number and push onto stack as a double
  dex
  dex
  dex
  dex
  ldy #26
  lda (SCRATCH+6),y ; LSB
  sta stackbase+1,x
  iny
  lda (SCRATCH+6),y ; MSB
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  ;; grab the file size and stash it
  iny
  lda (SCRATCH+6),y
  sta SCRATCH+12
  iny
  lda (SCRATCH+6),y
  sta SCRATCH+13
  iny
  lda (SCRATCH+6),y
  sta SCRATCH+14
  iny
  lda (SCRATCH+6),y
  sta SCRATCH+15

  ;; set up destination address
  lda #<IOSPACE
  sta SCRATCH+10
  lda #>IOSPACE
  sta SCRATCH+11

  jsr loadfile
  jmp next


;;; load a file from SD into memory. On entry, the starting block
;;; is specified on the stack, the length of the file is in
;;; SCRATCH+12-15, and the address in memory into whic it should be
;;; copied is in SCRATCH+10-11. (There is no logic to these addresses;
;;; it's just how the code was originally written before being extracted
;;; as a subroutine. Return to this for a more logical format?)
loadfile
  ;; turn block count on stack into sector count, and load the sector
  jsr cltosector
  jsr sdloadblock

  ;; now load what's in the block, up to the file size. we load in
  ;; blocks of 256 bytes, but we do so twice because the buffer is
  ;; actually 512 bytes.
  ;; BUG we ignore anything over 32k for the file size

loadblock
.(
  ;; by default, load 256 characters
  ldy #255
  sty SCRATCH
  ;; are there fewer than 256 characters left to process?
  lda SCRATCH+13
  beq under256
  dec SCRATCH+13    ; we will load 256 characters, take 256 off the count
  bra lfirst256
under256
  lda SCRATCH+12    ; < 256, so lowest byte is # of chars to print
  beq endfload      ; if it's zero, we're done
  dec               ; range from 0 rather than 1
  sta SCRATCH
  tay
  stz SCRATCH+12
.)

lfirst256
.(
loop
  lda LBLOCK,y
  sta (SCRATCH+10),y
  dey
  bne loop
  lda LBLOCK,y      ; and the last one by hand
  sta (SCRATCH+10),y
.)

.(
  clc
  lda SCRATCH+10
  adc SCRATCH
  adc #1
  sta SCRATCH+10
  bcc done
  inc SCRATCH+11
done
.)

  
  ;; now consider the second 256 characters in the sector
.(
  ;; are there fewer than 256 characters to process?
  lda SCRATCH+13
  beq under256
  dec SCRATCH+13    ; update count for the end of the load
  ldy #255          ; 256 characters to be copied
  sty SCRATCH       ; y is the index but keep a copy
  bra lsecond256
under256
  lda SCRATCH+12    ; < 256, so lowest byte is # of chars to print
  beq endfload      ; if it's zero, we're done
  dec               ; re-range to zero-index
  sta SCRATCH
  tay
  stz SCRATCH+12    ; after which, there will be none left
.)

lsecond256
.(
loop
  lda HBLOCK,y
  sta (SCRATCH+10),y
  dey
  bne loop
  lda HBLOCK,y      ; last one by hand
  sta (SCRATCH+10),y
.)

.(
  clc
  lda SCRATCH+10
  adc SCRATCH
  adc #1
  sta SCRATCH+10
  bcc done
  inc SCRATCH+11
done
.)

  ;; if there is more data, load the next block and repeat
  lda SCRATCH+13
  bne loadnextblock
  lda SCRATCH+12
  beq endfload

loadnextblock
  jsr sdloadnext
  jmp loadblock

endfload
  ; null-terminate the load
  lda #0
  sta (SCRATCH+10)
  rts

  

;; convert a cluster address into a sector address
;; calculation is cluster-2 * sectors/cluster + resv + len FATs + len root
;; generally, cluster-2 * 64 + 545
cltosector
.(
  ;; subtract 2
  sec
  lda stackbase+1,x
  sbc #2
  sta stackbase+1,x
  lda stackbase+2,x
  sbc #0
  sta stackbase+2,x
  lda stackbase+3,x
  sbc #0
  sta stackbase+3,x
  lda stackbase+4,x
  sbc #0
  sta stackbase+4,x
done
.)

  ;; shift left 6 times, to multiply by 64
  clc
  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  rol stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  ;; add 545 ( = 512+33 = 2*256 + 33)
  clc
  lda stackbase+1,x
  adc #33
  sta stackbase+1,x
  lda stackbase+2,x
  adc #2
  sta stackbase+2,x
  lda stackbase+3,x
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  adc #0
  sta stackbase+4,x

  rts


;doflookup
;  jsr readnext      ; get next word and put it into input buffer
;  jsr matchname     ; see what we get
;  lda SCRATCH+6
;  sta stackaccess
;  lda SCRATCH+7
;  sta stackaccess+1
;  jsr push16
;  jsr print16u
;  jmp next


;; take filename in WORD, look up in root directory, return pointer
;; to directory entry that matches in SCRATCH+6/7. Return entry is 0x0000
;; and carry is set in case of no match.
matchname
.(
  ;; load the root directory
  jsr sdloadroot

  ;; reset PADPTR
  lda #<PAD
  sta PADPTR
  lda #>PAD
  sta PADPTR+1

  ;; first, make a canonical version of the filename, padding
  ;; both name and extension with spaces to full 8.3 versions.
  ;; keep this on the PAD.
  ;; 
  ;; start by filling with default characters
.(
  ldy #10
  lda #$20
loop
  sta (PADPTR),y
  dey
  bne loop
.)

  ;; now, copy filename into the canoniclized version, switching
  ;; lower case to upper case along the way
.(
  lda WORD          ; null-terminate the string, just in case
  tay
  iny
  lda #0
  sta WORD,y

  ldy #1            ; skip the first byte (char count)
  lda PADPTR
  sta SCRATCH
  lda PADPTR+1
  sta SCRATCH+1
loop
  lda WORD,y
  cmp #"."
  beq endname
  cmp #"a"
  bcc copy
  cmp #"{"          ; first character after "z"
  bcs copy
  and #%11011111    ; convert lower to upper
copy  
  sta (SCRATCH)
  inc SCRATCH
  iny
  cpy #9
  beq endname
  bra loop
endname
  iny               ; skip "."
  clc
  lda PADPTR
  adc #8
  sta SCRATCH       ; BUG ignores upper byte, presumes no page boundary
.)

  ;; finally, copy the extension.
.(
extloop
  lda WORD,y
  beq done
  cmp #"a"
  bcc copy
  cmp #"{"          ; first character after "z"
  bcs copy
  and #%11011111    ; convert lower to upper
copy  
  sta (SCRATCH)
  inc SCRATCH
  iny
  cpy #3
  bne extloop
done
.)
  ;; now the filename is in the same format as stored in the
  ;; directory, making matching easier.
  lda #<LBLOCK
  sta SCRATCH+6
  lda #>LBLOCK
  sta SCRATCH+7

matchloop
  lda (SCRATCH+6)   ; null entry (ie, end of directory)?
  beq noentry

  ;; match a single directory entry
matchentry
  ldy #0
nameloop
  lda (SCRATCH+6),y
  cmp (PADPTR),y
  bne matchfail
  iny
  cpy #11
  bne nameloop
success
  clc
  rts

matchfail
  ;; get next directory entry
  clc
  lda SCRATCH+6     ; bump pointer
  adc #32           ; entries are 32 bytes long
  sta SCRATCH+6
  lda SCRATCH+7
  adc #0
  sta SCRATCH+7
  cmp #>PAD         ; run off the end of the buffer?
  bne matchloop
  jsr sdloadnext    ; load next block
  lda #<LBLOCK      ; reset the directory pointer to new block
  sta SCRATCH+6
  lda #>LBLOCK
  sta SCRATCH+7
  bra matchloop     ; loop to test this one
.)

noentry
  stz SCRATCH+6
  stz SCRATCH+7
  sec
  rts




;;; lowest levels -- send a byte, receive a byte...


sendbyte
  ldy #8
sendloop
  asl
  pha
  bcc sendzero
sendone
  lda #SD_MOSI
  tsb PORTB
  bra send
sendzero
  lda #SD_MOSI
  trb PORTB
send
  inc PORTB
  dec PORTB
  pla
  dey
  bne sendloop
  rts

;; wait for data by pulsing the clock until there's a zero on MISO
awaitdata
.(
  inc PORTB         ; set CLK high
  bit PORTB         ; check for data on MISO
  bpl done          ; exit if we see a zdero
  dec PORTB         ; otherwise, set CLK low and 
  bra awaitdata     ; loop around again
done
  dec PORTB
.)
  rts

;; wait with a timeout. if we don't hear something within 256 pulses,
;; set carry flag and return
awaittimeout
.(
  clc
  ldy #0
awaitloop
  inc PORTB
  bit PORTB
  bpl done
  dec PORTB
  dey
  beq timeout
  bra awaitloop
timeout
  sec
  rts
done
  dec PORTB
  rts
.)

;; wait for data and then receive a byte starting with zero
awaitbyte
  jsr awaitdata
  lda #0
  jmp recv7bits

;; wait for byte with timeout (signalled with carry)
awaitbto
  jsr awaittimeout
  bcs timeout
  lda #0
  jmp recv7bits
timeout
  rts
  
await40bits
  jsr awaitdata     ; wait for any data
  jsr recv7bits     ; grab first 7 bits (presuming leading 0)
  sta SCRATCH
  jsr recv8bits     ; second byte
  sta SCRATCH+1
  jsr recv8bits     ; third byte
  sta SCRATCH+2
  jsr recv8bits     ; fourth byte
  sta SCRATCH+3
  jsr recv8bits     ; fifth byte
  sta SCRATCH+4
  rts

getresponse
.(
  phx
  ldx #0
loop
  inx
  beq timedout
  jsr recv8bits
  cmp #$ff
  beq loop
timedout
  plx
  rts
.)

;; TODO unroll this, probably a good deal faster then looping
recv8bits
  lda #0            ; zero out result
  inc PORTB         ; set clock high
  lda PORTB         ; read data
  cmp #128          ; this sets carry flag to top bit
  rol               ; shift carry into A
  dec PORTB         ; set clock off
  ;; now fall through to receive next seven bits

recv7bits
.(
  ldy #7            ; count up to seven bits
  phx               ; store X, since we'll use it
recvloop
  inc PORTB         ; set CLK high
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low
  dey               ; update bit count
  bne recvloop      ; loop until finished
  plx               ; restore X
.)
  rts               ; return with data in A




;;;
;;; *** BUFFER/BLOCK/VIRTUAL MEMORY
;;;
;;; I don't implement the full panoply of regular FORTH routines
;;; just yet (and perhaps never), but this is enough to get things
;;; going and then incorporate the editor. Blocks are 1024 characters
;;; long, so buffers are 1028 bytes.
;;; 

;;; BUFFER allocates a buffer, which might require flushing out
;;; old data. All the activity happens in a subroutine so that I can
;;; also call it from inside the code for BLOCK.
dobuffer
  jsr buffersub
  jmp next


;;; Allocates a buffer for a block number given on the stack. Looks
;;; through current buffers to see if the block is already loaded,
;;; and if so, returns the existing buffer. If not, looks for an
;;; available buffer. If the buffer it wants to use is already
;;; allocated, and is dirty, then write it out before returning.
buffersub
  dex               ; make two bytes of working space on the stack
  dex

  lda #<FIRST
  sta stackbase+1,x
  sta SCRATCH
  lda #>FIRST
  sta stackbase+2,x
  sta SCRATCH+1

  ;; is the buffer currently loaded?
  ;; if so, return that one
.(
checkbuffer
  ldy #0
  lda (SCRATCH),y
  cmp stackbase+3,x
  bne checknext
  iny
  lda (SCRATCH),y
  and #$7F          ; mask off the top bit, which indicates clean/dirty
  cmp stackbase+4,x
  beq foundbuffer   ; yes, so return this buffer

checknext
  jsr plusbuf       ; no, so move on to the next one

  lda stackbase+1,x ; have we wrapped around? if we have, leave this
  cmp #<FIRST       ; loop and allocate a buffer
  bne continue
  lda stackbase+2,x
  cmp #>FIRST
  bne continue
  bra allocatebuffer

continue
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1
  bra checkbuffer
.) 

foundbuffer
  lda SCRATCH       ; update PREV to point to this buffer
  sta PREV
  lda SCRATCH+1
  sta PREV+1

  clc               ; return ptr to the first data byte of the buffer
  lda stackbase+1,x ; which is two bytes after the buffer address itself
  adc #2
  sta stackbase+3,x ; leave these over the buffer number on the stack
  lda stackbase+2,x
  adc #0
  sta stackbase+4,x

  inx               ; clean up the stack
  inx
  rts

;;; allocate a buffer. I don't look for an empty one. Run through how
;;; this is likely to work with what I expect to be the initial conditions
;;; for USE and PREV.
allocatebuffer
  ;; start with the buffer marked by USE
  lda USE
  sta stackbase+1,x
  lda USE+1
  sta stackbase+2,x

  ;; look at the next buffer address
  ;; is it the same as indicated by PREV?
  ;; if not, we're good
.(
checkbuffer
  lda stackbase+1,x
  cmp PREV
  bne good
  lda stackbase+2,x
  cmp PREV+1
  bne good

  ;; if so, pick another
  jsr plusbuf
  bne checkbuffer
.)

good
  lda stackbase+1,x ; copy buffer pointer into SCRATCH
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

  ;; is the buffer dirty?
  ldy #1
  lda (SCRATCH),y
  and #$80          ; check top bit
  beq clean

  ;; buffer is dirty, so flush it before continuing
  jsr flushbuf

  ;; mark it as clean
  ldy #1
  lda (SCRATCH),y
  and #127
  sta (SCRATCH),y
  
clean
  ;; at this point, stackbase+1/2 are working space containing
  ;; a buffer address, and stackbase+3/4 is still the block #

  ;; update USE and PREV
  clc
  lda stackbase+1,x
  sta PREV
  adc #2            ; we return a data address, which is BUF+2
  sta stackbase+3,x
  lda stackbase+2,x
  sta PREV+1
  adc #0
  sta stackbase+4,x

  jsr plusbuf
  lda stackbase+1,x
  sta USE
  lda stackbase+2,x
  sta USE+1
  inx               ; clean up the stack
  inx
  rts
;; end of buffersub


;; flush a buffer. on entry, the buffer pointer is in SCRATCH.
flushbuf

  ;; make space on the stack for the sector number
  dex
  dex
  dex
  dex
  
  ;; convert buffer number to sector number and store on stack
  ldy #1
  sec
  lda (SCRATCH)
  sbc #1            ; first step of conversion is to subtract one
  sta stackbase+1,x
  lda (SCRATCH),y
  and #127          ; mask off the dirty bit
  sbc #0
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  asl stackbase+1,x ; multiply by two. we know that this won't exceed
  rol stackbase+2,x ; 15 bits so we can stop after two shifts/rolls.

  clc
  lda stackbase+1,x
  adc USEBASE
  sta stackbase+1,x
  lda stackbase+2,x
  adc USEBASE+1
  sta stackbase+2,x
  lda USEBASE+2
  adc #0
  sta stackbase+3,x
  lda USEBASE+3
  adc #0
  sta stackbase+4,x

  ;; copy from buffer to I/O space

  clc               ; source pointer is buffer address plus two
  lda SCRATCH
  adc #2
  sta SCRATCH+2
  lda SCRATCH+1
  adc #0
  sta SCRATCH+3

  ;; copy first 256 bytes
.(
  ldy #0
copyloop
  lda (SCRATCH+2),y
  sta LBLOCK,y
  iny
  cpy #0
  bne copyloop
.)

  inc SCRATCH+3     ; move forward by 256 bytes

  ;; copy second 256 bytes
.(
  ldy #0
copyloop
  lda (SCRATCH+2),y
  sta HBLOCK,y
  iny
  cpy #0
  bne copyloop
.)

  ;; write first sector. removes address from the stack.
  jsr sdsaveblock
  bcs endflush

  ;; copy data for second sector from buffer to I/O space
  inc SCRATCH+3     ; first, bump the source pointer

  ;; copy first 256 bytes
.(
  ldy #0
copyloop
  lda (SCRATCH+2),y
  sta LBLOCK,y
  iny
  cpy #0
  bne copyloop
.)

  inc SCRATCH+3     ; move forward by 256 bytes

  ;; copy second 256 bytes
.(
  ldy #0
copyloop
  lda (SCRATCH+2),y
  sta HBLOCK,y
  iny
  cpy #0
  bne copyloop
.)

  ;; write second sector
  jsr sdsavenext

endflush
  rts
;; end of flushbuf


;;; BLOCK finds a buffer allocated for the block given on the stack
;;; and loads it into memory.
doblock
  jsr blocksub
  jmp next

;;; The actual functionality of BLOCK is broken out into this
;;; subroutine so that it can be easily incorporated into
;;; other words that need it.
blocksub
  ;; make a copy of the buffer number for later reference
  jsr dup16

  ;; allocate a buffer, result left on the stack
  jsr buffersub

  ;; is the block already loaded into that buffer?
  sec               ; subtract two to get to the buffer header
  lda stackbase+1,x
  sbc #2
  sta SCRATCH+2
  lda stackbase+2,x
  sbc #0
  sta SCRATCH+3
  lda (SCRATCH+2)   ; now check the block number from the header
  cmp stackbase+3,x
  bne loadit
  ldy #1
  lda (SCRATCH+2),y
  and #127          ; mask off the dirty bit
  cmp stackbase+4,x
  bne loadit
  jmp loaded

loadit
  ;; clear some working space on the stack
  dex
  dex
  dex
  dex

  ;; at this point, stackbase+1/2/3/4 are my working space (and will
  ;; be a sector numer). stackbase+5/6 is the buffer address.
  ;; stackbase+7/8 is the block number that was passed in.

  ;; make a copy of the block number (subtracting 1, because blocks
  ;; are numbered from one, and we will need to translate this into
  ;; a zero-ranged sector address).
  sec
  lda stackbase+7,x
  sbc #1
  sta stackbase+1,x
  lda stackbase+8,x
  sbc #0
  sta stackbase+2,x

  ;; translate block into a sector number. note that blocks
  ;; are numbered from 1, but we have already subtracted that.
  ;; multiply by two, and add the base address. leave result on
  ;; the stack.
  asl stackbase+1,x
  rol stackbase+2,z
  clc
  lda stackbase+1,x
  adc USEBASE
  sta stackbase+1,x
  lda stackbase+2,x
  adc USEBASE+1
  sta stackbase+2,x
  lda USEBASE+2
  adc #0
  sta stackbase+3,x
  lda USEBASE+3
  adc #0
  sta stackbase+4,x

  ;; load the first sector (512 bytes), removes four byte address
  ;; from the stack
  jsr sdloadblock

  ;; BUG ought to test for load error here

  ;; so now, stackbase+1/2 is the buffer address.
  ;; stackbase+3/4 is the block number that was passed in.

  ;; copy into the buffer
  lda stackbase+1,x ; SCRATCH+2/3 hold destination pointer
  sta SCRATCH+2     ; initially, the buffer pointer
  lda stackbase+2,x
  sta SCRATCH+3

  lda #<LBLOCK      ; SCRATCH+4/5 hold the source pointer
  sta SCRATCH+4     ; initially, LBLOCK
  lda #>LBLOCK
  sta SCRATCH+5

.(
  ldy#0
copyloop
  lda (SCRATCH+4),y
  sta (SCRATCH+2),y
  iny
  cpy #0
  bne copyloop
.)

  inc SCRATCH+3     ; bump destination pointer to next page
  lda #<HBLOCK      ; switch source pointer to HBLOCK
  sta SCRATCH+4
  lda #>HBLOCK
  sta SCRATCH+5
.(
  ldy#0
copyloop
  lda (SCRATCH+4),y
  sta (SCRATCH+2),y
  iny
  cpy #0
  bne copyloop
.)

  ;; load the second sector (512 bytes) for full 1k block
  jsr sdloadnext

  ;; BUG ought to test for load error here...

  inc SCRATCH+3     ; bump destination pointer to next page
  lda #<LBLOCK      ; set source pointer back to LBLOCK
  sta SCRATCH+4
  lda #>LBLOCK
  sta SCRATCH+5

.(
  ldy#0
copyloop
  lda (SCRATCH+4),y
  sta (SCRATCH+2),y
  iny
  cpy #0
  bne copyloop
.)

  inc SCRATCH+3     ; bump destination pointer to next page
  lda #<HBLOCK      ; and source pointer to HBLOCK
  sta SCRATCH+4
  lda #>HBLOCK
  sta SCRATCH+5
.(
  ldy#0
copyloop
  lda (SCRATCH+4),y
  sta (SCRATCH+2),y
  iny
  cpy #0
  bne copyloop
.)

  ;; now that we've successfully loaded the data,
  ;; update the block number in the buffer header
  sec
  lda stackbase+1,x
  sbc #2
  sta SCRATCH+2
  lda stackbase+2,x
  sbc #0
  sta SCRATCH+3
  lda stackbase+3,x
  sta (SCRATCH)
  ldy #1
  lda stackbase+4,x
  sta (SCRATCH),y

loaded
  ;; finish, leaving the buffer data address on the stack
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  inx
  inx
  rts
;; end of blocksub


;;; UPDATE marks the most recently accessed buffer (pointed to by
;;; PREV) as dirty, so that it will be written back if it needs
;;; to be flushed.
doupdate
  ldy #1
  lda (PREV),y
  ora #128
  sta (PREV),y
  jmp next

doprev
  dex
  dex
  lda #<PREV
  sta stackbase+1,x
  lda #>PREV
  sta stackbase+2,x
  jmp next

dofirst
  dex
  dex
  lda #<FIRST
  sta stackbase+1,x
  lda #>FIRST
  sta stackbase+2,x
  jmp next

;;; Flush all buffers that are currently marked as dirty. In
;;; some Forths, this is called SAVE-BUFFERS
dosavebufs
  jsr savebufssub
  bcc endsavebufs

  lda #$43  ; error code three
  jsr puta
  lda #$20
  jsr puta

  jmp abortdiskerror
endsavebufs
  jmp next

;;; this is implemented as a subroutine so that it can be called
;;; from both save-buffers and flush
savebufssub
.(
  dex
  dex
  lda #<FIRST
  sta stackbase+1,x
  lda #>FIRST
  sta stackbase+2,x

bufloop
  lda stackbase+1,x
  sta SCRATCH
  lda stackbase+2,x
  sta SCRATCH+1

  ;; if it's zero'd, skip
  ldy #1
  lda (SCRATCH)
  ora (SCRATCH),y
  beq nextbuffer

  lda (SCRATCH),y   ; test the dirty flag
  and #128
  beq nextbuffer

  jsr flushbuf
  bcs abortsave

  ldy #1            ; clear the dirty flag
  lda (SCRATCH),y
  and #127
  sta (SCRATCH),y

nextbuffer
  jsr plusbuf
  lda stackbase+1,x
  cmp #<FIRST
  bne bufloop
  lda stackbase+2,x
  cmp #>FIRST
  bne bufloop

  inx               ; clean up the stack
  inx
  clc               ; clear carry because no error to signal
  rts

abortsave
  inx
  inx
  sec
  rts
.)

doflush
  dex
  dex
.(
  jsr savebufssub

  lda #<FIRST
  sta stackbase+1,x
  lda #>FIRST
  sta stackbase+2,x
bufloop
  lda stackbase+1,x
  sta stackaccess
  lda stackbase+2,x
  sta stackaccess+1
  lda #0
  ldy #1
  sta (stackaccess)
  sta (stackaccess),y

  jsr plusbuf
  lda stackbase+1,x
  cmp #<FIRST       ; plusbuf loops, so we are done when we
  bne bufloop       ; return to FIRST
  lda stackbase+2,x
  cmp #>FIRST
  bne bufloop
.)
  inx
  inx
  jmp next


;;; Take a buffer pointer on the stack and cycles it to the next
;;; buffer pointer, circling around.
plusbuf
.(
  clc
  lda stackbase+1,x
  adc #<BUFFERSIZE  ; increment to next buffer
  sta stackbase+1,x
  lda stackbase+2,x
  adc #>BUFFERSIZE
  sta stackbase+2,x
  cmp #>LIMIT       ; have we run out of buffers?
  bne done
  lda stackbase+1,x
  cmp #<LIMIT
  bne done

  lda #<FIRST
  sta stackbase+1,x
  lda #>FIRST
  sta stackbase+2,x
done
  rts
.)


;;; Zero out all the buffer space. The mechanism used is not very
;;; efficient but it's designed to be agnostic as to the size of the
;;; buffers or their number -- which is kinda silly because I know
;;; both and they are unlikely to change... but hey, we only call this
;;; once.
zerobuffers
.(
  lda #<FIRST
  sta SCRATCH
  lda #>FIRST
  sta SCRATCH+1

loop
  lda #0
  sta (SCRATCH)
  clc
  lda SCRATCH
  adc #1
  sta SCRATCH
  bcc doneadd
  inc SCRATCH+1
doneadd
  lda SCRATCH
  cmp #<LIMIT
  bne loop
  lda SCRATCH+1
  cmp #>LIMIT
  bne loop

  rts
.)




;;;
;;; *** SCREEN EDITOR
;;;
;;; Basic screen editor for text, using EMACS-like commands.
;;; Assumes 16 rows of 64 characters to fit with block/buffer size,
;;; with nulls filling empty space.
;;;

;;; Just for the editor, relabel a bunch of the scratch space.
temp=SCRATCH
row=SCRATCH+1
col=SCRATCH+2
rowbase=SCRATCH+3 ; and 4
count=SCRATCH+5
upper=SCRATCH+6   ; and 7
lower=SCRATCH+8   ; and 9
jmpvec=SCRATCH+10 ; and 11

NROWS=16
MAXROW=NROWS-1
NCOLS=64
MAXCOL=NCOLS-1
TEXTBASE=SCRATCH+12
TEXTSIZE=NROWS*NCOLS

;;; table of entry points for the commands invoked by each
;;; control-key.
table
  .word tostart     ; a
  .word back        ; b
  .word undefined   ; c
  .word delfwd      ; d
  .word toend       ; e
  .word forw        ; f
  .word undefined   ; g
  .word delback     ; h
  .word undefined   ; i
  .word undefined   ; j
  .word delline     ; k
  .word repaint     ; l
  .word newline     ; m
  .word nextch      ; n
  .word openline    ; o
  .word prev        ; p
  .word undefined   ; q
  .word undefined   ; r
  .word undefined   ; s
  .word undefined   ; t
  .word undefined   ; u
  .word undefined   ; v
  .word undefined   ; w
  .word endedit     ; x
  .word undefined   ; y
  .word undefined   ; z


;;; entry point for the editor. the stack indicates the disk
;;; block to be edited, so we start by calling block to load
;;; it and determine the buffer address.
doedit
  jsr blocksub
  lda stackbase+1,x
  sta TEXTBASE
  lda stackbase+2,x
  sta TEXTBASE+1
  inx               ; clean up the stack
  inx
  phx
  jsr beginedit
  plx
  jmp next

beginedit
  lda #$00      ; initialize rowbase
  sta rowbase
  lda #$60
  sta rowbase+1

  ;; reset variables and screen for startup
  lda TEXTBASE
  sta rowbase
  lda TEXTBASE+1
  sta rowbase+1
  stz row
  stz col

  ;; BUG HACK HORRIBLE
  ;; on loading, convert trailing spaces to NULs and make sure
  ;; that there's a NUL at the end of each line
  lda rowbase
  sta lower
  lda rowbase+1
  sta lower+1
  lda #NROWS
  sta count
.(
nulloop
  ldy #MAXCOL
  lda #0
  sta (lower),y
  dey
spaceloop
  lda (lower),y
  beq checknext
  cmp #32
  beq replace
  cmp #10
  beq replace
  bra finishline
replace
  lda #0
  sta (lower),y
checknext
  dey
  cpy #255
  bne spaceloop  
finishline
  clc
  lda lower
  adc #NCOLS
  sta lower
  lda lower+1
  adc #0
  sta lower+1
  dec count
  lda count
  bne nulloop
.)
  jmp repaint ; repaint jumps back to editloop below

;;; This is the main editor dispatch loop. Fetch a character; if it's
;;; in the command-code range, then look it up in the table; otherwise,
;;; insert it. Everything is done with JMPs and every command JMPs back
;;; to here. Escape is handled with a separate messy routine rather
;;; that a second table.
editloop

  jsr getchar
  cmp #$1B        ; if it's less than 27, it's a control code
  beq escape      ; exactly 27 is escape
  bcs notcmd      ; over 27 is not a command
  dec             ; subtract 1 (to turn it into a 0-ranged value)
  asl             ; shift to multiply by two
  tax             ; that's an offset, so put it in X
  jmp (table,x)   ; invoke the command

notcmd
  jsr insert      ; not a command, so insert the character
  bra editloop

escape
  jsr getchar
  cmp #"f"
  beq escf
  cmp #"b"
  beq escb
  cmp #"["
  beq arrow
  jmp editloop
escf
  jmp fowdword
escb
  jmp backword
arrow
  jsr getchar
  cmp #"A"
  beq arrowup
  cmp #"B"
  beq arrowdown
  cmp #"C"
  beq arrowright
  cmp #"D"
  beq arrowleft
  jmp editloop
arrowup
  jmp prev
arrowdown
  jmp nextch
arrowright
  jmp forw
arrowleft
  jmp back

;;; move forward a word. BUG only really uses spaces as delimiters;
;;; should really use any non-alpha character.
fowdword
.(
  ;; if we are on a space, then find a word
  ldy col
findword
  lda (rowbase),y
  beq endofline
  cmp #$20
  bne findend
  iny
  cpy #MAXCOL
  beq endofline
  bra findword
findend
  ;; now find the end of the word
  lda (rowbase),y
  beq endofline
  cmp #$20
  beq found  
  iny
  cpy #MAXCOL
  bne findend
found  
endofline
  sty col
  jsr moveto
  jmp editloop
.)

backword
.(
  ;; if we are on a space, then find a word
  ldy col
  beq donebackword
findword
  lda (rowbase),y
  beq nextchar
  cmp #$20
  bne findstart
nextchar
  dey
  beq startofline
  bra findword
findstart
  ;; now find the end of the word
  lda (rowbase),y
  beq startofline
  cmp #$20
  beq found  
  dey
  bne findstart
found  
startofline
  sty col
  jsr moveto
donebackword
  jmp editloop
.)


;; for small integers (<100), convert to decimal and output
;; use this for the ansi codes for positioning
todecimal
.(
  ldy #$30
  sty temp  ; temp
convloop
  cmp #$0A
  bmi donedigit
  sec
  sbc #$0A
  inc temp
  bne convloop
donedigit
  tay
  lda temp
  jsr puta
  tya
  clc
  adc #$30
  jsr puta
  rts
.)


;; clear the screen
cls
  lda #$1B  ; esc
  jsr puta
  lda #$5B  ; "["
  jsr puta
  lda #$32  ; "2"
  jsr puta
  lda #$4A  ; "J"
  jsr puta
  rts

;; move cursor to home position
home
  lda #$1B  ; esc
  jsr puta
  lda #$5B  ; [
  jsr puta
  lda #$48  ; H
  jsr puta
  rts

;; clear from current line to bottom of screen
clrtoend
  lda #$1B  ; ESC
  jsr puta
  lda #$5B  ; [
  jsr puta
  lda #$30  ; 0
  jsr puta
  lda #$4A  ; J
  jsr puta
  rts

;; move cursor to current position (stored in row/col).
moveto
  lda #$1B ; ESC
  jsr puta
  lda #$5B ; [
  jsr puta
  lda row  ; row
  inc
  jsr todecimal
  lda #$3B  ; semic
  jsr puta
  lda col  ; col
  inc
  jsr todecimal
  lda #$48  ; H
  jsr puta
  rts

;; add a "+" marker at 65,17 to mark the extent of edit
;; edit region for forth words (16 rows x 64 chars).
addmarker
  lda #$1B ; ESC
  jsr puta
  lda #$5B ; [
  jsr puta
  lda #17
  jsr todecimal
  lda #$3B  ; semic
  jsr puta
  lda #65
  jsr todecimal
  lda #$48  ; H
  jsr puta
  lda #$2b  ; +
  jsr puta
  rts

nextch
.(
  lda row
  cmp #MAXROW ; #$13
  beq donothing
  inc row
.(
  clc
  lda rowbase
  adc #NCOLS ; #$40
  sta rowbase
  bcc doneadd
  inc rowbase+1
doneadd
.)
 jsr moveto
donothing
 jmp editloop
.)

prev
.(
  lda row
  beq donothing
  dec row
  sec
  lda rowbase
  sbc #NCOLS ; #$40
  sta rowbase
  lda rowbase+1
  sbc #$00
  sta rowbase+1
  jsr moveto
donothing
  jmp editloop
.)

back
.(
  lda col
  beq donothing
  dec col
  jsr moveto
donothing
 jmp editloop
.)

forw
.(
  lda col
  cmp #MAXCOL ; #$3F
  beq donothing
  inc col
  jsr moveto
donothing
 jmp editloop
.)

tostart
  stz col
  jsr moveto
  jmp editloop

toend
.(
  ldy #$00
endloop
  lda (rowbase),y
  beq atend
  iny
  cpy #MAXCOL ;#$3F
  beq atend
  bra endloop
atend
  sty col
  jsr moveto
  jmp editloop
.)

delfwd
.(
  ldy     col
delloop
  iny
  lda     (rowbase),y
  dey
  sta     (rowbase),y
  jsr     puta
  beq     done
  iny
  bra   delloop
done
  lda     #$20
  jsr     puta
  jsr     moveto
  jmp     editloop
.)

delback
.(
  lda col
  beq donothing
  dec col
  jsr moveto
  jmp delfwd
donothing
  jmp editloop
.)

insert
  pha
  ldy col
  lda (rowbase),y
  bne notatend
inschar
  pla
  sta (rowbase),y
  jsr puta
  inc col
  jsr moveto
  rts

notatend
  phy
  inc col
  jsr moveto
  dec col
  ply
  ;; move the rest of the line right by one character
  lda (rowbase),y
insloop
  iny
  pha
  lda (rowbase),y
  tax
  pla
  sta (rowbase),y
  jsr puta
  txa
  bne insloop
  iny
  sta (rowbase),y
  jsr moveto
  ldy col
  bra inschar
  lda row
  cmp #MAXROW
  bne newline
  jmp editloop

newline
  ldy col           ; are we at the end of a line?
  lda (rowbase),y
  beq atend         ; if yes
  jmp  breakline    ; if no

atend
.(
  clc               ; reset rowbase to the new line
  lda rowbase
  adc #NCOLS
  sta rowbase
  bcc doneadd
  inc rowbase+1
doneadd        
.)
  lda (rowbase)      ; is this next line empty?
  bne movelines      ; no, so move lines to insert a new one
  inc row            ; yes, so move to it
  stz col
  jsr moveto
  jmp editloop

movelines
  ;; move the rest of the text down by one line
  jsr rippledown

  ;; clear data out of this line
  ldy #MAXCOL
  lda #0
.(
clearloop
  sta (rowbase),y
  dey
  bne clearloop
  sta (rowbase)
.)

  ;; now that the data is in the right place, repaint the screen
  ;; first, clear everything below the current row
  jsr clrtoend
  inc row           ; we haven't done that yet
  jsr moveto

  ;; stash the row count
  lda row
  pha

  ;; now, paint rows that remain
  clc
  lda rowbase
  adc #NCOLS
  sta lower
  lda rowbase+1
  adc #$00
  sta lower+1
  stz col

paintnext
  lda row
  inc
  cmp #NROWS
  beq donerepaint
  sta row
  stz col
  jsr moveto
  jsr paintrow
  clc
  lda lower
  adc #NCOLS
  sta lower
  bcc paintnext
  inc lower+1
  bra paintnext

donerepaint
  pla
  sta row
  jsr addmarker
  jsr moveto

finish
  jmp editloop

breakline ;; BUG   TO BE IMPLEMENTED
  jmp editloop


;; output the text for one row, pointed to by lower. do it
;; directly for faster output without the subroutine call.
paintrow
.(
  phy
  ldy #0
rdyloop
  lda ACIA_STATUS
  and #$10
  beq rdyloop
  lda (lower),y
  beq done
  sta ACIA_DATA
  iny
  cpy #MAXCOL
  beq done
  bra rdyloop
done
  ply
  rts
.)

;;; clear below and print from current row to the bottom of
;;; of the screen. (uses rowbase to point to line)
paintdown
.(
  lda rowbase
  sta lower
  lda rowbase+1
  sta lower+1
  lda row
  pha               ; stash the row count
  lda col
  pha               ; stash the column count
  stz col
paintloop
  jsr moveto
  jsr clrtoend
  jsr paintrow
  lda row
  inc
  cmp #NROWS
  beq endpaint
  sta row
  clc
  lda lower
  adc #NCOLS
  sta lower
  lda lower+1
  adc #0
  sta lower+1
  bra paintloop
endpaint
  pla
  sta col
  pla
  sta row
  jsr addmarker
  jsr moveto
  rts
.)


;;; repaint the whole screen, saving and then restoring cursor position
;;;
repaint
  lda row
  pha
  lda col
  pha
  lda rowbase
  pha
  lda rowbase+1
  pha
  stz row
  stz col
  lda TEXTBASE
  sta rowbase
  lda TEXTBASE+1
  sta rowbase+1
  jsr cls
  jsr home
  jsr paintdown
  jsr addmarker
  pla
  sta rowbase+1
  pla
  sta rowbase
  pla
  sta col
  pla
  sta row
  jsr addmarker
  jsr moveto
  jmp editloop


;;; open a new line
openline
.(
  ldy col
  bne midline
  jsr rippledown
  ldy #0
  lda #0
clearloop
  sta (rowbase),y
  iny
  cpy #MAXCOL
  bne clearloop
  jsr paintdown
  jmp editloop

midline
  ;; still to be implemented
  jmp editloop
.)

;;; move lines down to open up a space. starts from the last line and
;;; works its way down to the current row (rowbase).
rippledown
.(
  ;; find the end of the text area by adding textsize to textbase
  clc
  lda TEXTBASE
  adc #<TEXTSIZE
  sta upper
  lda TEXTBASE+1
  adc #>TEXTSIZE
  sta upper+1

  ;; subtract one line length to get the last line in area
  sec
  lda upper
  sbc #NCOLS
  sta upper
  lda upper+1
  sbc #$00
  sta upper+1

  ;; is that the row we're on now?
  lda upper
  cmp rowbase
  bne continue
  lda upper+1
  cmp rowbase+1
  bne continue
  jmp finish        ;  yes so we are done

continue
  ;; substract one more line length and store in lower
  sec
  lda upper
  sbc #$40
  sta lower
  lda upper+1
  sbc #$00
  sta lower+1

  ;; at this point, we have two pointers, lower and upper,
  ;; which point to two adjacent lines at the end of the buffer.
  ;; we want to reapeatedly copy the contents of lower into
  ;; upper. We do this backwards from the end of the buffer
  ;; so that we are preserving text as it ripples down.
linecopy
  ldy #MAXCOL
charcopy
  lda (lower),y
  sta (upper),y
  dey
  bne charcopy
  lda (lower)   ; copy the last character
  sta (upper)

  sec           ; lower line now becomes upper line
  lda lower     ; and lower moves down by one line
  sta upper
  sbc #NCOLS
  sta lower
  lda lower+1
  sta upper+1
  sbc #$00
  sta lower+1

  lda upper      ; stop when upper hits the new line we're at
  cmp rowbase
  bne linecopy
  lda upper+1
  cmp rowbase+1
  bne linecopy
.)
  rts

;;; move lines up when one line is deleted. starts from rowbase (row
;;; being deleted) up to the end
rippleup
.(
  clc
  lda rowbase
  sta lower         ; set lower to be same as rowbase
  adc #NCOLS        ; and upper to be one row later
  sta upper
  lda rowbase+1
  sta lower+1
  adc #0
  sta upper+1

  clc               ; calculate limit for copying
  lda TEXTBASE
  adc #<TEXTSIZE
  sta jmpvec        ; weird, but just temporary
  lda TEXTBASE+1
  adc #>TEXTSIZE
  sta jmpvec+1

copyrow
  ldy #0
.(
charloop
  lda (upper),y
  sta (lower),y
  cpy #MAXCOL
  beq endofline
  iny
  bra charloop
.)
endofline

  clc               ; move upper to lower, and increment upper
  lda upper         ; by one row
  sta lower
  adc #NCOLS
  sta upper
  lda upper+1
  sta lower+1
  adc #0
  sta upper+1

  lda upper
  cmp jmpvec
  bne copyrow
  lda upper+1
  cmp jmpvec+1
  bne copyrow
  ;; now clear out that last line (now lower)
  ldy #0
  lda #0
loop
  sta (lower),y
  cpy #MAXCOL
  beq done
  iny
  bra loop  
done
.)
  rts


;;; delete line (^K) -- clears the line when there is text, and close
;;; up the line if it's empty.
delline
  ldy col           ; are we at the start of the line?
  bne midline       ; no

  lda (rowbase),y   ; is the line empty?
  beq closeline     ; yes, so close it up

  ;; delete contents of this line (and erase with spaces)
  ldy #0
.(
clearloop
  lda (rowbase),y
  beq endofline
  lda #0
  sta (rowbase),y
  lda #32
  jsr puta
  cpy #MAXCOL
  beq endofline
  iny
  bra clearloop
endofline
  jsr moveto
  jmp editloop
.)

closeline
  jsr rippleup
  jsr paintdown
  jmp editloop

midline
  ;; still to be implemented
  jmp editloop


;; move to bottom of the screen and quit via rts (back to doedit).
;; in an ugly hack, convert nulls to spaces on exit
endedit
  jsr nulltospace
  lda #$12
  sta row
  lda #$00
  sta col
  jsr moveto
  rts

getchar
  lda ACIA_STATUS
  and #$08
  beq getchar
  lda ACIA_DATA
  rts

undefined
  lda #$07          ; BEL (but it doesn't do anything)
  jsr puta
  jmp editloop


;; convert nulls to spaces in the buffer and add newlines
nulltospace
.(
  lda #NROWS
  sta count
  lda TEXTBASE
  sta lower
  lda TEXTBASE+1
  sta lower+1

outerloop
  ldy #63
innerloop
  lda (lower),y
  cmp #32
  beq moveback
  cmp #0
  bne foundit
  lda #32
  sta (lower),y
  bra moveback
foundit
  iny
  lda #10
  sta (lower),y
  bra nextline
moveback
  dey
  cpy #255          ; wrapped around?
  bne innerloop
  lda #10
  sta (lower)
nextline
  clc
  lda lower
  adc #NCOLS
  sta lower
  bcc doneadd
  inc lower+1
doneadd
  dec count
  lda count
  bne outerloop
  rts
.)

  



;;;
;;; *** USER I/O SUPPORT ROUTINES
;;;

puta
.(
  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts

okcrlf
  lda #<ok
  sta PRINTVEC
  lda #>ok
  sta PRINTVEC+1
  jsr printvecstr
  rts

cprompt
  lda #<dots
  sta PRINTVEC
  lda #>dots
  sta PRINTVEC+1
  jsr printvecstr
  rts

crlf
  lda #13
  jsr puta
  lda #10
  jsr puta
  rts




;;;
;;; *** NUMBER READING/PRINTING
;;;
;;; Various conversions to read and print variously-sized numbers
;;; in various formats.
;;;
;;;

;; Look on the stack for the address of a nul-terminated string.
;; Try to interpret that string as a number, and leave that number
;; on the stack. A trailing dot signals that we want it to be a
;; double. If we can't read a number, the stack will be empty
;; and we set Carry on exit.
readsign
  jsr pop16         ; move the string address into stackaccess

  sec               ; create space on the stack for two 32-byte
  txa               ; values.
  sbc #8
  tax

  stz stackbase+1,x ; zero out both 32-bit values
  stz stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x
  stz stackbase+5,x
  stz stackbase+6,x
  stz stackbase+7,x
  stz stackbase+8,x

  lda #6            ; how many bytes to drop at the end, ie, whether
  sta SCRATCH+1     ; we are pushing single or double.

  phy               ; preserve y
  ldy #0            ; y indexes digits of the input string

.(
  ;; first, check if the first character is a minus
  lda (stackaccess),y
  cmp #$2d
  bne checkbase     ; it is not, so proceed as usual
  lda #1            ; set a flag; we'll process this later
  sta SCRATCH
  iny

checkbase
  lda BASE          ; check if we're reading hexadecimal
  cmp #16
  bne nextcheck
  jmp readhex

nextcheck
  lda (stackaccess),y
  cmp #36           ; dollar sign signals a hex number
  bne nextdigit     ; no, so proceed as normal
  iny               ; yes, so skip this character and then
  jmp readhex       ; read as hex

nextdigit
  lda (stackaccess),y
  beq donelastdigit ; ended?

  cmp #$2e          ; dot signals a double
  bne checkdigit
  lda #4
  sta SCRATCH+1
  bra bumpdigit

checkdigit
  cmp #$30
  bcc notnumber
  cmp #$40
  bcs notnumber
  bra processdigit
notnumber
  jmp abortnumread

processdigit

  ;; there is a digit to process. First, multiply our partial result
  ;; by ten (once by 2, once by eight, and then add them).

  asl stackbase+5,x ; shift left to multiply by two
  rol stackbase+6,x
  rol stackbase+7,x
  rol stackbase+8,x

  lda stackbase+5,x ; make a copy in the other temporary slot
  sta stackbase+1,x
  lda stackbase+6,x
  sta stackbase+2,x
  lda stackbase+7,x
  sta stackbase+3,x
  lda stackbase+8,x
  sta stackbase+4,x

  asl stackbase+1,x ; shift the copy left twice more, so x8 in total
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x
  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  clc               ; add them (8x + 2x = 10x)
  lda stackbase+1,x
  adc stackbase+5,x
  sta stackbase+5,x
  lda stackbase+2,x
  adc stackbase+6,x
  sta stackbase+6,x
  lda stackbase+3,x
  adc stackbase+7,x
  sta stackbase+7,x
  lda stackbase+4,x
  adc stackbase+8,x
  sta stackbase+8,x

  sec
  lda (stackaccess),y
  sbc #$30          ; turn from ascii digit into a number
  clc               ; add it to our partial result
  adc stackbase+5,x
  sta stackbase+5,x
  lda stackbase+6,x
  adc #0
  sta stackbase+6,x
  lda stackbase+7,x
  adc #0
  sta stackbase+7,x
  lda stackbase+8,x
  adc #0
  sta stackbase+8,x

bumpdigit
  iny               ; bump the character count
  bra nextdigit     ; and go around again
.)

donelastdigit
  ;; finalize the number. this code is the same regardless of base.
  ;; if we began with a minus, then calculate the two's complement
  ;; of the number we have read.
  lda SCRATCH
  beq finishmult    ; no minus flag set

  ;; first, calculate 1's complement -- flip all bits and add one
  clc
  lda stackbase+5,x
  eor #$ff
  adc #1
  sta stackbase+5,x
  lda stackbase+6,x
  eor #$ff
  adc #0
  sta stackbase+6,x
  lda stackbase+7,x
  eor #$ff
  adc #0
  sta stackbase+7,x
  lda stackbase+8,x
  eor #$ff
  adc #0
  sta stackbase+8,x

finishmult
.(
  ;; check, are we returning a double or a single celled value?
  lda SCRATCH+1
  cmp #4
  beq cleanup
  lda stackbase+5,x ; convert double back to a single
  sta stackbase+7,x
  lda stackbase+6,x
  sta stackbase+8,x

cleanup
  ;; if we need a double, we drop four bytes off the stack. if
  ;; we need a single, we drop six. that's why we use 4 and 6
  ;; as our signals in SCRATCH+1
  txa
  clc
  adc SCRATCH+1
  tax
  ply               ; restore y
.)
  clc               ; signal success
  rts

abortnumread
  clc
  txa
  adc #8
  tax
  ply
  sec               ; signal that we couldn't read a number
  rts
  

;;; read multiple-precision hexadecimal number from the string
;;; pointed to by (stackaccess). y indicates the first character
;;; we care about (potentially after a sign character).
readhex
  ;; if this first character is a $, discard it
  lda (stackaccess),y
  cmp #36
  bne nexthex
  iny
nexthex
.(
  lda (stackaccess),y
  beq doneread

  cmp #$2e          ; is it a "."?
  bne checkdigit

  lda #4            ; it was a dot, so make a note and move on
  sta SCRATCH+1
  iny
  bra nexthex

checkdigit
  ;; not actually doing the check.... oops...

  ;; there is a digit to process. shift our partial result up
  ;; four bits
  asl stackbase+5,x ; first shift
  rol stackbase+6,x
  rol stackbase+7,x
  rol stackbase+8,x
  asl stackbase+5,x ; second shift
  rol stackbase+6,x
  rol stackbase+7,x
  rol stackbase+8,x
  asl stackbase+5,x ; third shift
  rol stackbase+6,x
  rol stackbase+7,x
  rol stackbase+8,x
  asl stackbase+5,x ; fourth shift
  rol stackbase+6,x
  rol stackbase+7,x
  rol stackbase+8,x

  ;; convert digit
.(
  lda (stackaccess),y
  cmp #$60
  bcc isupper
  ;; lower case character, so substract $57
  sec
  sbc #$57
  bra proceed
isupper
  cmp #$40
  bcc isnumber
  ;; upper case character, so substract $37
  sec
  sbc #$037
  bra proceed
isnumber
  ;; numeric character, so subtract $30
  sec
  sbc #$30
proceed
.)
  ;; sanity check?
  pha
  and #%11110000
  beq okay
  pla
  jmp abortnumread

okay
  pla
  ;; add
  clc
  adc stackbase+5,x
  sta stackbase+5,x
  lda stackbase+6,x
  adc #0
  sta stackbase+6,x
  lda stackbase+7,x
  adc #0
  sta stackbase+7,x
  lda stackbase+8,x
  adc #0
  sta stackbase+8,x

  iny
  bra nexthex
doneread
.)
  jmp donelastdigit


;;; this routine to set up the PADPTR is shared by all the
;;; printing routines
initpadptr
  ;; Initialize the PADPTR. We will assemble the string on the
  ;; pad. Leave one space for a count.
  lda #<PAD
  inc               ; space for the count
  sta PADPTR
  lda #>PAD         ; no carry; presume no page boundary
  sta PADPTR+1
  rts

;;; Print a 16-bit number, interpreted as signed, right-aligned in
;;; a field that is as wide as specified on the stack.
rprint16s
  jsr initpadptr

.(
  ;; next, check the most significant bit of the number
  ;; to see if it's negative
  lda stackbase+2,x
  bit #%10000000
  beq nominus

  lda #$2d          ; minus sign
  sta (PADPTR)      ; add it to the string we're assembling
  inc PADPTR

  ;; now calculate the two's complement of the number we have.
  ;; flip all the bits and add one.
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
nominus
.)
  jsr assemble16    ; assemble a 16-bit number on the pad
  jsr pop16         ; pull the field width (presume < 256)
  phy
  sec
.(
  lda stackaccess   ; load field width
  sbc PAD           ; subtract the the string length
  bmi printnum      ; skip spaces if number longer than field
  tay
  lda #$20
  cpy #0
  beq printnum
space
  jsr puta
  dey
  bne space
printnum
.)
  jsr prpadnum
  ply               ; restore Y
  rts

;;; Print a 16-bit number, bearing in mind that it might be negative.
;;; After the initial test for sign, this shares code with the
;;; unsigned print routine and with the right-aligned printing.
;;;
print16s
  jsr initpadptr

.(
  ;; next, check the most significant bit of the number
  ;; to see if it's negative
  lda stackbase+2,x
  bit #%10000000
  beq nominus

  lda #$2d          ; minus sign
  sta (PADPTR)      ; add it to the string we're assembling
  inc PADPTR

  ;; now calculate the two's complement of the number we have.
  ;; flip all the bits and add one.
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
nominus
.)
  jsr assemble16    ; assemble a 16-bit number on the pad
  lda #$20
  jsr puta
  jsr prpadnum      ; print it
  rts


;;; Print a 16-bit quantity interpreted as an unsigned number.
;;; Most of the code here is shared with the signed printing
;;; routine too.
print16u
  jsr initpadptr

  jsr assemble16    ; assemble a 16-bit number on the pad
  lda #$20
  jsr puta
  jsr prpadnum      ; print it
  rts


;;; assemble16 is shared by both the signed and unsigned printing
;;; routine. By the time we get here, we should already have
;;; printed a space and potentially a minus sign.
assemble16
.(
  lda BASE
  cmp #16
  bne continue
  jmp hassemble16
continue
.)
  dex               ; make working space on the stack
  dex
  dex
  
  ;; that leaves the data to be read at stackbase+4,x and stackbase+5,x
  
  stz stackbase+1,x ; These are the bytes in which we'll assemble
  stz stackbase+2,x ; up to five BCD digits. Initialize them to
  stz stackbase+3,x ; zero.

  phy               ; preserve Y
  lda #0
  sed
  ldy #16           ; count of bits we are processing

.(
loop
  asl stackbase+4,x
  rol stackbase+5,x
  lda stackbase+1,x
  adc stackbase+1,x
  sta stackbase+1,x
  lda stackbase+2,x
  adc stackbase+2,x
  sta stackbase+2,x
  rol stackbase+3,x
  dey
  bne loop
.)
  cld

  ;; we have the result in the temporary storage, as BCD. now print that as
  ;; a five-character string (since max is 65535).

  ;; first set a flag to signal whether we've printed anything non-zero
  stz SCRATCH

  txa               ; calculate base address we'll be using
  adc #<stackbase
  sta SCRATCH+2
  lda #>stackbase
  sta SCRATCH+3
  ldy #3

.(
nextbcd             ; go through this loop for each BCD digit
  ;; first, upper four bits
  lda (SCRATCH+2),y
  and #%11110000
  bne prupper       ; not zero, so we definitely print it
  cmp SCRATCH       ; check if we are still suppressing zeros
  beq dolower       ; yes, we are. move on.
prupper
  clc
  ror
  ror
  ror
  ror
  clc
  adc #'0
;  jsr puta          ; print the digit
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

dolower
  lda (SCRATCH+2),y
  and #%00001111
  bne prlower       ; non-zero so we definitely print it
  cmp SCRATCH       ; test for suppressing leading zeros
  beq skip
prlower
  clc
  adc #'0
;  jsr puta          ; print the digit
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

skip
  dey
  bne nextbcd
.)

.(
  lda SCRATCH      ; did we not print anything?
  bne finalize
  lda #$30         ; print a zero
  ;jsr puta
  sta (PADPTR)
  inc PADPTR

finalize
  sec               ; finalize the string count
  lda PADPTR
  sbc #<PAD
  dec               ; remove one
  sta PAD           ; that's the count
  ply               ; restore y

  txa               ; clear five bytes off the stack (three for
  clc               ; working space and two for the parameter)
  adc #5
  tax
.)
  rts

hassemble16
  phy
  ;; number is on the stack
  ;; output to PADPTR
  stz SCRATCH       ; signals if there has been any output yet

  inx               ; nasty stack hackery, watch out!
  jsr h8bits
  dex
  jsr h8bits

finalize
.(
  ;; if we get to the end and haven't outputted a digit, set 0
  lda SCRATCH
  bne done
  lda #'0
  sta (PADPTR)
  inc PADPTR
done
.)
  sec               ; finalize the string count
  lda PADPTR
  sbc #<PAD
  dec               ; remove one
  sta PAD           ; that's the count
  ply               ; restore y

  inx               ; assemble pops this from stack (a little weird)
  inx               ; this should happen in the print routine
  rts

hassemble32
  phy
  stz SCRATCH
  inx
  inx
  inx
  jsr h8bits
  dex
  jsr h8bits
  dex
  jsr h8bits
  dex
  jsr h8bits
  inx               ; pop one cell off the stack (finalize will do the
  inx               ; the other -- this is a mess, clean it up BUG)
  jmp finalize


h8bits
.(
  ;; first digit
  lda stackbase+1,x
  lsr
  lsr
  lsr
  lsr
  tay
  bne continue
  lda SCRATCH
  beq nextdigit
continue
  lda hextable,y
  sta (PADPTR)
  inc PADPTR
  inc SCRATCH
nextdigit
.)

.(
  ;; second digit
  lda stackbase+1,x
  and #15
  tay
  bne continue
  lda SCRATCH
  beq nextdigit
continue
  lda hextable,y
  sta (PADPTR)
  inc PADPTR
  inc SCRATCH
nextdigit
.)
  rts



;; print the counted string on the pad and clean up the stack after print
prpadnum
.(
  phy               ; preserve Y

  ldy #1
printnext
  lda PAD,y
  jsr puta
  cpy PAD
  beq cleanup
  iny
  bra printnext
  
cleanup
  ;; clean up -- reclaim our temporary space and also pop item from stack
  ply              ; restore Y
.)
  rts


;;; print the string pointed to at PRINTVEC
;;;
printvecstr
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda (PRINTVEC),y
  beq endstr
  sta ACIA_DATA
  iny
  bra next_char
endstr
.)
  rts



;;; this is just here because the stack code needs it... should
;;; reoganize my files...
putax
  rts




;;;
;;; *** STRING CONSTANTS
;;;


#ifdef ROM
greeting	 .byte "SECND 6502 Forth v09-ROM", $00
#else
greeting	 .byte "SECND 6502 Forth v09-RAM", $00
#endif
ok:		 .byte "  OK", $0d, $0a, $00
dots:		 .byte "   ...", $0d, $0a, $00
notdefinedmsg:   .byte ": not defined", $00
nestingmsg:	 .byte "  nesting mismatch", $00
compileerr:      .byte "  compile-only word encountered", $00
exitmsg:	 .byte $0d, $0a, $0d, $0a, "Exiting.", $0d, $0a, $00
inityesmsg:      .byte " initialized", $0d, $0a, $00
initnosmsg:      .byte " initialization failed", $0d, $0a, $00
timeoutmsg:      .byte " timeout", $0d, $0a, $00
cardfailmsg:     .byte " couldn't initialize card", $0d, $0a, $00
initializedmsg:  .byte " initialized ", $00
diskerrormsg:    .byte " disk error", $0d, $0a, $00
;readerrormsg:    .byte " read error", $0d, $0a, $00
;writeerrormsg:   .byte " write error", $0d, $0a, $00
dirofmsg:        .byte "Directory of ", $00
nofilemsg:       .byte " no such file", $0d, $0a, $00
bytesfree:       .byte " bytes free", $00
hextable:	 .byte "0123456789ABCDEF"
