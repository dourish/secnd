
;;;
;;; SECND - A FORTH FOR 65C02
;;;
;;; Since "FORTH" is actually an abbreviation of "FOURTH", "SECND"
;;; is an abbreviation of "SECOND", it being my second FORTH
;;; implementation. The last one was over 30 years ago, but let's
;;; not worry about that now. This time, I'm sticking closer to
;;; standards, albeit outdated ones; the starting point for this
;;; is FigFORTH although it has become gradually ANSified along the
;;; way.
;;;
;;; I'm building this for my single-board 65C02 computer, the Mite.
;;; It can run in ROM or RAM; for now, the memory map is built
;;; for a RAM-resident configuration.
;;;
;;; Paul Dourish, December 2017
;;;
;;; Version history:
;;; v01  first basic version of interpreter up and running
;;; v02  adding R-stack operators, variables, arrays, allot.
;;; v03  first steps for compiler, basic lists, strings, loops, conditionals
;;; v04  rounding out vocabulary, linking more internal operations to
;;;      external words, adding nest checking
;;; v05  recursion, double-length arithmetic, pair operations, signed
;;;      arithmetic
;;; v06  cleaning up and debugging, various new words, more internal
;;;      elements available to Forth, performance improvements.
;;; v07  testbed for SD card integration
;;;

  * = $0300

;;;
;;; Variables/space setup
;;;

SCRATCH    = $0010  ; through to $001F (adopted from monitor)

;;; MEMORY MAP
;;;
;;; 0000 through 004F is reserved for the monitor (reusing SCRATCH)
;;; 0050 through 007F is available for variables (below)
;;; 0080 through 00FF is operand stack
;;; 0100 through 01FF is the hardware stack as usual
;;; 0200 through 02FF is the return stack (more space than needed)
;;; 0300 through 1FFF is the interpreter and compiler code (this file)
;;; 2000 through 7BFF is user dictionary space
;;; 7C00 through 7DFF is low-level SD I/O buffer space (512 byte block)
;;; 7E00 through 7EBF is the PAD (string assembly area)
;;; 7EC0 through 7EFF is temporary string processing space
;;; 7F00 through 7FFF is the input buffer (TIB)

;;; 
;;; KEY SYSTEM VARIABLES
;;;
;;; IP is the instruction pointer
;;; DT (dictionary top) pointer to start (actually, end) of dictionary
;;; RP is return stack pointer
;;; XT holds execution token of currently executing word
;;; CODEVEC holds the location of the code for the next instruction
;;; DP holds pointer to the next available dictionary space
;;; TPTR holds the offset of the most recently processed input character
;;; TCNT holds the number of characters held in the buffer
;;; DPTR is an internal variable for traversing the dictionary
;;; STATUS is the system status flags (e.g. compilation flag)
;;; CWORD holds a pointer to the word currently being compiled
;;; SOURCE indicates where input is coming from (0 for terminal)
;;; INPUT points to the input buffer
n;;; WORD points to the temporary string processing space
;;; INBUFF points to the current non-terminal input area
;;; 
;;;
IP=$0050            ; and 0051
RP=$0052            ; and 0053 (return stack pointer)
DT=$0054            ; and 0055 (ptr to top of dictionary)
XT=$0056            ; and 0057
CODEVEC=$0058       ; and 0059
TPTR=$005A
TCNT=$005B
DPTR=$005C          ; and 005D
DP=$005E            ; and 005F (dictionary pointer)
STATUS=$0060        ; status word
CWORD=$0061         ; and 0062 (word currently being compiled)
PADPTR=$0063        ; and 0064 (pointer to text area)
SOURCE=$0065
INBUFF=$0066        ; and 0067
CURSEC=$0068        ; through $0071 (current loaded sector)
RBASE=$0200         ; base for R-stack
PAD=$7E00           ; PAD (string assembly area)
WORD=$7EC0          ; temporary space for parsing words (max 63 chars)
INPUT=$7F00         ; input space
USERBASE=$2800      ; staring address for user code
XRECV=$C4DB         ; address of XMODEM subroutine from monitor
DUMP=$C396          ; address of DUMP subroutine from monitor
LBLOCK=$7C00        ; address of lower I/O data page
HBLOCK=$7D00        ; address of upper I/O data page

MBR=$0200           ; cache SD card master boot record in unused stack space
MBR_NFATS=$0210     ; address of FAT count within cache
MBR_LABEL=$022B     ; address of label within cache

;;; FLAGS AND CONSTANTS
;;;
COMPILE=%00000001   ; status flags
SPI_CMD=64

IMM=%00100000       ; flag for IMMEDIATE word (ie executed in compile mode)

;;; The flags below are left on the stack by the compiler to signal
;;; what sort of clean-up operation is needed at the end of a loop.
;;; They also ensure that nesting is correct.
IFELSEFLAG=$FF      ; left by IF and ELSE
LEAVEFLAG=$FE       ; left by LEAVE
DOFLAG=$FD          ; left by DO
BEGINFLAG=$FC       ; left by BEGIN
WHILEFLAG=$FB       ; left by WHILE


  jmp coldstart     ; jump past code defined in stack routines

#include "../mitemon/decl.a65"
#include "../mitemon/stack.a65"


;;;
;;; Initialization and configuration. This version is running
;;; from RAM, so there's no need to initialize the ACIA. Set up
;;; the stack and the major variables.
;;;
coldstart
  ;; initialize stack...
  jsr initstack

  ;; initialize variables...

  ;; IP is the Forth instruction pointer
  stz IP
  stz IP+1

  stz STATUS        ; turn off compilation
  stz SOURCE        ; input from terminal

  ;; Initialize the return stack. I'm just putting that on page 2, 
  ;; growing downwards, until I have a better idea; I should probably
  ;; combine with some other area because a whole page is much
  ;; more space than needed
  lda #$FF
  sta RP
  lda #>RBASE
  sta RP+1

  ;; Initialize DT to the last entry on the dictionary (below)
  lda #<dtop
  sta DT
  lda #>dtop
  sta DT+1  

  ;; Initialize DP to the first available dictionary space (USERBASE)
  lda #<USERBASE
  sta DP
  lda #>USERBASE
  sta DP+1

  ;; initialize the 6522 for the SD routines
  jsr setup6522

  ;; jump to text interpreter
  jmp startinterp



;;;
;;; DICTIONARY
;;;
;;; Each entry in the dictionary comprises:
;;; - one byte that is both tags (three upper bits) and word length
;;;   five lower bits)
;;; - the characters making up the word definition name
;;; - pointer to next entry
;;; - the "code word" (address of code handling this instruction, which
;;;   will often be DOLIST for compiled words)
;;; - the parameter space (often the list of addresses for executing
;;;   this word, and often ending with EXIT)
;;;

d0entry
  .byte 4
  .byte "exit"
d0link
  .word $0000
exitcode
d0code
  .word exit

d1entry
  .byte 1
  .byte "+"
d1link
  .word d0entry
d1code
  .word doplus

d2entry
  .byte 1
  .byte "*"
d2link
  .word d1entry
d2code
  .word dotimes

d3entry
  .byte 7
  .byte "0branch"
d3link
  .word d2entry
zerobracode
d3code
  .word dozerobra

d4entry
  .byte 4
  .byte "true"
d4link
  .word d3entry
d4code
  .word dotrue

d5entry
  .byte 3
  .byte "lit"
d5link
  .word d4entry
dolitcode
d5code
  .word dolit

d6entry
  .byte 1
  .byte "."
d6link
  .word d5entry
d6code
  .word doprint16

d7entry
  .byte 2
  .byte "<>"
d7link
  .word d6entry
d7code
  .word donotequal

d8entry
  .byte %00100110   ; IMM + code for 6  ;; BUG? no need for immediate
  .byte "branch"
d8link
  .word d7entry
branchcode
d8code
  .word dobranch

d9entry
  .byte 3
  .byte "dup"
d9link
  .word d8entry
d9code
  .word dodup

d10entry
  .byte 4
  .byte "swap"
d10link
  .word d9entry
d10code
  .word doswap

d11entry
  .byte 4
  .byte "drop"
d11link
  .word d10entry
d11code
  .word dodrop

d12entry
  .byte 1
  .byte "/"
d12link
  .word d11entry
d12code
  .word dodiv

d13entry
  .byte 3
  .byte "mod"
d13link
  .word d12entry
d13code
  .word domod

d14entry
  .byte 1
  .byte "="
d14link
  .word d13entry
d14code
  .word doequal

d15entry
  .byte 5
  .byte "depth"
d15link
  .word d14entry
d15code
  .word dodepth

d16entry
  .byte 1
  .byte ">"
d16link
  .word d15entry
d16code
  .word dogreater

d17entry
  .byte 1
  .byte "<"
d17link
  .word d16entry
d17code
  .word doless

d18entry
  .byte 2
  .byte "cr"
d18link
  .word d17entry
crcode
d18code
  .word docr

d19entry
  .byte 4
  .byte "emit"
d19link
  .word d18entry
d19code
  .word doemit

d20entry
  .byte 4
  .byte "over"
d20link
  .word d19entry
d20code
  .word doover

d21entry
  .byte 3
  .byte "rot"
d21link
  .word d20entry
d21code
  .word dorot

d22entry
  .byte 5
  .byte "false"
d22link
  .word d21entry
d22code
  .word dofalse

d23entry
  .byte 1
  .byte "@"
d23link
  .word d22entry
d23code
  .word dofetch

d24entry
  .byte 2
  .byte "c@"
d24link
  .word d23entry
d24code
  .word docfetch

d25entry
  .byte 1
  .byte "!"
d25link
  .word d24entry
d25code
  .word dostore

d26entry
  .byte 2
  .byte "c!"
d26link
  .word d25entry
d26code
  .word docstore

d27entry
  .byte 5
  .byte "cells"
d27link
  .word d26entry
d27code
  .word docells

d28entry
  .byte 8
  .byte "variable"
d28link
  .word d27entry
d28code
  .word dovariable

d29entry
  .byte 1
  .byte "-"
d29link
  .word d28entry
d29code
  .word dominus

d30entry
  .byte 4
  .byte "here"
d30link
  .word d29entry
d30code
  .word dohere

d31entry
  .byte 5
  .byte "allot"
d31link
  .word d30entry
d31code
  .word doallot

d32entry
  .byte 3
  .byte "bye"
d32link
  .word d31entry
d32code
  .word dobye

d33entry
  .byte 1
  .byte ":"
d33link
  .word d32entry
d33code
  .word docolon

d34entry
  .byte %00100001   ; set the immediate bit plus count of 1
  .byte ";"
d34link
  .word d33entry
d34code
  .word dosemic

d35entry
  .byte 2
  .byte ">r"
d35link
  .word d34entry
d35code
  .word dotor

d36entry
  .byte 2
  .byte "r>"
d36link
  .word d35entry
d36code
  .word dofromr

d37entry
  .byte 2
  .byte "r@"
d37link
  .word d36entry
d37code
  .word dorcopy

d38entry
  .byte 1
  .byte "i"
d38link
  .word d37entry
d38code
  .word dorcopy

d39entry
  .byte %00100010   ; IMM flag plus count of two
  .byte $2e, $22    ; dot, quote (.")
d39link
  .word d38entry
dotquotecode
d39code
  .word dodotqu

d40entry
  .byte %00100010   ; IMM flag plus count of two
  .byte "if"
d40link
  .word d39entry
d40code
  .word doif

d41entry
  .byte %00100100   ; IMM flag plus count of four
  .byte "then"
d41link
  .word d40entry
d41code
  .word dothen

d42entry
  .byte %00100101   ; IMM flag plus count of five
  .byte "begin"
d42link
  .word d41entry
d42code
  .word dobegin

d43entry
  .byte %00100101   ; IMM flag plus count of five
  .byte "until"
d43link
  .word d42entry
d43code
  .word dountil  

d44entry
  .byte %00100100   ; IMM plus count of four
  .byte "else"
d44link
  .word d43entry
d44code
  .word doelse

d45entry
  .byte 5
  .byte "words"
d45link
  .word d44entry
d45code
  .word dowords

d46entry
  .byte %00100010   ; IMM plus count of two
  .byte "do"
d46link
  .word d45entry
d46code
  .word dodo

d47entry
  .byte 4
  .byte "(do)"
d47link
  .word d46entry
parendocode
d47code
  .word doparendo

d48entry
  .byte %00100100   ; IMM plus count of four
  .byte "loop"
d48link
  .word d47entry
d48code
  .word doloop

d49entry
  .byte 6
  .byte "(loop)"
d49link
  .word d48entry
parenloopcode
d49code
  .word doparenloop

d50entry
  .byte %00100101   ; IMM plus count of five
  .byte "+loop"
d50link
  .word d49entry
d50code
  .word doplusloop

d51entry
  .byte 7
  .byte "(+loop)"
d51link
  .word d50entry
parplusloopcode
d51code
  .word doparplusloop

d52entry
  .byte 1
  .byte "j"
d52link
  .word d51entry
d52code
  .word doj

d53entry
  .byte 1
  .byte "k"
d53link
  .word d52entry
d53code
  .word dok

d54entry
  .byte 3
  .byte "max"
d54link
  .word d53entry
d54code
  .word domax

d55entry
  .byte 3
  .byte "min"
d55link
  .word d54entry
d55code
  .word domin

d56entry
  .byte 3
  .byte "key"
d56link
  .word d55entry
d56code
  .word dokey

d57entry
  .byte 3
  .byte "and"
d57link
  .word d56entry
d57code
  .word doand

d58entry
  .byte 2
  .byte "or"
d58link
  .word d57entry
d58code
  .word door

d59entry
  .byte 3
  .byte "xor"
d59link
  .word d58entry
d59code
  .word doxor

d60entry
  .byte 2
  .byte "0="
d60link
  .word d59entry
eqlzerocode
d60code
  .word doeqlzero

d61entry
  .byte 2
  .byte "1+"
d61link
  .word d60entry
d61code
  .word do1plus

d62entry
  .byte 2
  .byte "1-"
d62link
  .word d61entry
d62code
  .word do1minus

d63entry
  .byte 2
  .byte "2+"
d63link
  .word d62entry
d63code
  .word do2plus

d64entry
  .byte 2
  .byte "2-"
d64link
  .word d63entry
d64code
  .word do2minus

d65entry
  .byte %00100101   ; IMM plus count of 5
  .byte "leave"
d65link
  .word d64entry
d65code
  .word doleave

d66entry
  .byte 7
  .byte "(leave)"
d66link
  .word d65entry
parenleavecode
d66code
  .word doparenleave

d67entry
  .byte 6
  .byte "invert"
d67link
  .word d66entry
d67code
  .word doinvert

d68entry
  .byte %00100101   ; IMM plus count of five
  .byte "while"
d68link
  .word d67entry
d68code
  .word dowhile

d69entry
  .byte %00100110   ; IMM plus count of six
  .byte "repeat"
d69link
  .word d68entry
d69code
  .word dorepeat

d70entry
  .byte %00100111   ; IMM plus count of seven
  .byte "recurse"
d70link
  .word d69entry
d70code
  .word dorecurse

d71entry
  .byte %00100001   ; IMM plus count of one
  .byte $5c         ; backslash
d71link
  .word d70entry
d71code
  .word dobackslsh

d72entry
  .byte 8
  .byte "constant"
d72link
  .word d71entry
d72code
  .word doconstant

d73entry
  .byte %00100010   ; IMM flag plus count of two
  .byte $73, $22    ; "s", quote (.")
d73link
  .word d72entry
d73code
  .word dosquote

d74entry
  .byte 4
  .byte "(s", $22, ")"
d74link
  .word d73entry
parsquotecode
d74code
  .word dostrlit

d75entry
  .byte 4
  .byte "type"
d75link
  .word d74entry
d75code
  .word dotype

d76entry
  .byte 3
  .byte "s>d"
d76link
  .word d75entry
d76code
  .word dosgltodbl

d77entry
  .byte 2
  .byte "d+"
d77link
  .word d76entry
d77code
  .word doadd32

d78entry
  .byte 2
  .byte "d-"
d78link
  .word d77entry
d78code
  .word dosub32

d79entry
  .byte 2
  .byte "m+
d79link
  .word d78entry
d79code
  .word doaddmix

d80entry
  .byte 2
  .byte "d="
d80link
  .word d79entry
d80code
  .word doeql32

d81entry
  .byte 3
  .byte "d0="
d81link
  .word d80entry
d81code
  .word dozero32

d82entry
  .byte 2
  .byte "m*"
d82link
  .word d81entry
d82code
  .word domultmix

d83entry
  .byte 2
  .byte "d."
d83link
  .word d82entry
d83code
  .word doprint32

d84entry
  .byte 5
  .byte "2swap"
d84link
  .word d83entry
d84code
  .word do2swap

d85entry
  .byte 4
  .byte "2dup"
d85link
  .word d84entry
d85code
  .word do2dup

d86entry
  .byte 5
  .byte "2over"
d86link
  .word d85entry
d86code
  .word do2over

d87entry
  .byte 5
  .byte "2drop"
d87 link
  .word d86entry
d87code
  .word do2drop

d88entry
  .byte 6
  .byte "lshift"
d88link
  .word d87entry
d88code
  .word dolshift

d89entry
  .byte 6
  .byte "rshift"
d89link
  .word d88entry
d89code
  .word dorshift

d90entry
  .byte 2
  .byte "*/"
d90link
  .word d89entry
d90code
  .word dostardiv

d91entry
  .byte 3
  .byte "abs"
d91link
  .word d90entry
d91code
  .word doabs

d92entry
  .byte 6
  .byte "negate"
d92link
  .word d91entry
d92code
  .word donegate

d93entry
  .byte 4
  .byte "pick"
d93link
  .word d92entry
d93code
  .word dopick

d94entry
  .byte 4
  .byte "?dup"
d94link
  .word d93entry
d94code
  .word doquerydup

d95entry
  .byte 2
  .byte "+!"
d95link
  .word d94entry
d95code
  .word doplusstore

d96entry
  .byte 2
  .byte ".s"
d96link
  .word d95entry
d96code
  .word dodots

d97entry
  .byte %00100001   ; IMM plus count of 1
  .byte "("
d97link
  .word d96entry
d97code
  .word docomment

d98entry
  .byte 4
  .byte "/mod"
d98link
  .word d97entry
d98code
  .word dodivmod

d99entry
  .byte 6
  .byte "forget"
d99link
  .word d98entry
d99code
  .word doforget

d100entry
  .byte 1           ; not immediate though, right? BUG
  .byte $27         ; tick
d100link
  .word d99entry
d100code
  .word dotick

d101entry
  .byte 9
  .byte "immediate"
d101link
  .word d100entry
d101code
  .word doimmed

d102entry
  .byte 7
  .byte "dnegate"
d102link
  .word d101entry
d102code
  .word donegate32

d103entry
  .byte 4
  .byte "fill"
d103link
  .word d102entry
d103code
  .word dofill

d104entry
  .byte 1
  .byte "0"
d104link
  .word d103entry
d104code
  .word doloadconst
d104param
  .word $0000

d105entry
  .byte 2
  .byte "u."
d105link
  .word d104entry
d105code
  .word douprint16

d106entry
  .byte 2
  .byte ".r"
d106link
  .word d105entry
d106code
  .word dorprint16

d107entry
  .byte 3
  .byte "d0<"
d107link
  .word d106entry
d107code
  .word dolesszero32

d108entry
  .byte 4
  .byte "dabs"
d108link
  .word d107entry
d108code
  .word doabs32

d109entry
  .byte 2
  .byte "d<"
d109link
  .word d108entry
d109code
  .word doless32

d110entry
  .byte 4
  .byte "dmax"
d110link
  .word d109entry
d110code
  .word dodmax

d111entry
  .byte 4
  .byte "dmin"
d111link
  .word d110entry
d111code
  .word dodmin

d112entry
  .byte 3
  .byte "d.r"
d112link
  .word d111entry
d112code
  .word dorprint32

d113entry
  .byte 5
  .byte "abort"
d113link
  .word d112entry
d113code
  .word abort

d114entry
  .byte 6
  .byte "upload"
d114link
  .word d113entry
d114code
  .word doupload

d115entry
  .byte 4
  .byte "load"
d115link
  .word d114entry
d115code
  .word doload

d116entry
  .byte 4
  .byte "key?"
d116link
  .word d115entry
d116code
  .word dokeyqu

d117entry
  .byte 3
  .byte "nip"
d117link
  .word d116entry
d117code
  .word donip

d118entry
  .byte 4
  .byte "tuck"
d118link
  .word d117entry
d118code
  .word dotuck

d119entry
  .byte 4
  .byte "dump"
d119link
  .word d118entry
dumpcode
d119code
  .word dodump

d120entry
  .byte 5
  .byte "count"
d120link
  .word d119entry
d120code
  .word docount

d121entry
  .byte 5
  .byte "mount"
d121link
  .word d120entry
d121code
  .word domount

d122entry
  .byte 6
  .byte "sendff"
d122link
  .word d121entry
d122code
  .word dosendff

d123entry
  .byte 4
  .byte "cmd8"
d123link
  .word d122entry
d123code
  .word docmd8

d124entry
  .byte 6
  .byte "acmd41"
d124link
  .word d123entry
d124code
  .word doacmd41

d125entry
  .byte 5
  .byte "cmd55"
d125link
  .word d124entry
d125code
  .word docmd55

d126entry
  .byte 4
  .byte "cmd0"
d126link
  .word d125entry
d126code
  .word docmd0

d127entry
  .byte 5
  .byte "cmd58"
d127link
  .word d126entry
d127code
  .word docmd58

d128entry
  .byte 5
  .byte "cmd17"
d128link
  .word d127entry
d128code
  .word docmd17

d129entry
  .byte 9
  .byte "loadblock"
d129link
  .word d128entry
loadblockcode
d129code
  .word doloadblock

d130entry
  .byte 9
  .byte "dumpblock"
d130link
  .word d129entry
d130code
  .word dolist
d130param
  .word loadblockcode
  .word crcode
  .word dolitcode
  .word 31744
  .word dolitcode
  .word 240
  .word dumpcode
  .word exitcode

d131entry
  .byte 3
  .byte "dir"
d131link
  .word d130entry
d131code
  .word dodir

dtop
d132entry
  .byte 4
  .byte "show"
d132link
  .word d131entry
d132code
  .word doshow


;d101entry
;  .byte %00100011   ; IMM plus count of three
;  .byte "?do"
;d101llink
;  d100entry
;d101code
;  .word doqdo
;
;dtop
;d102entry
;  .byte 5
;  .byte "(?do)"
;d102link
;  .word d101entry
;parenqdocode
;d102code
;  .word doparenqdo

;; TOP OF DICTIONARY



;;;
;;; The words below are my experiment on calling things and getting
;;; back to the interpreter. Dummy is the word we'll enter in order to
;;; execute something; the point of it is to make sure that after we've
;;; executed what we want, we run "doquitword", which should take us
;;; back into the interpreter loop
;;;
;;; Once I have the interpreter loop running in a more standard way,
;;; this won't be needed.
;;;


doquitword
  .byte 0
doquitlink
  .word $0000
doquitcode
  .word interploop

dummy
  .byte 0
dummylink
  .word $0000
dummycode
  .word dolist      ; won't actually run this, start with NEXT instead
dummyparam
  .word $0000       ; will write in the actual code link word here
dummyexit
  .word doquitcode





;;;
;;; INNER INTERPRETER
;;;
;;; The three routines below -- NEXT, DOLIST, and EXIT -- are the core
;;; of the inner interpreter, which executes stored words.
;;;
;;; NEXT moves from one instruction to the next inside a defined word.
;;; This code is included at the end of each assembly language routine
;;; (or rather, we jump to it).
;;;
;;; DOLIST begins the execution of a compiled word. It stores the IP
;;; on the return stack, resets the IP to the new word, and then calls
;;; NEXT to start on it.
;;;
;;; EXIT is compiled in as the last address of each compiled word. It
;;; undoes what DOLIST has done, and moves back to the earlier execution
;;; context.
;;;
;;; Note that none of these are subroutines -- everything is connected
;;; as direct jumps (actually, indirect jumps!) with the RSTACK used
;;; to keep track of what's going on.



;;; DOLIST is the executing code for a colon-defined word.
dolist
  ;; first, push the current instruction pointer onto the
  ;; return stack (subroutine unrolled)
  lda IP+1
  sta (RP)
  dec RP
  lda IP
  sta (RP)
  dec RP

  ;; next, grab the first address in the parameter block for this
  ;; colon-defined word. We know that XT points to the code word.
  ;; so we grab that address and then add one cell (two bytes)
  ;; store this in IP.
  clc
  lda XT
  adc #$2
  sta IP
  lda XT+1
  adc #0
  sta IP+1

  ;; IP now points to the next isntruction we want to execute, in
  ;; this word. Proceed to execute it.
  ;jmp next         ; commented out because we can just fall through

;;; ** PUT NOTHING HERE... depending on fall-through from DOLIST to NEXT!

;;; NEXT executes the next word. Before it does the jump, it increments
;;; IP so that IP always designates the next word to be executed.
next
  ldy #1            ; IP points to the location storing the next
  lda (IP)          ; word we need to execute. fetch that location,
  sta XT            ; and store it in XT.
  lda (IP),y
  sta XT+1

  ;; increment IP by two bytes (one cell) before we move on
.(
  clc
  lda IP
  adc #2
  sta IP
  bcc continue
  inc IP+1
continue
.)

  lda (XT),y        ; XT contains a pointer to a code word. Load
  sta CODEVEC+1     ; the code address stored there into CODEVEC.
  lda (XT)
  sta CODEVEC

  jmp (CODEVEC)     ; execute the code for this instruction/word



;;; EXIT is the routine that is called at the end of each colon-defined
;;; word (it's compiled in as the last address to be called). It undoes
;;; DOLIST... it removes an address from the return stack, puts it back
;;; as the instruction pointer, and calls next.
exit
  ;; formerly jsr rpull, now unrolled.
  inc RP            ; take value off return stack and put it in IP
  lda (RP)
  sta IP
  inc RP
  lda (RP)          ; and place it in the instruction pointer
  sta IP+1
  jmp next          ; go execute the next instruction


;;;
;;; PRIMITIVES
;;; Individual routines for each instruction. Most of these are
;;; regular words, whose run-time behaviour is specified here and
;;; at compile-time are simply written in as addresses to the code
;;; words in the dictionary. Some have separate compile-time and
;;; run-time components (e.g. DO and (DO)).

doplus
  jsr add16
  jmp next

dominus
  jsr sub16
  jmp next

dotimes
  jsr mult16
  jmp next

dodiv
  jsr div16
  jmp next

domod
  jsr mod16
  jmp next

dodivmod
  jsr divmod16
  ;; that leaves the stack in a bit of a mess. clean up.
  lda stackbase+1,x ; move modulus from +1 and +3 to +7 and +8
  sta stackbase+7,x
  lda stackbase+2,x
  sta stackbase+8,x
  lda stackbase+3,x ; move quotient from +3 and +4 to +5 and +6
  sta stackbase+5,x
  lda stackbase+4,x
  sta stackbase+6,x
  inx               ; drop working values off the stack, leaving
  inx               ; modulos and quotient in the right places
  inx
  inx
  jmp next

doprint16
  jsr print16s
  jmp next

douprint16
  jsr print16u
  jmp next

dorprint16
  jsr swap16        ; pull number to be printed to the top
  jsr rprint16s
  jmp next

doprint32
  jsr print32s
  jmp next

dorprint32
  ;; top cell is the field width. next two cells down are the
  ;; double-length number. Do a custom rotation.
  lda stackbase+2,x ; push top cell onto hardware stack, MSB first
  pha
  lda stackbase+1,x
  pha
  lda stackbase+3,x ; move double-word from +3 through +6 to
  sta stackbase+1,x ; +1 through +4
  lda stackbase+4,x
  sta stackbase+2,x
  lda stackbase+5,x
  sta stackbase+3,x
  lda stackbase+6,x
  sta stackbase+4,x
  pla               ; restore field width from hardware stack
  sta stackbase+5,x ; but tuck it under the double word
  pla
  sta stackbase+6,x
  jsr rprint32s
  jmp next

docr
  jsr crlf
  jmp next

dodup
  jsr dup16
  jmp next

dodrop
  jsr pop16
  jmp next

doswap
  jsr swap16
  jmp next

;;; Implements PICK. When given a parameter over, say, 64, this is
;;; likely to go very wrong.
dopick
  jsr pop16         ; pop value off the stack
  asl stackaccess   ; multiply by two to convert to bytes
  rol stackaccess+1
  clc
  lda stackaccess   ; add that to stackbase
  adc #<stackbase
  sta stackaccess
  lda stackaccess+1
  adc #>stackbase
  sta stackaccess+1
  clc
  txa               ; now add X + 1
  inc
  adc stackaccess
  sta stackaccess
  lda stackaccess+1
  adc #0
  sta stackaccess+1

  dex
  dex
  ldy #0
  lda (stackaccess),y
  sta stackbase+1,x
  iny
  lda (stackaccess),y
  sta stackbase+2,x

  jmp next 


doquerydup
.(
  lda stackbase+1,x
  ora stackbase+2,x
  beq done
  jsr dup16
done
  jmp next
.)

dorshift
.(
  jsr pop16         ; max is 32 by standard
  ldy stackaccess
loop
  lsr stackbase+2,x ; going right, so start with MSB
  ror stackbase+1,x
  dey
  bne loop
.)
  jmp next

dolshift
.(
  jsr pop16         ; max is 32 by standard
  ldy stackaccess
loop
  asl stackbase+1,x ; going left, so start with LSB
  rol stackbase+2,x
  dey
  bne loop
.)
  jmp next

doequal
.(
  lda stackbase+1,x
  cmp stackbase+3,x
  bne notequal
  lda stackbase+2,x
  cmp stackbase+4,x
  bne notequal
equal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp settrue
notequal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp setfalse
.)


donotequal
.(
  lda stackbase+1,x
  cmp stackbase+3,x
  bne notequal
  lda stackbase+2,x
  cmp stackbase+4,x
  bne notequal
equal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp setfalse
notequal
  inx               ; drop one cell off stack (we'll fill in the other)
  inx
  jmp settrue
.)


;;; No 16-bit comparisons, so for signed arithmetic, we basically
;;; have to do a subtraction and then test for overflow. this
;;; routine is borrowed from fig6502 and I'm still not sure what
;;; the EOR is for, if anything.
dogreater
.(
  sec
  lda stackbase+1,x
  sbc stackbase+3,x
  lda stackbase+2,x
  sbc stackbase+4,x
  bvc there
  eor #$80
there
  bpl here
  inx
  inx
  jmp settrue
here
  inx
  inx
  jmp setfalse
.)


;;; See dogreater above.
doless
.(
  sec
  lda stackbase+3,x
  sbc stackbase+1,x
  lda stackbase+4,x
  sbc stackbase+2,x
  bvc there
  eor #$80
there
  bpl here
  inx
  inx
  jmp settrue
here
  inx
  inx
  jmp setfalse
.)


dodepth
  stx SCRATCH
  lda #$ff
  sec
  sbc SCRATCH
  clc
  lsr               ; shift right to divide by two
  stz stackbase,x
  dex
  sta stackbase,x
  dex
  jmp next

doemit
  lda stackbase+1,x
  jsr puta
  inx
  inx
  jmp next

;;; Implements OVER. We do everything inline here rather than using
;;; push and poop.
doover
  dex
  dex
  lda stackbase+5,x
  sta stackbase+1,x
  lda stackbase+6,x
  sta stackbase+2,x
  jmp next

;;; Implements ROT. We do everything inline here rather than using
;;; push and pop.
dorot
  dex               ; make some new space on the stack temporarily
  dex
  lda stackbase+7,x ; first, copy the item from three down on the stack
  sta stackbase+1,x ; into the new space
  lda stackbase+8,x ; so, 7/8 -> 1/2
  sta stackbase+2,x

  lda stackbase+5,x ; now move everything back
  sta stackbase+7,x ; first, 5/6 -> 7/8
  lda stackbase+6,x
  sta stackbase+8,x
  lda stackbase+3,x ; then 3/4 -> 5/6
  sta stackbase+5,x
  lda stackbase+4,x
  sta stackbase+6,x
  lda stackbase+1,x ; then 1/2 -> 3/4
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x

  inx               ; clean up
  inx

  jmp next


;;; DOLIT is the run-time code for literal values. Read the contents of
;;; the next parameter as a value to be pushed onto the stack.
;;; We enter with IP indicating the literal value; we increment IP
;;; by two bytes (one cell) so that skips to the next instruction to be
;;; executed. Since this is a very frequently executed routine, 
;;; the push is unrolled rather than doing a jsr push16.
;;; 
;;; (wouldn't "(literal)" be a more consistent name for this?)
dolit
  dex               ; make space on the stack
  dex
  lda (IP)          ; load the value at the instruction pointer
  sta stackbase+1,x
  ldy #1            ; and MSB
  lda (IP),y
  sta stackbase+2,x

.(
  clc
  lda IP            ; increment IP to next cell (which stores the value)
  adc #2
  sta IP
  bcc continue
  inc IP+1
continue
.)

  jmp next
  

;;; dostrlit is the run-time behaviour for S" (ie, string literal). Loads
;;; string address and string length onto the stack.
dostrlit
  lda IP           ; IP points to the string address
  sta stackaccess  ; so store in stackaccess
  lda IP+1
  sta stackaccess+1
  jsr push16       ; add to the data stack
  
  lda (IP)         ; load the length count
  sta stackaccess
  stz stackaccess+1 ; max 255 characters in a string
  jsr push16

  lda (IP)         ; load the count again
  inc              ; add one to get number of bytes to skip
  clc              ; bump IP past the string constant
  adc IP
  sta IP
  lda IP+1
  adc #0
  sta IP+1

  jmp next         ; done

;;; dovaddr is the internal code for variables... look up the current
;;; XT and use it to find the address reserved for the variable, and
;;; push that. (Similarly this should perhaps be called "(VARIABLE)").
dovaddr
  dex               ; make space on the stack
  dex
  clc
  lda XT            ; find the param space, two bytes after the XT
  adc #2
  sta stackbase+1,x ; and store it on top of the stack
  lda XT+1          ; same for MSB
  adc #0
  sta stackbase+2,x
  jmp next

;;; As above, but for constants, so we don't load the address,
;;; but the value.
doloadconst
  dex               ; make some space on the stack
  dex
  ldy #2            ; looking at (XT)+2 (param space)
  lda (XT),y        ; load LSB
  sta stackbase+1,x ; straight onto the stack
  iny
  lda (XT),y        ; MSB
  sta stackbase+2,x
  jmp next          ; done
  


;;; dofetch is the code for "@". Pull an address off the stack and
;;; look up the 16-bit data stored at that address
dofetch
  lda stackbase+1,x ; don't actually pop the address, just grab it
  sta stackaccess
  lda stackbase+2,x
  sta stackaccess+1
  ldy #1
  lda (stackaccess)  ; load MSB and store on stack
  sta stackbase+1,x  ; store back on the stack
  lda (stackaccess),y  ; then LSB
  sta stackbase+2,x
  jmp next

;;; docfetch implements c@ -- same as dofetch but loads just one byte
docfetch
  lda stackbase+1,x ; don't actually pop the address, just grab it
  sta stackaccess
  lda stackbase+2,x
  sta stackaccess+1
  lda (stackaccess) ; grab single byte at the address
  sta stackbase+1,x ; and store in LSB
  jsr pop16         ; pop address into stackaccess
  dex               ; make space on the stack
  dex
  stz stackbase+2,x ; set MSB to zero
  jmp next


;;; dostore is the code for "!". Pull an address of the stack as in
;;; dofetch; but store the address pointed to by the next stack
;;; location in it.
dostore
  jsr pop16         ; put address into stackaccess
  ldy #1
  lda stackbase+1,x  ; load LSB off stack and
  sta (stackaccess)    ; store at location we popped
  lda stackbase+2,x    ; then for MSB
  sta (stackaccess),y  ; with y=1
  inx               ; drop the value from the stack
  inx
  jmp next

;;; doplusstore is the code for +!
doplusstore
  jsr pop16         ; put address into stackaccess
  clc
  ldy #1
  lda stackbase+1,x  ; load LSB off stack and
  adc (stackaccess)
  sta (stackaccess)    ; store at location we popped
  lda stackbase+2,x    ; then for MSB
  adc (stackaccess),y
  sta (stackaccess),y  ; with y=1
  inx               ; drop the value from the stack
  inx
  jmp next


;;; cstore implements "c!" - like store but just one byte (LSB from stack)
docstore
  jsr pop16         ; put address into stackaccess
  lda stackbase+1,x ; load LSB off stack and
  sta (stackaccess) ; store at location we popped
  inx               ; drop the value from the stack
  inx
  jmp next


;;; Turn an integer count of cells into a count of bytes. Since
;;; my cells are two bytes, that means multiplying item on top of
;;; stack by two (shift left).
docells
  asl stackbase+1,x
  rol stackbase+2,x
  jmp next


;;; variable reads the next word from input and allocates space
;;; for it in the dictionary as a variable (ie with the "dovaddr"
;;; code).
dovariable
  ;; grab next word from the input buffer
  jsr readnext      ; next word from input buffer into WORD
 
  ;; copy word from WORD
  lda WORD          ; first, copy the count
  sta (DP)
  tay               ; store count in Y
.(
copynext            ; now copy the rest of the word, backwards
  lda WORD,y        ; copy Yth letter
  sta (DP),y        ; store it in dictionary space
  dey               ; count down to 0
  bne copynext
.)

  lda (DP)          ; set Y to next available byte
  tay
  iny

  ;; set link to location pointed to by DT
  lda DT
  sta (DP),y
  iny
  lda DT+1
  sta (DP),y
  iny

  ;; set code to dovaddr
  lda #<dovaddr
  sta (DP),y
  iny
  lda #>dovaddr
  sta (DP),y
  iny

  iny               ; bump twice more to allow parameter space
  iny               ; for storage

  ;; set DT to new top entry, the one we've just created here
  lda DP
  sta DT
  lda DP+1
  sta DT+1

.(
  clc               ; update DP to next available space
  tya               ; by adding bytes consumed to DP
  adc DP
  sta DP
  bcc continue
  inc DP+1
continue
.)
 
  jmp next

;;; constant reads the next word from input and allocates space
;;; for it in the dictionary as a constant (just like variable
;;; above, except that the code will do something different).
;;; BUG shares so much code with above, we should reuse
doconstant
  ;; grab next word from the input buffer
  jsr readnext      ; next word from input buffer into WORD
 
  ;; copy word from WORD
  lda WORD          ; first, copy the count
  sta (DP)
  tay               ; store count in Y
.(
copynext            ; now copy the rest of the word, backwards
  lda WORD,y        ; copy Yth letter
  sta (DP),y        ; store it in dictionary space
  dey               ; count down to 0
  bne copynext
.)

  lda (DP)          ; set Y to next available byte
  tay
  iny

  ;; set link to location pointed to by DT
  lda DT
  sta (DP),y
  iny
  lda DT+1
  sta (DP),y
  iny

  ;; set code to doloadconst
  lda #<doloadconst ; one of only two lines different from above
  sta (DP),y
  iny
  lda #>doloadconst ; and this is the other one
  sta (DP),y
  iny

  ;; now load a word from the stack and copy it into the
  ;; space for the constant value
  lda stackbase+1,x
  sta (DP),y
  iny
  lda stackbase+2,x
  sta (DP),y
  iny
  inx               ; drop two bytes (one cell) from the stack
  inx               

  ;; set DT to new top entry, the one we've just created here
  lda DP
  sta DT
  lda DP+1
  sta DT+1

.(
  clc               ; update DP to next available space
  tya               ; by adding bytes consumed to DP
  adc DP
  sta DP
  bcc continue
  inc DP+1
continue
.)
 
  jmp next


;;; dohere implements "HERE" and just returns the pointer to the next
;;; available dictionary spot.
dohere
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16
  jmp next


;;; ALLOT takes a number of bytes and bumps DP, which makes that many
;;; bytes available to whatever is at the top of the dictionary. It's
;;; used to allocate array space to variables.
doallot
  jsr pop16
  clc
  lda DP
  adc stackaccess
  sta DP
  lda DP+1
  adc stackaccess+1
  sta DP+1
  jmp next


;;; Leave the system after printing a termination message. This
;;; just ends with an RTS, which should take us back to the monitor
;;; if we were called that way, or will crash things if we weren't,
;;; which has the same effect!
dobye
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda exitmsg,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
  rts
.)

;;; rcopy (for the Forth word "R") -- copy top of R stack onto data stack
;;; this code also implements I (since it's the same thing).
dorcopy
  dex               ; make space on user stack
  dex
  ldy #1
  lda (RP),y        ; LSB of top value on return stack
  sta stackbase+1,x ; add to user stack
  iny
  lda (RP),y        ; and then again for MSB
  sta stackbase+2,x
  jmp next


;;; j copies immediately outer loop value (basically, third item down
;;; on the return stack)
doj
  dex               ; make space on user stack
  dex
  ldy #5            ; get data from bytes 5 and 6 (third value down)
  lda (RP),y        ; LSB of value on return stack
  sta stackbase+1,x ; add to user stack
  iny
  lda (RP),y        ; and then again for MSB
  sta stackbase+2,x
  jmp next


;;; k copies second outer loop value (basically, fifth item down
;;; on the return stack)
dok
  dex               ; make space on user stack
  dex
  ldy #9            ; get data from bytes 9 and 10 (fifth value down)
  lda (RP),y        ; LSB of value on return stack
  sta stackbase+1,x ; add to user stack
  iny
  lda (RP),y        ; and then again for MSB
  sta stackbase+2,x
  jmp next


;; dotor (for the Forth word ">R" -- move from top of stack onto r-stack
;;;
dotor
  ;jsr pop16
  ;jsr rpush
  lda stackbase+2,x
  sta (RP)
  dec RP
  lda stackbase+1,x
  sta (RP)
  dec RP            ; BUG presumes that RP doesn't roll over page boundary
  inx
  inx
  jmp next


;; dofromr (for Forth word "R>" -- move from r-stack to top of stack
;;;
dofromr
;  jsr rpull
  dex
  dex
  inc RP
  lda (RP)
  sta stackbase+1,x
  inc RP
  lda (RP)
  sta stackbase+2,x
  jmp next

;;; docolon implements the colon-word... basically, acts like
;;; variable in that it opens up a dictionary word, althogh this
;;; time for a dolist definition. Also, it sets the compile flag.
;;;
;;; NB things will go wrong if we enconter a colon inside a colon
;;; definition or start to process variables or something. We presume
;;; that nothing is going to mess with DP while compilation is in
;;; progress.
;;;
docolon
  ;; first, set the compiler flag
  lda STATUS
  ora #COMPILE
  sta STATUS

  ;; grab next word from the input buffer
  jsr readnext      ; next word from input buffer into WORD
 
  ;; copy word from WORD
  lda WORD          ; first, copy the count
  sta (DP)
  tay               ; store count in Y
.(
copynext            ; now copy the rest of the word, backwards
  lda WORD,y        ; copy Yth letter
  sta (DP),y        ; store it in dictionary space
  dey               ; count down to 0
  bne copynext
.)

  lda (DP)          ; set Y to next available byte
  tay
  iny

  ;; set link to location pointed to by DT
  lda DT
  sta (DP),y
  iny
  lda DT+1
  sta (DP),y
  iny

  ;; set code to dolist
  lda #<dolist
  sta (DP),y
  iny
  lda #>dolist
  sta (DP),y
  iny

  lda DP            ; cache the address of the word we're now compiling
  sta CWORD         ; we wait until we're done (dosemic) before we update
  lda DP+1          ; the top-of-dictionary pointer
  sta CWORD+1

  clc               ; update DP to next available space
  tya               ; by adding bytes consumed to DP
  adc DP
  sta DP
  lda DP+1
  adc #0
  sta DP+1
 
  jmp next           ; not sure which of these is right...
  ;jmp interploop    ; in the compiler, we don't execute NEXT


;;; do-semi-colon, ie, tidy up when we're finishing compiling a word
;;;
dosemic
  ;; turn off the compiler
  lda STATUS
  and #%11111110
  sta STATUS

  ;; add call to exit at the end of the entry
  ldy #0
  lda #<exitcode
  sta (DP),y
  iny
  lda #>exitcode
  sta (DP),y

  ;; update DP for those two last bytes
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  ;; set DT to new top entry, the word we've just finished compiling
  lda CWORD
  sta DT
  lda CWORD+1
  sta DT+1

  jmp next


;;; Do dot-quote. I'm not entirely happy with my solution for this yet.
;;; This word has three different context-dependent behaviors:
;;; 1. when we are compiling (determined by compiler flag), assemble
;;;    string from the text stream and compile it into the word.
;;; 2. when we are called as part of a regular execution cycle, print
;;;    the word that's compiled in following this instruction.
;;; 3. when we are running in the interpreter, as determined by IP
;;;    pointing to the dummy word, assemble the string that follows
;;;    in the input buffer and print it.
dodotqu
.(
  ;; are we compiling?
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; Yes. compile it (case 1)
  ;; first, add in the execution word
  lda #<dotquotecode
  sta (DP)
  ldy #1
  lda #>dotquotecode
  sta (DP),y

  ;; then update DP by 2, to account for that word
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  ;; next, assemble the string on the PAD
  jsr assemblestr

  ;; now we copy it into space where we are comping, pointed to by DP.
  lda PAD           ; first, copy the length
  sta (DP)

  tay               ; now copy the rest of the string (backwards)
charloop
  lda PAD,y
  sta (DP),y
  dey
  bne charloop

  ;; now update DP to account for the string
  clc
  lda PAD           ; that's the length count for the string
  inc               ; add one for the count byte
  adc DP            ; bump DP by that many bytes
  sta DP
  lda DP+1
  adc #$0
  sta DP+1

  jmp next          ; and proceed. we're done.

nocompile
  ;; are we interactive?
  ;; we can tell if IP points to dummyexit
  lda IP
  cmp #<dummyexit
  bne nointerp
  lda IP+1
  cmp #>dummyexit
  bne nointerp

  ;; Yes, so we need the interactive behaviour (case 3)

  ;; first. assemble the string to be printed
  jsr assemblestr

  ;; now print it
  ;; but first, write in a space over the length indicator,
  ;; which we don't need because it's null-terminated
  lda #$20
  sta PAD

  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda PAD,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
.)

  jmp next          ; we're done so proceed to next instruction

nointerp
  ;; Finally, this is the regular behavior (case 2). We're executing
  ;; from a compiled word. So IP points to a counted string. Print
  ;; it, and increment the instruction pointer appropriately.

.(
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda #$20          ; print a space to begin
  sta ACIA_DATA
.)

  phx               ; save X, since we're about to use it
  lda (IP)          ; load the string length
  tax               ; transfer to X. X counts down as Y counts up
  ldy #1

  ;; now print X characters 
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda (IP),y
  sta ACIA_DATA
  iny
  dex
  bne next_char
done
.)

  plx               ; restore X

  ;; finally, update the instruction pointer
  ;; Y is the number of characters plus one (because of the last iny)
  ;; so that's actually just the right number to add to the IP.
.(
  tya               ; transfer Y to A and add it to IP
  clc
  adc IP            ; LSB
  sta IP
  bcc continue
  inc IP+1          ; MSB in case of carry
continue
.)
.)

  jmp next          ; continue to the next instruction


;;; This is the compiler behavior for S"; it compiles dostrlit
;;; and an inline string constant. (do-s-quote)
dosquote
  ldy #1
  lda #<parsquotecode
  sta (DP)
  lda #>parsquotecode
  sta (DP),y

  ;; then update DP by 2, to account for that word
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  jsr assemblestr   ; read and assemble string from input

  ;; now we copy it into space where we are comping, pointed to by DP.
  ;; BUG this code is shared with dodotqu, so factor it out. I think
  ;; it is technically $,"... yeah?
  lda PAD           ; first, copy the length
  sta (DP)

  tay               ; now copy the rest of the string (backwards)
charloop
  lda PAD,y
  sta (DP),y
  dey
  bne charloop

  ;; now update DP to account for the string
  clc
  lda PAD           ; that's the length count for the string
  inc               ; add one for the count byte
  adc DP            ; bump DP by that many bytes
  sta DP
  lda DP+1
  adc #$0
  sta DP+1

  jmp next          ; done


;;; Read text from the input buffer up until a single quote mark
;;; and assemble it onto the PAD. At the end, we'll have a string
;;; that is both counted and null-terminated. This is used in both
;;; compile mode and run mode of dotquote and in S".
assemblestr

  ;; first, set up the PAD ptr
  lda #<PAD
  sta PADPTR
  lda #>PAD
  sta PADPTR+1

.(
  ;; read the next word into WORD
continue
  jsr readnext

  ;; is it a closing quote? count of 1, char is $22
  lda WORD
  cmp #$01          ; check the string length
  bne assemble
  lda WORD+1        ; we know it's a single-character string
  cmp #$22          ; check the single character
  beq finished

assemble
  ;; concatenate onto the string we're assembling at PAD
  lda #$20          ; space
  sta (PADPTR)
  ldy WORD          ; the character count
.(
nextchar
  lda WORD,y
  sta (PADPTR),y    ; Y is off-by-one but it's okay (leading space)
  dey
  bne nextchar
.)

  ;; update PADPTR
.(
  lda WORD          ; length of this most recent word
  inc               ; plus leading space
  clc
  adc PADPTR
  sta PADPTR        ; update the pointer
  bcc skipmsb
  inc PADPTR+1      ; in case we generated a carry...
skipmsb
.)

  ;; update count
  sec               ; BUG this will stop working if PAD crosses word boundary
  lda PADPTR
  sbc #<PAD
  dec               ; subtract one (don't count the count byte itself)
  sta PAD

  bra continue
.)
finished
  ;; add a null at the end of the string
  lda #$00
  sta (PADPTR)

  rts


;;; discardcomment reads from the input buffer until it finds
;;; the end-of-comment marker. Somewhat like assemblestr except
;;; that there is no assembly.
discardcomment
.(
continue
  jsr readnext

  lda WORD
  cmp #$01
  bne continue
  lda WORD+1
  cmp #$29          ; 0x29 is closing parenthesis
  bne continue

  rts
.)


;;; dotype implements TYPE. Reads a count and a string address from the
;;; stack and prints the number of characters indicated in the count.
dotype
  jsr pop16
  ldy stackaccess   ; put the count in Y
  jsr pop16         ; fetch the string address
  cpy #0
  beq endtype       ; stop now if the count was 0

  phx               ; save X temporarily

  tya               ; move Y into X (via A)
  tax
  ldy #1            ; start Y at 1 (to skip count byte)
typenext
  lda (stackaccess),y
  jsr puta
  iny
  dex
  bne typenext
  plx               ; restore X

endtype
  jmp next

;;; 0branch is an internal word used for conditionals. Test top of stack,
;;; and if false, add the next parameter (ie instruction offset) to the
;;; IP. When we come in, the IP is pointing to the branch address,
;;; so that is the position from which the offset is to be calculated.
dozerobra
  jsr pop16         ; pull value off the top of the stack
  lda stackaccess   ; test for zero
  ora stackaccess+1
  beq dobranch      ; if it's zero, then jump to branch code

nonzero
  ;; otherwise we will continue with processing, but first,
  ;; increment IP to skip the branch offset.
.(
  clc
  lda IP
  adc #2
  sta IP
  bcc skipmsb
  inc IP+1
skipmsb
.)

  jmp next          ; all done, proceed to next instruction


;;; dobranch is used by ELSE; does an immediate branch. So, it's just
;;; like 0branch if the top stack value is 0; in fact, 0branch calls
;;; this code in that case
dobranch
  ldy #1  
  lda (IP),y        ; load offset and cache it on the stack
  pha               ; do MSB first because we want to pull
  lda (IP)          ; LSB first
  pha

  clc               ; now add the cached offset to the IP
  pla
  adc IP
  sta IP
  pla
  adc IP+1
  sta IP+1

  jmp next


;;; doif is an immediate word that compiles IF.
;;; compile it into a 0bra, and put the address of the branch word
;;; onto the stack. Pesume that THEN will later come back
;;; and fix up the address
;;;
doif
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  lda #<zerobracode
  sta (DP)
  ldy #1
  lda #>zerobracode
  sta (DP),y

  ;; bump DP by two (to move on to the branch address location)
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  ;; put that on the stack so that ELSE or THEN can find it later
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  ;; add the IFELSEFLAG to the stack
  lda #IFELSEFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

  ;; bump DP by two again (to move to next instruction space)
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  jmp next

nocompile
  jmp abortcompile
.)


;;; This is the compiler behavior for THEN. We look on the stack for
;;; address of the branch offset, then calculate the offset and
;;; write it in.
;;;
;;; BUG should exit with error if we're not in compile mode
dothen
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; pop the flag from the stack and make sure it's an IFELSEFLAG
  jsr pop16
  lda stackaccess
  cmp #IFELSEFLAG
  beq thenproceed

  jmp abortnest

thenproceed
  ;; take the current DP pointer, and subtract from it the value on
  ;; the stack. The result is the offset that should be stored in
  ;; the word pointed to by the item on the stack. Pop it from the stack.

  jsr pop16         ; pop branch address into stackaccess

  sec               ; calculate offset
  lda DP
  sbc stackaccess
  sta SCRATCH
  lda DP+1
  sbc stackaccess+1
  sta SCRATCH+1

  lda SCRATCH       ; write it into the branch instruction
  sta (stackaccess)
  ldy #1
  lda SCRATCH+1
  sta (stackaccess),y

nocompile
  jmp next          ; done. proceed to next instruction.
.)


;;; doelse is the compiler behavior for ELSE. Like THEN, it updates
;;; the prior branch address that's been left on the stack. Like IF,
;;; it compiles in a branch (not 0branch this time) and leaves an address
;;; on the stack for THEN to fill in.
;;;
;;; BUG doesn't check for compiler
doelse
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; First, pop the flag off the stack and ensure it's the IFELSEFLAG.
  jsr pop16
  lda stackaccess
  cmp #IFELSEFLAG
  beq elseproceed
  jmp abortnest
  
elseproceed

  ;; Next, compile in the branch instruction and keep a copy of
  ;; the branch address to be put on the stack in a moment.
  ;; this way, a successful IF clause should hit a branch that causes
  ;; it to jump to the end (skipping the ELSE clause)
  lda #<branchcode
  sta (DP)
  ldy #1
  lda #>branchcode
  sta (DP),y

.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  lda DP            ; cache this address for a moment
  sta SCRATCH+2
  lda DP+1
  sta SCRATCH+3

.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  ;; Next, do the THEN-like behavior and update the address left by IF.
  ;; Take the current DP pointer, and subtract from it the value on
  ;; the stack. The result is the offset that should be stored in
  ;; the word pointed to by the item on the stack. Pop it from the stack.

  jsr pop16         ; pop branch address into stackaccess

  sec               ; calculate offset
  lda DP
  sbc stackaccess
  sta SCRATCH
  lda DP+1
  sbc stackaccess+1
  sta SCRATCH+1

  lda SCRATCH       ; write it into the branch instruction
  sta (stackaccess)
  ldy #1
  lda SCRATCH+1
  sta (stackaccess),y

  ;; Finally, put that deferred branch instruction address onto
  ;; the stack
  lda SCRATCH+2
  sta stackaccess
  lda SCRATCH+3
  sta stackaccess+1
  jsr push16

  ;;; and replace the flag.
  lda #IFELSEFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

  jmp next

nocompile
  jmp abortcompile
.)

;;; dobegin is compiler behavior for BEGIN. It simply pushes the current
;;; DP onto the user stack, so that UNTIL can find it later and use it
;;; to calculate the offset.
dobegin
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; add the current instruction location to the stack
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  ;; add a flag to signal that this is for a BEGIN
  lda #BEGINFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

nocompile
  jmp next
.)

;;; dountil is the compiler behaviour for UNTIL. It compiles a 0branch
;;; with the offset calculated from the value left on the stack by
;;; dobegin.
dountil
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; pop the flag off the stack to make sure it's a BEGINFLAG
  jsr pop16
  lda stackaccess
  cmp #BEGINFLAG
  beq proceed
  jmp abortnest
  
proceed
  ;; compile the zerobranch and update DP.
  lda #<zerobracode
  sta (DP)
  ldy #1
  lda #>zerobracode
  sta (DP),y

.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; pull the address at the start of the loop
  jsr pop16

  ;; now calculate the offset. Subtract current DP from the value
  ;; on the stack. Result is negative number (the branch backwards).
  sec
  lda stackaccess
  sbc DP
  sta SCRATCH
  lda stackaccess+1
  sbc DP+1
  sta SCRATCH+1

  ;; now write that in as a parameter to the branch.
  ;; BUG lots of needless reads and writes going on here
  lda SCRATCH
  sta (DP)
  ldy #1
  lda SCRATCH+1
  sta (DP),y

  ;; increment DP again
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

nocompile
  jmp next
.)


;;; dodo is the compiler behavior for DO (the runtime behavior is
;;; doparendo). It compiles in (do) and then pushes the next instruction
;;; address (the loop target) onto the stack along with a flag.
dodo
  ;; test if we're compiling
  lda STATUS
  bit #COMPILE
  beq nocompiledo

  ;; compile (do)
  lda #<parendocode
  sta (DP)
  ldy #1
  lda #>parendocode
  sta (DP),y

doshared            ; entry point for do-query-do below

  ;; increment DP
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; push this address on the stack as the loop target address
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  ;; push a flag to contextualize the item on the stack. LOOP will
  ;; need this in order to distinguish between a DO and a LEAVE.
  lda #DOFLAG
  sta stackaccess
  stz stackaccess+1
  jsr push16

  jmp next          ; done!

nocompiledo
  jmp abortcompile

;;; doqdo is the compile-time code for ?DO, much of which is shared with
;;; do above.
;doqdo
;.(
;  ;; test if we're compiling
;  lda STATUS
;  bit #COMPILE
;  beq nocompiledo
;
;  ;; compile (do)
;  lda #<parenqdocode
;  sta (DP)
;  ldy #1
;  lda #>parenqdocode
;  sta (DP),y
;
;  jmp doshared
;
; realized that this is wrong. i need a forward branch in the case of
; the null loop. maybe make it look like a leave?


;;; doparendo is the implementation of (DO), the run-time behavior for
;;; DO. It pulls two values off the data stack (the loop limit and the
;;; loop index) and places them on the return stack (in inverted order).
doparendo
  lda stackbase+4,x ; MSB of limit
  sta (RP)
  dec RP
  lda stackbase+3,x ; LSB of limit
  sta (RP)
  dec RP
  lda stackbase+2,x ; MSB of index
  sta (RP)
  dec RP
  lda stackbase+1,x ; LSB of index
  sta (RP)
  dec RP
  clc               ; pop two cells (four types) off stack
  txa
  adc #4
  tax
  jmp next          ; done  


;;; doloop is the compiler behavior for LOOP. It compiles (LOOP) and a
;;; branch address to the address left on the stack.
doloop
  lda STATUS
  bit #COMPILE
  beq nodocompile

  lda #<parenloopcode
  sta (DP)
  ldy #1
  lda #>parenloopcode
  sta (DP),y

looptest
  ;; pop the flag off the stack and check DOFLAG or LEAVEFLAG
  jsr pop16
  lda stackaccess
  cmp #LEAVEFLAG
  beq fixleave
  cmp #DOFLAG
  beq loopcompile
  jmp abortnest

fixleave
  ;; there's a LEAVEFLAG on the stack, so update the address there
  ;; it should point to the instruction two cells (four bytes) after
  ;; this one, so first, calculate that.
  clc
  lda DP
  adc #4
  sta SCRATCH
  lda DP+1
  adc #0            ; in case of carry
  sta SCRATCH+1

  jsr pop16         ; get the address from the stack
  sec               ; substract from SCRATCH to get the offset
  lda SCRATCH
  sbc stackaccess
  pha               ; cache LSB
  lda SCRATCH+1
  sbc stackaccess+1
  ldy #1
  sta (stackaccess),y ; and write it back into stackaccess
  pla               ; pull the LSB
  sta (stackaccess)

  ;; there may be multiple LEAVEs, so loop around
  jmp looptest

;; we get here when we have found a DOFLAG on the stack
loopcompile
  ;; increment DP
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; now compile in the branch offset. first,
  ;; pull the address at the start of the loop
  jsr pop16

  ;; now calculate the offset. Subtract current DP from the value
  ;; on the stack. Result is negative number (the branch backwards).
  sec
  lda stackaccess
  sbc DP
  sta SCRATCH
  lda stackaccess+1
  sbc DP+1
  sta SCRATCH+1

  ;; now write that in as a parameter to the branch.
  ;; BUG lots of needless reads and writes going on here
  lda SCRATCH
  sta (DP)
  ldy #1
  lda SCRATCH+1
  sta (DP),y

  ;; increment DP again
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  jmp next

nodocompile
  jmp abortcompile


;;; doplusloop implements the compiler behavior for +LOOP. Basically,
;;; it writes in a differnt code address but then jumps into the LOOP
;;; code to do all the calculations of offsets, etc.
doplusloop
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  lda #<parplusloopcode
  sta (DP)
  ldy #1
  lda #>parplusloopcode
  sta (DP),y
  bra looptest

  jmp next

nocompile
  jmp abortcompile
.)

;;; doparplusloop implements (+LOOP), the runtime code for +LOOP.
;;; much of this will be shared with (LOOP), except that we start
;;; by pulling a value from the stack to do increment.
doparplusloop
  jsr pop16         ; pull the increment value
  ldy #1
  clc               ; and add it to the value at top of r-stack
  lda (RP),y
  adc stackaccess
  sta (RP),y
  iny
  lda (RP),y
  adc stackaccess+1
  sta (RP),y

  ;; for a positive loop increment, we can just use the
  ;; same code as (LOOP). Check the sign of the increment

  bit stackaccess+1 ; test top bit of increment value
  bpl testandloop   ; branch when N=0 to shared code with (LOOP)

  ;; it's negative, so we have to do our own test
  ;; grab the loop limit and stash it in SCRATCH+2/3.
  ldy #3
  lda (RP),y
  sta SCRATCH+2
  iny
  lda (RP),y
  sta SCRATCH+3

  ;; compare index to the loop limit
.(
  ldy #1
  sec
  lda (RP),y        ; LSB of index
  sbc SCRATCH+2     ; LSB of limit
  iny
  lda (RP),y        ; MSB
  sbc SCRATCH+3
  sbc (RP),y
;  bmi noloop        ; minus if limit > index
  bpl takeloop
.)
  jmp noloop


;;; doparenloop implements (LOOP), which is the run-time code for LOOP.
;;; increment and test index and optionally branch back to address
;;; provided.
doparenloop
  ;; increment the loop index in-place
.(
  ldy #1
  clc
  lda (RP),y        ; no (),y mode for INC, sadly!
  adc #1
  sta (RP),y
  bcc continue
  iny
  lda (RP),y
  adc #0
  sta (RP),y
continue
.)

testandloop         ; also entry point for (+LOOP)
  ;; grab the loop limit and stash it in SCRATCH+2/3.
  ldy #3
  lda (RP),y
  sta SCRATCH+2
  iny
  lda (RP),y
  sta SCRATCH+3

  ;; compare index to the loop limit
.(
  ldy #1
  sec
  lda (RP),y        ; LSB, index
  sbc SCRATCH+2     ; compared to LSB, limit
  iny
  lda (RP),y
  sbc SCRATCH+3
  bpl noloop
.)

takeloop
  ;; grab the branch address from (IP) and add it to IP
  ldy #1
  lda (IP),y        ; load MSB
  pha               ; stash it
  clc
  lda (IP)          ; load LSB
  adc IP            ; add
  sta IP            ; update
  pla               ; recover stashed MSB
  adc IP+1          ; add
  sta IP+1          ; update

  jmp next

noloop
  ;; drop values from the return stack by adding 4 (4 bytes, 2 cells)
  ;; to the RP. We assume RP is all on the same page and ignore MSB.
  clc
  lda RP
  adc #4
  sta RP
.(
  clc
  lda IP
  adc #2
  sta IP
  bcc skipmsb
  inc IP+1
skipmsb
.)

  jmp next


;;; Doleave implements the compile-time of LEAVE. It compiles
;;; a branch, leaving an offset to be resolved later by LOOP.
doleave
  lda #<parenleavecode
  sta (DP)
  ldy #1
  lda #>parenleavecode
  sta (DP),y

  ;; increment DP to point to branch address location
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  ;; we want to push this onto the stack BUT we need to "tuck" it
  ;; under any interleaved IF/ELSE loops. so we need to look down
  ;; the stack until we find the right place to put it, copy everything
  ;; else, and then insert the address and the flag.
  dex               ; first, make space for two new cells on the stack
  dex               ; two cells equals four bytes, so four dex
  dex
  dex

  txa               ; copy X into Y. we'll use Y as the index
  tay               ; for looping down the stack

  ;; BUG BUG BUG this loop is unbounded if we don't find a flag!
lookforflag
  lda stackbase+5,y ; is top item a DOFLAG?
  cmp #DOFLAG
  beq foundflag     ; yes
  lda stackbase+5,y ; no, so we copy two cells up and try again
  sta stackbase+1,y
  lda stackbase+6,y
  sta stackbase+2,y
  lda stackbase+7,y
  sta stackbase+3,y
  lda stackbase+8,y
  sta stackbase+4,y
  iny               ; skip Y ahead to the next pair of cells
  iny
  iny
  iny
  bra lookforflag

foundflag
  ;; we have found the DOFLAG. use the two cells "above" this for our
  ;; address and flag
  lda DP            ; DP goes onto the stack
  sta stackbase+3,y
  lda DP+1
  sta stackbase+4,y
  lda #LEAVEFLAG
  sta stackbase+1,y
  lda #0
  sta stackbase+2,y

  ;; increment DP to point to next instruction address
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  jmp next


;;; doparenleave is the implementation of (leave), the run-time behavior
;;; for LEAVE. It basically just does a branch, but first, it pops
;;; some values off the return stack.
doparenleave
  clc
  lda RP
  adc #4
  sta RP
  jmp dobranch


;;; dowords. Print out the words defined in the dictionary (including
;;; variables).
dowords
.(
  jsr crlf

  ;; set up search by initializing dictionary pointer. reuse the
  ;; same pointer (DPTR) used in matching (tick).
  lda DT
  sta DPTR
  lda DT+1
  sta DPTR+1

nextentry
  ;; have we run out of dictionary entries? (when DPTR is $0000)
  lda DPTR
  bne printit
  lda DPTR+1
  beq done

printit
  ldy #0
  lda (DPTR),y
  and #%00011111    ; mask off the tags
  phx
  tax
  ldy #1
nextchar
  lda (DPTR),y
  jsr puta
  iny
  dex
  bne nextchar

  lda #$20          ; end with a space
  jsr puta
  plx

  ;; move on to the next entry
  ;;
  lda (DPTR)        ; get word length...
  and #%00011111    ; mask off the tags
  tay               ; store in Y, and add one...
  iny               ; for the pointer to the next entry
  lda (DPTR),y      ; update DPTR to point to next entry
  pha
  iny
  lda (DPTR),y  
  sta DPTR+1
  pla
  sta DPTR
  bra nextentry

done
  jmp next
.)


;;; implements MAX (16-bit)
domax
.(
  ;; compare most significant bytes
  lda stackbase+2,x
  cmp stackbase+4,x
  beq testother
  bpl topofstack
  bra nextonstack
  
  ;; only in the case where they were equal, test less significant
testother
  lda stackbase+1,x
  cmp stackbase+3,x
  bmi nextonstack

  ;; item on the top of the stack was larger. copy it over
  ;; lower item, and pop top item off
topofstack
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  ;; and just fall through to the pop below

  ;; lower item on stack is max. just pop off the top.
nextonstack
  inx
  inx
.)

donemax
  jmp next


;;; implements MIN (16-bit)
domin
.(
  ;; compare most significant bytes
  lda stackbase+2,x
  cmp stackbase+4,x
  beq testother
  bmi topofstack
  bra nextonstack
  
  ;; only in the case where they were equal, test less significant
testother
  lda stackbase+1,x
  cmp stackbase+3,x
  bpl nextonstack

  ;; item on the top of the stack was larger. copy it over
  ;; lower item, and pop top item off
topofstack
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  ;; and just fall through to the pop below

  ;; lower item on stack is max. just pop off the top.
nextonstack
  inx
  inx
.)

donemin
  jmp next


;;; implements KEY -- read a character from the terminal and
;;; leave its ascii value on the stack
dokey
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA

  sta stackaccess
  stz stackaccess+1
  jsr push16

  jmp next

;;; implements KEY? -- returns true/false signalling whether there
;;; is keyboard input waiting to be read.
dokeyqu
  dex
  dex
  lda ACIA_STATUS
  and #$08
  beq nokey
  jmp settrue
nokey
  jmp setfalse


;;; AND, OR, XOR
;;;
doand
  lda stackbase+1,x
  and stackbase+3,x
  sta stackbase+3,x
  lda stackbase+2,x
  and stackbase+4,x
  sta stackbase+4,x
  inx
  inx
  jmp next

door
  lda stackbase+1,x
  ora stackbase+3,x
  sta stackbase+3,x
  lda stackbase+2,x
  ora stackbase+4,x
  sta stackbase+4,x
  inx
  inx
  jmp next

doxor  
  lda stackbase+1,x
  eor stackbase+3,x
  sta stackbase+3,x
  lda stackbase+2,x
  eor stackbase+4,x
  sta stackbase+4,x
  inx
  inx
  jmp next


;;; implements 0=. Faster than "0 =" and works in place.
;;; uses setfalse and settrue for result, which requires that X
;;; be set appropriately for the result before we jump
doeqlzero
.(
  lda stackbase+1,x ; test for zero
  ora stackbase+2,x
  beq iszero        ; yes?
notzero
  jmp setfalse
iszero              ; yes it's zero
  jmp settrue
.)

;;; implements TRUE
dotrue
  dex
  dex
settrue
  lda #$ff
  sta stackbase+1,x
  sta stackbase+2,x
  jmp next


;;; implements FALSE
dofalse
  dex
  dex
setfalse
  stz stackbase+1,x
  stz stackbase+2,x
  jmp next


;;; 1+, 1-, 2+, 2-
;;;
do1plus
.(
  clc
  inc stackbase+1,x
  bne done
  inc stackbase+2,x
done
  jmp next
.)

do1minus
.(
  sec
  lda stackbase+1,x
  sbc #1
  sta stackbase+1,x
  bcs done
  dec stackbase+2,x
done
  jmp next
.)

do2plus
.(
  clc
  lda stackbase+1,x
  adc #2
  sta stackbase+1,x
  bcc done
  inc stackbase+2,x
done
  jmp next
.)

do2minus
.(
  sec
  lda stackbase+1,x
  sbc #2
  sta stackbase+1,x
  bcs done
  dec stackbase+2,x
done
  jmp next
.)

doinvert
  lda stackbase+1,x
  eor #$ff
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  sta stackbase+2,x
  jmp next

;;; Implements compile-time behaviour for WHILE (inside BEGIN/REPEAT).
;;; Compiles to 0branch and then leaves offset address on the stack.
dowhile
  lda #<zerobracode ; compile 0branch
  sta (DP)
  ldy #1
  lda #>zerobracode
  sta (DP),y

  ;; increment DP past the instruction and on to offset location
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  lda DP            ; push the address of the branch offset
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

  lda #WHILEFLAG    ; push a flag to contextualize that address
  sta stackaccess
  stz stackaccess+1
  jsr push16

  ;; increment DP once more
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  jmp next


;;; compile-time behaviour for repeat is to fix up any stacked
;;; WHILE calls and branch back to the last BEGIN
dorepeat
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  lda #<branchcode
  sta (DP)
  ldy #1
  lda #>branchcode
  sta (DP),y

reptest
  ;; pop the flag off the stack and check DOFLAG or LEAVEFLAG
  jsr pop16
  lda stackaccess
  cmp #WHILEFLAG
  beq fixwhile
  cmp #BEGINFLAG
  beq bracompile
  jmp abortnest

fixwhile
  ;; there's a LEAVEFLAG on the stack, so update the address there
  ;; it should point to the instruction two cells (four bytes) after
  ;; the current DP, so first, calculate that.
  ;; NB this code is shared with LOOP so integrate
  clc
  lda DP
  adc #4
  sta SCRATCH
  lda DP+1
  adc #0            ; in case of carry
  sta SCRATCH+1

  jsr pop16         ; get the address from the stack
  sec               ; substract from SCRATCH to get the offset
  lda SCRATCH
  sbc stackaccess
  pha               ; cache LSB
  lda SCRATCH+1
  sbc stackaccess+1
  ldy #1
  sta (stackaccess),y ; and write it back into stackaccess
  pla               ; pull the LSB
  sta (stackaccess)

  ;; may be multiple WHILEs so loop around
  jmp reptest

bracompile
  ;; we get here when we finally hit the BEGIN flag
  ;; increment DP
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; now compile in the branch offset. first,
  ;; pull the address at the start of the loop
  jsr pop16

  ;; now calculate the offset. Subtract current DP from the value
  ;; on the stack. Result is negative number (the branch backwards).
  sec
  lda stackaccess
  sbc DP
  sta SCRATCH
  lda stackaccess+1
  sbc DP+1
  sta SCRATCH+1

  ;; now write that in as a parameter to the branch.
  ;; BUG lots of needless reads and writes going on here
  lda SCRATCH
  sta (DP)
  ldy #1
  lda SCRATCH+1
  sta (DP),y

  ;; increment DP again
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  jmp next

nocompile
  jmp abortcompile
.)


;;; Implement RECURSE. This is an immediate word, and uses CWORD
;;; (plus an offset) to insert the code address of the word currently
;;; being defined).
dorecurse
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  clc
  lda CWORD         ; put word address into SCRATCH
  sta SCRATCH
  lda CWORD+1
  sta SCRATCH+1

  lda (CWORD)       ; load length of word string
  inc               ; add one for the length byte
  inc               ; and another two for the link
  inc
  clc
  adc SCRATCH       ; add to address. now scratch will contain
  sta SCRATCH       ; the address of the code word (cfa).
.(
  bcc continue
  inc SCRATCH+1
continue
.)
  lda SCRATCH       ; write the address it at compiler location
  sta (DP)
  ldy #1
  lda SCRATCH+1
  sta (DP),y

  ;; increment DP
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc continue
  inc DP+1
continue
.)

  jmp next          ; we're done
nocompile
  jmp abortcompile
.)

;;; backslash -- ignore the rest of the line
dobackslsh
  stz TCNT          ; flush the input buffer
  stz TPTR
  jmp next


;;; do comment. this is called as an immediate word. it basically
;;; skips ahead in the input buffer until it reads a word that is
;;; a singular closing parenthesis by itself.
docomment
  jsr discardcomment
  jmp next


doabs
.(
  lda stackbase+2,x ; is number on stack negative?
  bit #%10000000
  beq endabs        ; no it's not, so we're done

  jmp donegate      ; otherwise, negate it
endabs
.)
  jmp next


donegate
  clc               ; flip bits and add one to form two's complement
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  jmp next

;;; Implements .S, which prints the stack, mainly for debugging.
;;; Can't mess with X because we need to keep it as a working stack
;;; pointer ('cos we need to put numbers on the top of the stack
;;; to print them!
dodots
.(
  ;; first, cache a copy of the stack pointer
  txa
  sta SCRATCH+8
  ;; then set Y to the bottom of the stack
  ldy #$ff
loop
  cpy SCRATCH+8     ; when we hit the saved stack pointer, stop
  beq done
  dey               ; move to next stack location
  dey
  dex               ; make space on the top of the stack
  dex
  lda stackbase+1,y ; copy from location pointed to by Y
  sta stackbase+1,x ; into new top-of-stack position
  lda stackbase+2,y
  sta stackbase+2,x
  jsr print16s      ; that will also pop the copy from the stack
  bra loop
done
.)
  jmp next

;;; dotick implements TICK ('). Grabs a word and looks is up in the
;;; dictionary, leaving the xt on the stack. Short and sweet...
dotick
  jsr readnext
  jsr dictmatch

  clc               ; calculate xt. Add length of word, plus one for
  lda (DPTR)        ; the length byte and two for the link
  and #%00011111    ; mask off the status bits
  adc #3            ; max count value is 32, so this won't cause carry
  adc DPTR
  sta stackaccess
  lda DPTR+1
  adc #0            ; in case of carry
  sta stackaccess+1

  jsr push16
  jmp next

;;; doforget implements FORGET. Uses the same dictionary matching
;;; routine as the text interpreter (I'm gradually breaking this stuff
;;; out so that it can be used more generically).
doforget
.(
  jsr readnext      ; read next word from input stream
  jsr dictmatch     ; look for a match
  lda DPTR
  ora DPTR+1
  beq nomatch
  lda (DPTR)        ; load the word count for this entry
  inc               ; and add one for the count byte
  clc               ; and add to DPTR, so that it points to the link
  adc DPTR
  sta DPTR
  lda DPTR+1
  adc #0
  sta DPTR+1

  ldy #1            ; reset top of dictionary to the word preceeding
  lda (DPTR)        ; the word we are forgetting
  sta DT
  lda (DPTR),y
  sta DT+1
  bra done  
  ;; BUG reset DP in here too to reuse space? not sure how safe.

nomatch
  ;; issue an error

done
  jmp next
.)

;;; doimmediate implements IMMEDIATE, which sets the IMMEDIATE flag
;;; for the most recently defined word. Not sure if it should be
;;; immediate itself! Most recently defined word is the one at the
;;; top of the dictionary, ie at DT.
doimmed
  lda (DT)
  ora #IMM
  sta (DT)
  jmp next          ; shortest instruction yet?


;;; dofill implements FILL.
dofill
  lda stackbase+5,x ; copy base address into stackaccess
  sta stackaccess
  lda stackbase+6,x
  sta stackaccess+1

.(
outerloop
  lda stackbase+4,x ; MSB of count
  beq lessthanpage  ; if zero, there's less than a page to copy

  lda stackbase+1,x ; the value to copy in
  ldy #$ff
innerloop
  sta (stackaccess),y
  dey
  bne innerloop
  sta (stackaccess),y
  inc stackaccess+1 ; add one to MSB of our base
  dec stackbase+4,x ; count off one page
  bne outerloop     ; until MSB of count is zero
.)

lessthanpage
.(
  lda stackbase+1,x ; we might be coming from before we loaded this
  ldy stackbase+3,x ; remaining count
  beq done
finalloop
  dey
  sta (stackaccess),y
  cpy #0
  bne finalloop
done
.)
  clc               ; pop three cells off the stack
  txa
  adc #6
  tax
  jmp next


;;; Call into the xmodem upload code from the monitor
doupload
  jsr crlf
  jsr XRECV
  jmp next


;;; Temporarily switch input to tbe buffer location specified on
;;; the stack.
doload
  jsr pop16         ; load address from the stack and set it
  lda stackaccess   ; as the memory region from which to read
  sta INBUFF        ; input text.
  lda stackaccess+1
  sta INBUFF+1
  stz TCNT          ; flush pending input
  stz TPTR
  inc SOURCE        ; 0 is terminal, non-zero is memory
  jmp next

donip
  lda stackbase+1,x
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x
  inx
  inx
  jmp next

;;; ( x1 x2 -- x2 x1 x2)
;;;            +5 +3 +1
dotuck
  dex
  dex
  lda stackbase+3,x
  pha
  sta stackbase+1,x
  lda stackbase+4,x
  pha
  sta stackbase+2,x

  lda stackbase+5,x
  sta stackbase+3,x
  lda stackbase+6,x
  sta stackbase+4,x

  pla
  sta stackbase+6,x
  pla
  sta stackbase+5,x
  jmp next

;;; Implement DUMP command by calling dump routine from the monitor.
;;; In Forth, the byte count is on the top of the stack and the base
;;; address underneath; the monitor looks for them the other way around.
;;; So to a swap before calling the routine.
dodump
  jsr swap16
  jsr DUMP
  jmp next


;;; implements COUNT -- take a pointer to a counted string on the stack,
;;; and turn it into a pointer to the characters and the count.
docount
  clc
  lda stackbase+1,x ; LSB of counted string address
  sta SCRATCH       ; cache it
  adc #1            ; add one (to get address of characters)
  sta stackbase+1,x ; put back
  lda stackbase+2,x ; now same for MSB
  sta SCRATCH+1
  adc #0
  sta stackbase+2,x
  lda (SCRATCH)     ; load character count from cached address
  sta stackaccess
  stz stackaccess+1
  jsr push16
  jmp next

  

;;;
;;; DOUBLE-LENGTH ARITHMETIC
;;;
;;; These routines are all for double-length (ie, 32-bit
;;; rather then 16-bit) arithmetic, although for the moment,
;;; I'm entirely ignoring issues about signed vs unsigned.
;;;

;;; promote a single-lenth value to a double-legnth value (S>D).
dosgltodbl
.(
  dex               ; add space on the stack
  dex
  lda stackbase+3,x ; copy the single-length cell down
  sta stackbase+1,x
  lda stackbase+4,x
  sta stackbase+2,x

  ;; extend whatever the sign bit is of this word into the
  ;; larger word. so check if it's one or zero
  lda stackbase+4,x
  bit #%10000000
  beq zerobits      ; it's zero
  lda #$ff          ; it's one, so load FF into each byte
  sta stackbase+3,x
  sta stackbase+4,x
  bra end
zerobits
  stz stackbase+3,x ; zero out the upper cell
  stz stackbase+4,x
end
.)
  jmp next

;;; double-length addition
doadd32
  clc
  lda stackbase+1,x ; byte #1
  adc stackbase+5,x
  sta stackbase+5,x ; leaves result in lower area on stack
  lda stackbase+2,x ; byte #2
  adc stackbase+6,x
  sta stackbase+6,x
  lda stackbase+3,x ; byte #3
  adc stackbase+7,x
  sta stackbase+7,x
  lda stackbase+4,x ; byte #4
  adc stackbase+8,x
  sta stackbase+8,x
  inx               ; drop the upper two-cell number
  inx
  inx
  inx
  jmp next          ; done

;;; mixed-length addition. Add a 16-bit wide number on the top of
;;; the stack to a 32-bit wide number below it.
doaddmix
  clc
  lda stackbase+1,x ; byte #1
  adc stackbase+3,x
  sta stackbase+3,x ; leaves result in lower area on stack
  lda stackbase+2,x ; byte #2
  adc stackbase+4,x
  sta stackbase+4,x
  lda stackbase+5,x ; byte #3
  adc #0
  sta stackbase+5,x
  lda stackbase+6,x ; byte #4
  adc #0
  sta stackbase+6,x
  inx               ; drop the single-length number
  inx
  jmp next          ; done


;;; double-length subtraction
dosub32
  sec                        ; set the carry
  lda stackbase+5,x ; byte #1
  sbc stackbase+1,x
  sta stackbase+5,x ; leaves result in lower area on stack
  lda stackbase+6,x ; byte #2
  sbc stackbase+2,x
  sta stackbase+6,x
  lda stackbase+7,x ; byte #3
  sbc stackbase+3,x
  sta stackbase+7,x
  lda stackbase+8,x ; byte #4
  sbc stackbase+4,x
  sta stackbase+8,x
  inx               ; drop the upper two-cell number
  inx
  inx
  inx
  jmp next          ; done

donegate32
  clc
  lda stackbase+1,x ; add one and flip bits to calculate two's complement
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  eor #$ff
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x
  jmp next


;;; test for equality for 32-bit numbers
doeql32
.(
  lda stackbase+1,x
  cmp stackbase+5,x
  bne notequal
  lda stackbase+2,x
  cmp stackbase+6,x
  bne notequal
  lda stackbase+3,x
  cmp stackbase+7,x
  bne notequal
  lda stackbase+4,x
  cmp stackbase+8,x
  bne notequal
equal
  clc               ; clean up stack before setting result
  txa
  adc #6
  tax
  jmp settrue
notequal
  clc               ; clean up stack before setting result
  txa
  adc #6
  tax
  jmp setfalse
.)


;;; compare a 32-bit number to zero
dozero32
.(
  lda stackbase+1,x ; or all the bytes together
  ora stackbase+2,x
  ora stackbase+3,x
  ora stackbase+4,x
  beq zero          ; zero?
notzero
  inx               ; clean up stack before setting result
  inx
  jmp setfalse
zero
  inx               ; clean up stack before setting result
  inx
  jmp settrue
.)

;;; implements D0<
dolesszero32
.(
  lda stackbase+4,x
  bit #%1000000
  bne yes
  inx
  inx
  jmp setfalse
yes
  inx
  inx
  jmp settrue
.)

;;; implements DABS
doabs32
.(
  lda stackbase+4,x
  bit #%1000000
  beq done
  jmp donegate32
done
  jmp next
.)

;;; implements D<
doless32
.(
  sec
  lda stackbase+5,x
  sbc stackbase+1,x
  lda stackbase+6,x
  sbc stackbase+2,x
  lda stackbase+7,x
  sbc stackbase+3,x
  lda stackbase+8,x
  sbc stackbase+4,x
  bpl no
  clc
  txa
  adc #6
  tax
  jmp settrue
no
  txa
  adc #6
  tax
  jmp setfalse
.)

;;; implements DMIN
dodmin
.(
  sec
  lda stackbase+5,x
  sbc stackbase+1,x
  lda stackbase+6,x
  sbc stackbase+2,x
  lda stackbase+7,x
  sbc stackbase+3,x
  lda stackbase+8,x
  sbc stackbase+4,x
  bpl no
yes
  clc               ; min value is lower on stack, so drop
  txa               ; the upper one
  adc #4
  tax
  jmp next
no
  jsr swap32
  bra yes
.)

;;; implements DMAX
dodmax
.(
  sec
  lda stackbase+5,x
  sbc stackbase+1,x
  lda stackbase+6,x
  sbc stackbase+2,x
  lda stackbase+7,x
  sbc stackbase+3,x
  lda stackbase+8,x
  sbc stackbase+4,x
  bpl no
yes
  jsr swap32        ; swap and proceed with "no"
no
  clc               ; min value is lower on stack, so drop
  txa               ; the upper one
  adc #4
  tax
  jmp next
.)



;;; domultmix -- multiply two 16-bit numbers, giving a 32-bit result
domultmix
  jsr multmixsub
  jmp next

multmixsub
.(
  sec               ; make some working space on the stack
  txa               ; need six bytes... four for our result and
  sbc #6            ; two for the expansion of n1
  tax
  stz stackbase+1,x ; zero it out
  stz stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x
  stz stackbase+5,x
  stz stackbase+6,x

  ;; multiplying n1 by n2. n1lsb is stackbase+7,x;
  ;; n1msb is stackbase+8,x; n2lsb is stackbase+9,x; and
  ;; n2msb is stackbase+10,x
nextbit
  ; first bit
  lda #$01
  bit stackbase+9,x ; test lowest bit of n2
  beq nextshift     ; if it's zero, skip to shifting
  ; it's one, so we do an addition
  clc
  lda stackbase+7,x ; add n1 to our working count
  adc stackbase+1,x ; which is stored in the temporary stack space
  sta stackbase+1,x
  lda stackbase+8,x
  adc stackbase+2,x
  sta stackbase+2,x
  lda stackbase+3,x ; 32-bit extension space for n1
  adc stackbase+5,x
  sta stackbase+3,x
  lda stackbase+4,x
  adc stackbase+6,x
  sta stackbase+4,x
nextshift           ; now shift n1 one place to the left
  ; shift n1 left
  asl stackbase+7,x
  rol stackbase+8,x
  rol stackbase+5,x ; this is the space into which we're extending
  rol stackbase+6,x ; n1 (for double length)
  ; shift n2 right
  clc               ; and shift n2 one place to the left
  ror stackbase+10,x
  ror stackbase+9,x
  bne nextbit       ; if n2 is non-zero, then continue on
  lda stackbase+10,x
  bne nextbit
done
.)
  ;; clean up the mess we made on the stack
  ;; first, put the result back in the right place
  lda stackbase+1,x
  sta stackbase+7,x
  lda stackbase+2,x
  sta stackbase+8,x
  lda stackbase+3,x
  sta stackbase+9,x
  lda stackbase+4,x
  sta stackbase+10,x
  ;; then, discard our temporary space
  clc
  txa
  adc #6
  tax
  rts


;;; Mixed-length division. Divide a 32-bit number by a 16-bit number,
;;; giving a 16-bit result. This is used as part of */.
;;; on entry, the 16-bit divisor is on the top of the stack (ie
;;; at stackbase+1 and +2), and the 32-bit divisand is lower (ie
;;; at stackbase+3 through +6)
divmixsub
.(
  phy               ; preserve Y

  ;; handle negative numbers. we convert everything to positive and
  ;; keep a note of whether we need to negate the result. this is
  ;; kinda a crappy way to do this but will get me through for now.
  ;; BUG BETTER NEGATIVE DIVISION
  stz SCRATCH

  lda stackbase+6,x ; test top bit of divisand
  bit #%10000000
  beq testdivisor
  eor #$ff          ; negative, so negate it
  sta stackbase+6,x
  
  clc               ; flip bits and add one to generate two's complement
  lda stackbase+3,x
  eor #$ff
  adc #1
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x
  lda stackbase+5,x
  eor #$ff
  adc #0
  sta stackbase+5,x
  lda stackbase+6,x
  adc #0            ; already EOR'd this byte up top
  sta stackbase+6,x
  inc SCRATCH

testdivisor
  lda stackbase+2,x ; now do the same to the divisor
  bit #%10000000
  beq continue      ; not negative
  eor #$ff          ; flip bits and add one to generate two's complement
  sta stackbase+2,x
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  adc #0
  sta stackbase+2,x
  inc SCRATCH

continue
  ;; make some working space on the stack. two 16-bit values needed.
  dex
  dex
  dex
  dex

  ;; zero out those spaces
  stz stackbase+1,x ; stackbase+1 and +2 are remainlsb, remainmsb
  stz stackbase+2,x
  stz stackbase+3,x ; stackbase+3 and +4 are resultlsb, resultmsb
  stz stackbase+4,x

  ; divisor (n1) is now stackbase+5 and +6
  ; divisand (n2) is npw stackbase+7 through +10

  ldy #$20          ; loop count, going 32 times (one per divisand bit)
nextbit
  ; shift n2 (divisand) left, rotating top bit into temp
  asl stackbase+7,x
  rol stackbase+8,x
  rol stackbase+9,x
  rol stackbase+19,x
  rol stackbase+1,x
  rol stackbase+2,x
  ; is temp larger than/equal to n1?
  lda stackbase+2,x       ; msb first -- does that resolve it?
  cmp stackbase+6,x
  bcc shift0
  bne subtract
  lda stackbase+1,x
  cmp stackbase+5,x
  bcs subtract
  bra shift0
  ; yes so subtract divisor from temp
subtract
  sec
  lda stackbase+2,x
  sbc stackbase+6,x
  sta stackbase+2,x
  lda stackbase+1,x
  sbc stackbase+5,x
  sta stackbase+1,x
  ; shift and test
shift1
  ; shift result one place left, shifting in a 1 at the bottom
  sec
  rol stackbase+3,x
  rol stackbase+4,x
  bra test
shift0
  ; shift result one place left, shifting in a 1 at the bottom
  clc
  rol stackbase+3,x
  rol stackbase+4,x
test
  ; test-- are we done (all 32 bits)?
  dey
  bne nextbit
  ;; we are now done.
  ;; remainder is in stackbase+1 and +2; quotient is in stackbase+3 and +4
enddiv
.)

  lda stackbase+3,x ; put result in right place
  sta stackbase+9,x
  lda stackbase+4,x
  sta stackbase+10,x
  clc               ; clean up the stack
  txa
  adc #8
  tax

  ;; if the lowest bit of SCRATCH is set, then negate the result
  lda SCRATCH
  bit #1
  beq donemixdiv
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
donemixdiv
  ply               ; restore y
  rts


dostardiv
  jsr pop16         ; temporarily move divisor out of the way
  lda stackaccess
  pha
  lda stackaccess+1
  pha
  jsr multmixsub    ; do the multiplication
  pla               ; put the divisor back
  sta stackaccess+1
  pla
  sta stackaccess
  jsr push16
  jsr divmixsub     ; do the division
  jmp next


;;; BUG there is an awful lot of code shared between rprint32
;;; and print32. Can all the setup stuff be broken out?
rprint32s
  ;; Initialize the PADPTR. We will assemble the string on the
  ;; pad. Leave one space for a count.
  lda #<PAD
  inc               ; space for the count
  sta PADPTR
  lda #>PAD         ; no carry; presume no page boundary
  sta PADPTR+1

.(
  ;; next, check the most significant bit of the number
  ;; to see if it's negative
  lda stackbase+4,x
  bit #%10000000
  beq nominus

  lda #$2d          ; minus sign
  sta (PADPTR)      ; add it to the string we're assembling
  inc PADPTR

  ;; now calculate the two's complement of the number we have.
  ;; flip all the bits and add one.
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  eor #$ff
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x

nominus
.)
  jsr assemble32    ; assemble the 32-bit number on the pad
  jsr pop16         ; pull the field width (presume < 256)
  phy
  sec
.(
  lda stackaccess   ; load field width
  sbc PAD           ; subtract the the string length
  bmi printnum      ; skip spaces if number longer than field
  tay
  lda #$20
  cpy #0
  beq printnum
space
  jsr puta
  dey
  bne space
printnum
.)
  jsr prpadnum
  ply               ; restore Y
  rts



;;; Print a 32-bit decimal number. This is kinda awful. The technique
;;; I used for 16-bits was messy enough, but this is messier now that
;;; I've extended it. (Updated to handle negative numbers.)
print32s
  ;; Initialize the PADPTR. We will assemble the string on the
  ;; pad. Leave one space for a count.
  lda #<PAD
  inc               ; space for the count
  sta PADPTR
  lda #>PAD         ; no carry; presume no page boundary
  sta PADPTR+1

.(
  ;; next, check the most significant bit of the number
  ;; to see if it's negative
  lda stackbase+4,x
  bit #%10000000
  beq nominus

  lda #$2d          ; minus sign
  sta (PADPTR)      ; add it to the string we're assembling
  inc PADPTR

  ;; now calculate the two's complement of the number we have.
  ;; flip all the bits and add one.
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
  lda stackbase+3,x
  eor #$ff
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  adc #0
  sta stackbase+4,x

nominus
  jsr assemble32
  lda #$20
  jsr puta
  jsr prpadnum
.)
  rts



assemble32
  ;; Open five bytes of storage on the stack. These will be
  ;; ten nybbles each holding a single binary-coded decimal
  ;; digit (since 32 bytes stores a max of a ten-digit decimal).
  dex
  dex
  dex
  dex
  dex
  
  ;; that leaves the data to be read at stackbase+6,x through
  ;; stackbase+9,x
  
  stz stackbase+1,x ; dec0
  stz stackbase+2,x ; dec1
  stz stackbase+3,x ; dec2
  stz stackbase+4,x ; dec3
  stz stackbase+5,x ; dec4

  phy               ; preserve Y
  lda #0
  sed
  ldy #32           ; count of bits we are processing

.(
loop
  asl stackbase+6,x ; roll bits out of the data values
  rol stackbase+7,x ; and into the carry, one by one
  rol stackbase+8,x
  rol stackbase+9,x
  lda stackbase+1,x ; and then use carry to add into the
  adc stackbase+1,x ; decimal space
  sta stackbase+1,x
  lda stackbase+2,x
  adc stackbase+2,x
  sta stackbase+2,x
  lda stackbase+3,x
  adc stackbase+3,x
  sta stackbase+3,x
  lda stackbase+4,x
  adc stackbase+4,x
  sta stackbase+4,x
  lda stackbase+5,x
  adc stackbase+5,x
  sta stackbase+5,x
  dey
  bne loop
.)
  cld
  ;; we have the result in the temporary storage, as BCD. now print
  ;; that as a ten-character string. do this as five loops of
  ;; an upper and lower nybble.

  ;; set a flag to determine whether we've printed anything non-zero
  stz SCRATCH

  txa
  adc #<stackbase
  sta SCRATCH+2
  lda #>stackbase
  sta SCRATCH+3
  ldy #5

.(
nextbcd             ; go through this loop for each BCD digit
  ;; first, upper four bytes
  lda (SCRATCH+2),y
  and #%11110000
  bne prupper       ; non-zero
  cmp SCRATCH       ; if it's zero, check if we're printing zeros
  beq lower         ; if we're not, then skip this one
prupper
  clc               ; shift the top four bits down to the bottom
  ror
  ror
  ror
  ror
  clc
  adc #'0
;  jsr puta
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

lower
  ;; next, lower four bytes
  lda (SCRATCH+2),y
  and #%00001111
  bne prlower       ; non-zero
  cmp SCRATCH       ; if it's zero, check if we're printing zeros
  beq skip          ; if we're not, then skip this one
prlower
  clc
  adc #'0
;  jsr puta
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

skip
  dey
  bne nextbcd
.)

.(
  ;; check -- if we never printed anything, output a zero
  lda SCRATCH
  bne finalize
  lda #$30          ; add a zero
  ;jsr puta
  sta (PADPTR)
  inc PADPTR

finalize
  sec
  lda PADPTR        ; calculate string length
  sbc #<PAD
  dec
  sta PAD           ; update string count
  ply               ; restore Y

  clc               ; clear bytes off the stack (five for
  txa               ; working space and four for 32-bit number).
  adc #9
  tax
.)
  rts



;;;
;;; DOUBLE CELL STACK ROUTINES
;;;

do2dup
  dex
  dex
  dex
  dex
  lda stackbase+5,x
  sta stackbase+1,x
  lda stackbase+6,x
  sta stackbase+2,x
  lda stackbase+7,x
  sta stackbase+3,x
  lda stackbase+8,x
  sta stackbase+4,x
  jmp next

do2drop
  inx
  inx
  inx
  inx
  jmp next

do2over
  dex
  dex
  dex
  dex
  lda stackbase+9,x
  sta stackbase+1,x
  lda stackbase+10,x
  sta stackbase+2,x
  lda stackbase+11,x
  sta stackbase+3,x
  lda stackbase+12,x
  sta stackbase+4,x
  jmp next

do2swap
  jsr swap32
  jmp next

;;; this routine is broken out because we use it in some other
;;; places too
swap32
  lda stackbase+1,x ; cache two cells from top of stack
  pha               ; on the processor's hardware stack
  lda stackbase+2,x
  pha
  lda stackbase+3,x
  pha
  lda stackbase+4,x
  pha

  lda stackbase+5,x ; copy two lower cells into the two cells
  sta stackbase+1,x ; on the top of the stack
  lda stackbase+6,x
  sta stackbase+2,x
  lda stackbase+7,x
  sta stackbase+3,x
  lda stackbase+8,x
  sta stackbase+4,x

  pla               ; restore the cached values and place them
  sta stackbase+8,x ; in the two lower cells
  pla
  sta stackbase+7,x
  pla
  sta stackbase+6,x
  pla
  sta stackbase+5,x

  rts



;;;
;;; TEXT INTERPRETER
;;;
;;; For the moment, this is a basically a stopgap. The real FORTH
;;; text interpreter has many individual components that manifest
;;; themselves as words in the dictionary, and we'll get there.
;;; (The fact that the text interpreter is called QUIT in true Forth
;;; is the ultimate testement to Chuck Moore's twisted nature.)
;;; This is just something to get us going. Again, much borrowed here
;;; from the code of the monitor.
;;;


;;; initialize the interpreter
;;;
startinterp

  ;; set up buffer (nothing to do)

  ;; set up buffer pointer (current pointer within text buffer)
  stz TPTR

  ;; set up buffer counter (number of characters input)
  stz TCNT

  ;; print greeting
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda greeting,y
  beq interploop
  sta ACIA_DATA
  iny
  jmp next_char
.)


;;; This is the main loop of the interpreter -- which also includes
;;; hooks to the compiler, because in Forth those are deeply
;;; conjoined.
;;;
interploop

  ;; get the next input word into WORD, potentially refilling
  ;; the text buffer in the process
  jsr readnext

  ;; search for a match in the dictionary
  ;;
  jsr dictmatch
  lda DPTR          ; check for no match (DPTR is 0000)
  ora DPTR+1
  beq nomatch

  ;; we found a match for a word to execute. Set up the context
  ;; and call NEXT to get started.
gotmatch
  ;; first, check if we're compiling. if we are not, then we can continue
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; now check if the word is immediate... because if it is, we should
  ;; go ahead and execute it, even if we're compiling
  lda (DPTR)
  bit #IMM
  bne nocompile

  ;; compile this into the currently-compiling word. that means we
  ;; should add the address of the code word into the location
  ;; pointed to by DP and increment DP.
  ;; DPTR stores the start of the entry for the word to execute.
  ;; So its code word is at (DPTR) + wordlength + 1 (len) + 2 (link)
  ldy #1
  lda (DPTR)        ; word length
  and #%00011111    ; mask off tag bits
  inc 		    ; +1 for the length byte
  inc
  inc               ; + 2 more for the link word
  clc
  adc DPTR          ; add to address and store in dummy word entry
  sta (DP)
  lda DPTR+1
  adc #$0
  sta (DP),y

  ;; increment DP by 2
.(
  clc
  lda DP
  adc #2
  sta DP
  bcc skipmsb
  inc DP+1
skipmsb
.)

  ;; proceed with the interpreter loop
  jmp interploop

nocompile
  ;; DPTR stores the start of the entry for the word to execute.
  ;; So its code word is at (DPTR) + wordlength + 1 (len) + 2 (link)
  lda (DPTR)        ; word length
  and #%00011111    ; mask off tag bits
  inc 		    ; +1 for the length byte
  inc
  inc               ; + 2 more for the link word
  clc
  adc DPTR          ; add to address and store in dummy word entry
  sta dummyparam
  lda DPTR+1
  adc #$0
  sta dummyparam+1

  ;; put the dummy parameter address into IP.
  lda #<dummyparam
  sta IP
  lda #>dummyparam
  sta IP+1

  ;; jump to NEXT to start running it
  jmp next


  ;; we didn't find a match in the dictionary, so see if we can parse
  ;; it as a number.
nomatch
  ;; before we do the conversion, check that all the letters are digits
  ldy WORD
numcheck
.(
  lda WORD,y
  cmp #$2d          ; minus sign
  bne digitcheck
  cpy #$1           ; only allowed when y=1
  bne nointerpret
  bra continue
digitcheck
  cmp #$30
  bcc nointerpret   ; BCC = branch if less than
  cmp #$40
  bcs nointerpret   ; BCS = branch if greater or equal
continue
  dey
  bne numcheck
.)

  ;; convert number and put it on the stack
  ;; my routines for this us a null-terminated string, so add a null
  ldy WORD
  iny
  lda #0
  sta WORD,y        ; add a null
  lda #<WORD        ; put address on the stack threshold
  sta stackaccess
  lda #>WORD
  sta stackaccess+1
.(
  inc stackaccess   ; bump it by one to avoid the count
  bne done
  inc stackaccess+1
done
.)
  jsr push16
  jsr readsign16    ; read a signed number (ie process leading minus)
  ;;jsr readdec16     ; convert it, leave it on the stack


  ;; if we are compiling, we need to take it off the stack again
  ;; and compile it into the word.
  lda STATUS
  bit #COMPILE
  beq normal

  ;; we are compiling. so we need to add this to the current
  ;; word as a literal. that means adding the code for DOLIT
  ;; and then the number.
  jsr pop16
  ldy #0
  lda #<dolitcode
  sta (DP),y
  iny
  lda #>dolitcode
  sta (DP),y
  iny
  lda stackaccess
  sta (DP),y
  iny
  lda stackaccess+1
  sta (DP),y
  iny

  ;; add Y to DP
  clc
  tya
  adc DP
  sta DP
  lda DP+1
  adc #0
  sta DP+1

normal
  jmp interploop
  
  ;; if we get here, we couldn't find a match, nor could we read it as
  ;; a number. there's no interpretation, so issue an error, flush
  ;; the input, and loop
nointerpret  

  ;; turn off the compiler, if we were compiling
  stz STATUS

  ;; print an error, in three stages. first, a space; then, the
  ;; undefined word; finally, the error message.

.(
wait_txd_empty3
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty3
  lda #$20
  sta ACIA_DATA
.)

  ldy #1
.(
next_char
wait_txd_empty3
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty3
  lda WORD,y
  sta ACIA_DATA
  iny
  cpy WORD
  bcc next_char
  beq next_char
.)

  jmp abortnotdef


;;; dictmatch looks up a word in the dictionary. The word being
;;; matched is indicated by WORD, which holds a pointer to a
;;; counted string. On exist, DPTR either points to the entry
;;; for the word, or 0000 in case of no match.
dictmatch
  ;; set up search by initializing dictionary pointer
  lda DT
  sta DPTR
  lda DT+1
  sta DPTR+1

nextentry
  ;; have we run out of dictionary entries? (when DPTR is $0000)
  lda DPTR
  bne compareentry
  lda DPTR+1
  beq return

compareentry
  ;; compare words. counted strings can be compared directly;
  ;; byte by byte will compare counts first. But we need to
  ;; mask out the tags in the count.

  ldy #0
  lda (DPTR),y
  and #%00011111    ; mask off the tags
  cmp WORD,y        ; compare word lengths
  bne trynext       ; no match

  ;; now compare words. do this from the end (for easier testing)
  ldy WORD
.(
nextchar
  lda (DPTR),y
  cmp WORD,y
  bne trynext
  dey
  bne nextchar
.)
  ;; successful match!
  bra return
  
  ;; loop to next entry
trynext
  lda (DPTR)        ; get word length...
  and #%00011111    ; mask off the tags
  tay               ; store in Y, and add one...
  iny               ; for the pointer to the next entry
  lda (DPTR),y      ; update DPTR to point to next entry
  sta SCRATCH
  iny
  lda (DPTR),y  
  sta DPTR+1
  lda SCRATCH
  sta DPTR
  bra nextentry
return
  rts


;;; readnext
;;; read the next word into the area at WORD, potentially refilling
;;; the entire buffer in the process.
;;; this is a subroutine so that I can also use it in dovariable,
;;; although it is mainly used by the text interpreter.
readnext
  ;; if no more input, ->nomoreinput

  lda TPTR          ; current pointer
  cmp TCNT          ; is that as much text as was read?
  beq nomoreinput   ; if yes, print prompt and get more

  tay               ; put TPTR into Y
interpword
  ;; begin loop

.(
  ;; look for next word
  lda INPUT,y
  cmp #$20          ; space
  beq nextchar
  cmp #$09          ; tab
  beq nextchar
  bne readword      ; not white space, so go and read a word

  ;; continue skipping past space
nextchar
  iny
  cpy TCNT
  beq nomoreinput
  bra interpword
.)

  ;; no more input -- we have exhausted the text buffer. refill.
nomoreinput
.(
  lda SOURCE        ; where are we reading from?
  beq terminal      ; terminal
  jsr readbufline   ; buffer
  bra finishedread
terminal
  ;; are we compiling?
  lda STATUS
  beq usualprompt   ; not compiling so say "OK" as usual
  jsr cprompt       ; different prompt to say we're still compiling
  bra refill
usualprompt
  jsr okcrlf        ; signal completion
refill
  jsr readtermline  ; read another line of text
finishedread
  stz TPTR          ; reset the pointer
  bra readnext      ; loop around
.)

  ;; we have detected the start of a non-space sequence. read a word
  ;; into a counted string at WORD.
readword
.(
  stz WORD
  phx
  ldx #1            ; X starts at 1 because 0 is the count
nextchar
  lda INPUT,y
  beq doneword      ; done if we hit NULL
  cmp #$20
  beq doneword      ; done if we hit space
  cmp #$09
  beq doneword      ; done if we hit tab
  sta WORD,x        ; X starts at 1 because 0 is the count
  stx WORD
  iny
  cpy TCNT          ; run off the end of the buffer?
  beq doneword
  inx
  bra nextchar
doneword
  plx
  sty TPTR          ; update the pointer (and free up Y)
.)
  rts



;;; Read a new line into the INPUT buffer. This reads from the
;;; terminal; readbufline will read from a buffer.
readtermline
  ldy #0
  stz TCNT          ; reset the counter
readchar
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA
  cmp #$08           ; check for backspace
  beq backspace
  cmp #$0D           ; check for newline (carriage return)
  beq doneline
  cmp #$0A           ; also allow line feed to terminate line
  beq doneline
  sta INPUT,y        ; track the input
  iny
  jsr puta           ; echo the typed character
  jmp readchar       ; loop to repeat
backspace
  cpy #0             ; beginning of line?
  beq readchar
  dey                ; if not, go back one character
  jsr puta           ; move cursor back
  jmp readchar

  ;; this is where we land if the line input has finished
  ;;
doneline
  lda #0
  sta INPUT,y       ; add a null terminator
  sty TCNT          ; update character count
  rts


;;; Read a new line into the INPUT buffer, taking our input from
;;; an area of memory. This is a bit of a hack, but allows other
;;; code to process the input buffer with no knowledge of where
;;; the text comes from. When the buffer is exhausted (signaled
;;; by reading either a nul or the XMODEM buffer data, switch
;;; back to terminal input.
readbufline
  ldy #0
  stz TCNT
readloop
  lda (INBUFF),y
  beq endofbuffer   ; null indicates end of the buffer
  cmp #$1A          ; XMODEM padding character too
  beq endofbuffer
  cmp #$0A
  beq endofline
  cmp #$0D
  beq endofline
  sta INPUT,y
  iny
  bra readloop
endofbuffer
  stz SOURCE        ; set SOURCE back to 0 (ie, read from terminal)
  ; continue to end of line
endofline
  lda #0
  sta INPUT,y
  sty TCNT
  iny               ; move past the end of line character
  tya               ; and update the buffer pointer
  clc
  adc INBUFF
  sta INBUFF
  lda INBUFF+1
  adc #0
  sta INBUFF+1
  rts  



;;; Implements ABORT. On error, resets and returns to interpreter.
;;; BUG doesn't reset DP if we were in the process of compiling, so
;;; leave a mess in the user space.
abort
  ;; turn off the compiler
  lda STATUS
  and #%11111110
  sta STATUS

  lda #$FF
  sta RP            ; reset return stack
  tax               ; reset user stack
  stz TCNT          ; reset text buffer
  stz TPTR
  stz SOURCE        ; return control to terminal

  jsr crlf          ; print newline
  jmp interploop    ; back to interpreter main loop


;;; ABORT with a message about nesting
abortnest
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda nesting,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
.)
  jmp abort

;;; ABORT with a message about nesting
abortcompile
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda compileerr,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
.)
  jmp abort
  
;;; ABORT with a message about an undefined word
abortnotdef
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda cantinterpret,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
.)
  jmp abort


;;;
;;; SD CARD SUPPORT
;;;
;;; I have an SD breakout card attached to Port B on the 6522. These
;;; routines are the drivers to initialize, read, and write, as
;;; well (later) as navigating the FAT16 filesystem.
;;; 
;;; Wiring details:
;;;   CLK is PB0, ie 1
;;;   MOSI is PB1, ie 2
;;;   CS is PB2, ie 4
;;;   MISO is PB7, which maps onto S flag on BIT (test with BPL and BMI)
;;; MISO, MOSI, and CS all have pull-up resisters, so they are high in
;;; the idle/unused state, except when pulled low by active circuitry.
;;;
;;; SD card support code is organized into roughly three layers. The
;;; lowest is the signalling layer that uses the 6522 to implement the
;;; SPI protocol. The thin middle layer is a basic layer for reading
;;; and writing data blocks. The upper layer implements (a subset of)
;;; the FAT16 filesystem.
;;;
SD_CLK  = 1
SD_MOSI = 2
SD_CS   = 4
SD_MISO = 128

;;; LOWEST LAYER (SPI PROTOCOL)
;;;

;;; set up data direction for PORTB -- lower four bits are outputs
;;; and upper four bits are inputs. This is called from FORTH startup.
setup6522
  lda #15
  sta VIA_DDRB
  rts

;;; Forth word to initialize the SD card and read the boot block.
domount
.(
  stz CURSEC
  stz CURSEC+1
  stz CURSEC+2
  stz CURSEC+3

  ;; BUG should test for card present
  jsr resetsd
  jsr cmd0
  cmp #1
  bne abortcardfail

  jsr sendff
  jsr cmd8
  ;; BUG test the response

  lda #100           ; going to try this up to 100 times
  sta SCRATCH

repeat55
  jsr sendff
  jsr cmd55
  jsr sendff
  jsr acmd41
  cmp #0            ; loop until we get a 0 response
  beq success

  dec SCRATCH
  bne repeat55
  jmp abortcardfail

success
  jsr sendff
  jsr cmd17

  jsr gettoken
  jsr getblock

.(

  ;; copy first 64 bytes into MBR area
  ldy #0
loop
  lda LBLOCK,y
  sta MBR,y
  iny
  cpy #64
  bne loop
.)

  ;; print a message with the card name
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda initializedmsg,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
.)

.(
  ldy #0
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda MBR_LABEL,y
  sta ACIA_DATA
  iny
  cpy #11
  bne next_char
.)

done
  jmp next
.)


;;; ABORT with a message about card not initializing
abortcardfail
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda cardfailmsg,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
.)
  jmp abort

;;; ABORT with a disk error
abortdiskerror
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda diskerrormsg,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
.)
  jmp abort


docmd0
  jsr resetsd
  jsr cmd0
  ;; push whatever came back onto the stack
  sta stackaccess
  stz stackaccess+1
  jsr push16
  jmp next

;;; initialize the SD card and set it to SPI mode.
resetsd
  lda #SD_CS+SD_MOSI  ; set MOSI and CS to 1
  sta PORTB

  ;; toggle CLK at least 74 times (ie do 80, for 10 bytes of FF)
  ;;
  ldy #80
.(
initloop
  inc PORTB
  dec PORTB
  dey
  bne initloop
.)
  rts

cmd0
  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd0 (01+6*0 + 24*0 + 10010101)
  lda #SPI_CMD+0
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #%10010101    ; CRC plus end bit
  jsr sendbyte

  jsr setidle       ; set to idle to await input
  jsr getresponse   ; get single byte response

  ldy #SD_CS+SD_MOSI ; set CS and MOSI high to release card
  sty PORTB
  rts

setidle
  ldy #%00000010    ; CLK off, MOSI high, CS low
  sty PORTB
  rts  

;; send an $ff... this is basically just about creating delays
;; between commands
sendff
  ;; set cs to 1
  lda #SD_CS
  tsb PORTB
  lda #$ff
  jsr sendbyte
  rts

;; the forth word version
dosendff
  jsr sendff
  jmp next

;; forth word version for cmd8
docmd8
.(
  jsr sendff
  jsr cmd8

  ;; if any bit other that the low order bit is set
  ;; on the response, then return that.
  lda SCRATCH
  and #254
  beq returndata

  ;; we got a signal of an illegal command. return it
  lda SCRATCH
  sta stackaccess
  stz stackaccess+1
  bra end

returndata
  ;; push lower 16 bits of what we get back onto the stack
  lda SCRATCH+4
  sta stackaccess
  lda SCRATCH+3
  sta stackaccess+1
end
  jsr push16
  jmp next
.)

cmd8
  ;; set cs to 0
  lda #4
  trb PORTB

  ;; send cmd8 with parameter 0x000001aa
  lda #SPI_CMD+8
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  lda #1
  jsr sendbyte
  lda #$aa
  jsr sendbyte
  lda #$87          ; crc
  jsr sendbyte

  jsr setidle
  jsr await40bits

  lda #SD_CS+SD_MOSI  ; release card (CS and MOSI high)
  sta PORTB

  rts

;; do cmd58, which gets a long response
docmd58
  jsr sendff
  jsr cmd58
  lda SCRATCH+1
  sta stackaccess+1
  lda SCRATCH+2
  sta stackaccess
  jsr push16
  lda SCRATCH+3
  sta stackaccess+1
  lda SCRATCH+4
  sta stackaccess
  jsr push16
  lda SCRATCH
  sta stackaccess
  stz stackaccess+1
  jsr push16
  jmp next

cmd58
  ;; set cs to 0
  lda #4
  trb PORTB

  ;; send cmd58
  lda #SPI_CMD+58
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #%01110101
  jsr sendbyte

  jsr setidle
  jsr await40bits

  lda #SD_CS+SD_MOSI  ; release card (CS and MOSI high)
  sta PORTB

  rts



;; do cmd55... that will allow acmd 41...
docmd55
.(
  jsr sendff
  jsr cmd55
  sta stackaccess
  stz stackaccess+1
  jsr push16
  jmp next
.)

cmd55
  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd55 with parameter 0
  lda #SPI_CMD+55
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; crc
  jsr sendbyte

  jsr setidle
  jsr getresponse
  ldy #6
  sty PORTB
  rts

  
doacmd41
.(
  jsr sendff
  jsr acmd41
  sta stackaccess
  stz stackaccess+1
  jsr push16
  jmp next
.)

acmd41
  ;; set cs to 0
  lda #4
  trb PORTB

  lda #SPI_CMD+41
  jsr sendbyte
  lda #%01000000    ; bit 30 is HCS flag
  jsr sendbyte
  lda #16           ; bit 20 selects 3.2-3.3V
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; checksum, but doesn't matter in SPI mode?
  jsr sendbyte

  jsr setidle
  jsr getresponse

  ldy #6
  sty PORTB
  rts

docmd17
  jsr sendff
  jsr cmd17
  sta stackaccess
  stz stackaccess+1
  jsr push16
  jmp next  

cmd17
  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd17 with parameter 0
  lda #SPI_CMD+17
  jsr sendbyte
  lda #0
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  jsr sendbyte
  lda #$95          ; crc, doesn't matter
  jsr sendbyte

  jsr setidle
  jsr getresponse
  rts

dogetblock
  jsr gettoken
  jsr getblock
  jmp next

gettoken
  ; listen until we hear %11111110 (254/$FE)
  jsr recv8bits
  cmp #$FE
  bne gettoken
  rts

getblock
.(
  ;; get 256 bytes at xx
  stz SCRATCH+8
  lda #>LBLOCK
  sta SCRATCH+9
loop
  jsr recv8bits
  sta (SCRATCH+8)
  inc SCRATCH+8
  bne loop
.)
.(
  ;; get 256 bytes at yy
  stz SCRATCH+8
  lda #>HBLOCK
  sta SCRATCH+9
loop
  jsr recv8bits
  sta (SCRATCH+8)
  inc SCRATCH+8
  bne loop
.)
  ; get CRC but ignore it. 16 bits, so two byte reads.
  jsr recv8bits
  jsr recv8bits

  jsr sendff        ; eight clock ticks to let SD card finish up
  rts


doloadblock
.(
  jsr sdloadblock
  bcc done
  jmp abortdiskerror
done
  jmp next
.)


;;; Load block specified by double on the stack, translating between
;;; number formats.
sdloadblock

  ;; check if this block is already loaded.
  lda stackbase+1,x
  cmp CURSEC
  bne startload
  lda stackbase+2,x
  cmp CURSEC+1
  bne startload
  lda stackbase+3,x
  cmp CURSEC+2
  bne startload
  lda stackbase+4,x
  cmp CURSEC+3
  bne startload
  clc               ; make sure carry is clear (error signal)
  bra finishload    ; jump to end, clean up stack
  
startload
  jsr sendff

  ;; set cs to 0
  lda #SD_CS
  trb PORTB

  ;; send cmd17 with parameter from the stack
  lda #SPI_CMD+17
  jsr sendbyte
  lda stackbase+4,x
  jsr sendbyte
  lda stackbase+3,x
  jsr sendbyte
  lda stackbase+2,x
  jsr sendbyte
  lda stackbase+1,x
  jsr sendbyte
  lda #$95          ; crc, doesn't matter
  jsr sendbyte

  jsr setidle
  jsr getresponse
  cmp #0
  bne abortread

  jsr gettoken
  jsr getblock

  ;; update cache of current sector number
  lda stackbase+1,x
  sta CURSEC
  lda stackbase+2,x
  sta CURSEC+1
  lda stackbase+3,x
  sta CURSEC+2
  lda stackbase+4,x
  sta CURSEC+3

finishload
  inx               ; clean up the stack
  inx
  inx
  inx

  clc               ; operation successful, so clear carry
  rts

abortread
  inx               ; clean up the stack
  inx
  inx
  inx

  sec               ; set carry to signal failure
  rts


sdloadnext
  ;; copy cached block number onto the stack, adding one
  dex
  dex
  dex
  dex
  clc
  lda CURSEC
  adc #1
  sta stackbase+1,x
  lda CURSEC+1
  adc #0
  sta stackbase+2,x
  lda CURSEC+2
  adc #0
  sta stackbase+3,x
  lda CURSEC+3
  adc #0
  sta stackbase+4,x

  ;; now jump to regular block load code, skipping cache check
  ;; (because we know it's different, clearly).
  jmp startload


;; load the root directory
sdloadroot
  dex
  dex
  dex
  dex
  lda #1            ; sector 513 == 0x00000201
  sta stackbase+1,x
  lda #2
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x
  jmp sdloadblock
  

;;; List files from the root directory
;;;
dodir
  ;; BUG check that there's a disk mounted and present
  ;; load the root directory -- just hardcoding location for now
  ;; BUG calculate this properly
  stz stackaccess
  stz stackaccess+1
  jsr push16
  lda #2            ; block 513 = 2 in MSB and 1 in LSB
  sta stackaccess+1
  lda #1
  sta stackaccess
  jsr push16
  jsr sdloadblock
  bcc header
  jmp abortdiskerror

header
  jsr crlf
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda dirofmsg,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
.)

  ldy #0
.(
loop
  lda MBR_LABEL,y
  cmp #$20
  beq done
  jsr puta
  iny
  cpy #11
  beq done
  bra loop
done
.)
  jsr crlf
  
startdir
  ;; set pointer to first entry
  lda #<LBLOCK
  sta SCRATCH+6
  lda #>LBLOCK
  sta SCRATCH+7

printdirent         ; print the entry pointed to by SCRATCH+6

  lda (SCRATCH+6)
  beq endofdir      ; if it's null, we're done

  ldy #11           ; check for hidden file
  lda (SCRATCH+6),y
  and #2
  bne nextdirent    ; skip hidden files

  ;; print two spaces
  lda #$20
  jsr puta
  jsr puta

  ;; print the file name (and then extension)
  ldy #0
.(
nextchar
  lda (SCRATCH+6),y
  jsr puta
  iny
  cpy #8            ; stop after eight characters
  bne nextchar
.)

  lda #"."
  jsr puta

printext            ; now print extension, if there is one
  lda (SCRATCH+6),y
  jsr puta
  iny
  lda (SCRATCH+6),y
  jsr puta
  iny
  lda (SCRATCH+6),y
  jsr puta

  lda #8
  sta stackaccess
  stz stackaccess+1
  jsr push16

  ldy #28           ; bytes 28-31 are the filesize in bytes
  dex
  dex
  dex
  dex
  lda (SCRATCH+6),y
  sta stackbase+1,x
  iny
  lda (SCRATCH+6),y
  sta stackbase+2,x
  iny
  lda (SCRATCH+6),y
  sta stackbase+3,x
  iny
  lda (SCRATCH+6),y
  sta stackbase+4,x
  jsr rprint32s
  jsr crlf

nextdirent
.(
  clc               ; add 32 to skip to next entry
  lda SCRATCH+6
  adc #32
  sta SCRATCH+6
bcc done
  inc SCRATCH+7
done
.)
  bra printdirent

endofdir
  jsr crlf

  jmp next


;; NOTE this uses SCRATCH+4,5,12,13,14,15
doshow

  ;; first, load the directory
  jsr sdloadroot
  
  ;; pop a value from the stack and take it as an index into the directory
  jsr pop16
  lda stackaccess
  sta SCRATCH+4
  lda stackaccess+1
  sta SCRATCH+5

;  lda #5            ; TEMP this is the entry we're loading
;  sta SCRATCH+4
;  stz SCRATCH+5

  ;; shift left to multiply by 32
  asl SCRATCH+4
  rol SCRATCH+5
  asl SCRATCH+4
  rol SCRATCH+5
  asl SCRATCH+4
  rol SCRATCH+5
  asl SCRATCH+4
  rol SCRATCH+5
  asl SCRATCH+4
  rol SCRATCH+5

  ;; now add the base address of the directory
  clc
  lda SCRATCH+4
  adc #<LBLOCK
  sta SCRATCH+4
  lda SCRATCH+5
  adc #>LBLOCK
  sta SCRATCH+5

  ;; now, SCRATCH+4/5 points to directory entry

  ;; first, put the block number on the stack as a double
  dex
  dex
  dex
  dex
  ldy #26
  lda (SCRATCH+4),y
  sta stackbase+1,x
  iny
  lda (SCRATCH+4),y
  sta stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  ;; grab the file size and stash it
  iny
  lda (SCRATCH+4),y
  sta SCRATCH+12
  iny
  lda (SCRATCH+4),y
  sta SCRATCH+13
  iny
  lda (SCRATCH+4),y
  sta SCRATCH+14
  iny
  lda (SCRATCH+4),y
  sta SCRATCH+15

  ;; turn block count on stack into sector count, and load the sector
  jsr cltosector
  jsr sdloadblock

  ;; now type what's in the block, up to the file size. we print in
  ;; blocks of 256 bytes, but we do so twice because the buffer is
  ;; actually 512 bytes.
  ;; BUG we ignore anything over 32k for the file size

  jsr crlf

typeblock
.(
  ;; by default, print 256 characters
  lda #255
  sta SCRATCH
  ;; are there fewer than 256 characters to process?
  lda SCRATCH+13
  beq under256
  dec SCRATCH+13    ; we will print 256 characters, take 256 off the count
  bra first256
under256
  lda SCRATCH+12    ; < 256, so lowest byte is # of chars to print
  beq endshow       ; if it's zero, we're done
  dec               ; range from 0 rather than 1
  sta SCRATCH
  stz SCRATCH+12
.)

first256
  ldy #0
.(
typechar
  lda LBLOCK,y
  jsr puta
  cmp #10           ; in the case of an LF, add a CR too
  bne nextchar
  lda #13
  jsr puta
nextchar
  cpy SCRATCH
  beq done
  iny
  bra typechar
done
.)

  ;; now consider the second 256 characters in the sector
.(
  ;; by default, print 256 characters
  lda #255
  sta SCRATCH
  ;; are there fewer than 256 characters to process?
  lda SCRATCH+13
  beq under256
  dec SCRATCH+13    ; update count for the end of the print
  bra second256
under256
  lda SCRATCH+12    ; < 256, so lowest byte is # of chars to print
  beq endshow       ; if it's zero, we're done
  dec               ; re-range to zero-index
  sta SCRATCH
  stz SCRATCH+12    ; after which, there will be none left
.)

second256
  ldy #0
.(
typechar
  lda HBLOCK,y
  jsr puta
  cmp #10           ; in the case of an LF, add a CR too
  bne nextchar
  lda #13
  jsr puta
nextchar
  cpy SCRATCH
  beq done
  iny
  bra typechar
done
.)

  ;; if there is more data, load the next block and repeat
  lda SCRATCH+13
  bne nextblock
  lda SCRATCH+12
  beq endshow

nextblock
  jsr sdloadnext
  jmp typeblock

endshow
  jsr crlf
  jmp next
  

;; convert a cluster address into a sector address
;; calculation is cluster-2 * sectors/cluster + resv + len FATs + len root
;; generally, cluster-2 * 64 + 545
cltosector
.(
  ;; subtract 2
  sec
  lda stackbase+1,x
  sbc #2
  sta stackbase+1,x
  lda stackbase+2,x
  sbc #0
  sta stackbase+2,x
  lda stackbase+3,x
  sbc #0
  sta stackbase+3,x
  lda stackbase+4,x
  sbc #0
  sta stackbase+4,x
done
.)

  ;; shift left 6 times, to multiply by 64
  clc
  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  rol stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  asl stackbase+1,x
  rol stackbase+2,x
  rol stackbase+3,x
  rol stackbase+4,x

  ;; add 545 ( = 512+33 = 2*256 + 33)
  clc
  lda stackbase+1,x
  adc #33
  sta stackbase+1,x
  lda stackbase+2,x
  adc #2
  sta stackbase+2,x
  lda stackbase+3,x
  adc #0
  sta stackbase+3,x
  lda stackbase+4,x
  adc #0
  sta stackbase+4,x

  rts



;;; lowest levels -- send a byte, receive a byte...


sendbyte
  ldy #8
sendloop
  asl
  pha
  bcc sendzero
sendone
  lda #SD_MOSI
  tsb PORTB
  bra send
sendzero
  lda #SD_MOSI
  trb PORTB
send
  inc PORTB
  dec PORTB
  pla
  dey
  bne sendloop
  rts

;; wait for data by pulsing the clock until there's a zero on MISO
awaitdata
.(
  inc PORTB         ; set CLK high
  bit PORTB         ; check for data on MISO
  bpl done          ; exit if we see a zdero
  dec PORTB         ; otherwise, set CLK low and 
  bra awaitdata     ; loop around again
done
  dec PORTB
.)
  rts

;; wait with a timeout. if we don't hear something within 256 pulses,
;; set carry flag and return
awaittimeout
.(
  clc
  ldy #0
awaitloop
  inc PORTB
  bit PORTB
  bpl done
  dec PORTB
  dey
  beq timeout
  bra awaitloop
timeout
  sec
  rts
done
  dec PORTB
  rts
.)

;; wait for data and then receive a byte starting with zero
awaitbyte
  jsr awaitdata
  lda #0
  jmp recv7bits

;; wait for byte with timeout (signalled with carry)
awaitbto
  jsr awaittimeout
  bcs timeout
  lda #0
  jmp recv7bits
timeout
  rts
  
await40bits
  jsr awaitdata     ; wait for any data
  jsr recv7bits     ; grab first 7 bits (presuming leading 0)
  sta SCRATCH
  jsr recv8bits     ; second byte
  sta SCRATCH+1
  jsr recv8bits     ; third byte
  sta SCRATCH+2
  jsr recv8bits     ; fourth byte
  sta SCRATCH+3
  jsr recv8bits     ; fifth byte
  sta SCRATCH+4
  rts

getresponse
.(
  phx
  ldx #0
loop
  inx
  beq timedout
  jsr recv8bits
  cmp #$ff
  beq loop
timedout
  plx
  rts
.)

;; TODO unroll this, probably a good deal faster then looping
recv8bits
  lda #0            ; zero out result
  inc PORTB         ; set clock high
  lda PORTB         ; read data
  cmp #128          ; this sets carry flag to top bit
  rol               ; shift carry into A
  dec PORTB         ; set clock off
  ;; now fall through to receive next seven bits

recv7bits
.(
  ldy #7            ; count up to seven bits
  phx               ; store X, since we'll use it
recvloop
  inc PORTB         ; set CLK high
  ldx PORTB         ; get data into X
  cpx #128          ; set carry flag to top bit of data
  rol               ; roll that into the accumulator
  dec PORTB         ; set CLK low
  dey               ; update bit count
  bne recvloop      ; loop until finished
  plx               ; restore X
.)
  rts               ; return with data in A



;;;
;;; USER I/O SUPPORT ROUTINES
;;; These have been "borrowed" from mitemon
;;;

puta
.(
  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts

okcrlf
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda ok,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
  rts
.)

cprompt
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda dots,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
  rts
.)


crlf
  pha
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0d
  sta ACIA_DATA
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0a
  sta ACIA_DATA
  pla
  rts


;; readsign16 looks on the stack for the address of a null-terminated
;; 16-bit number that might be preceeded with a minus sign.
readsign16
.(
  jsr pop16         ; move the string address into stackaccess

  dex               ; make some workspace on the stack. need two 16-byte
  dex               ; words, one of which will eventually be our result
  dex               ; so, workspace space is stackbase+1,x to stackbase+4,x
  dex
  stz stackbase+1,x ; zero out both 16-bit values
  stz stackbase+2,x
  stz stackbase+3,x
  stz stackbase+4,x

  phy               ; preserve y
  ldy #0            ; y indexes digits of the input string

  ;; first, check if the first character is a minus
  lda (stackaccess),y
  cmp #$2d
  bne nextdigit     ; it is not, so proceed as usual
  lda #1            ; set a flag; we'll process this later
  sta SCRATCH
  iny

nextdigit
  lda (stackaccess),y

  sec
  sbc #$30          ; turn from ascii digit into a number
  clc               ; add it to our partial result
  adc stackbase+3,x
  sta stackbase+3,x
  lda stackbase+4,x
  adc #0
  sta stackbase+4,x
  iny               ; bump the character count
  cpy #6            ; was that the last digit? (max 6 inc. minus)
  beq donelastdigit  
  lda (stackaccess),y
  beq donelastdigit ; stop stop if we hit null-terminator
mult10              ; more digits, so multiply by ten and go around
  asl stackbase+3,x ; shift left to multiply by two
  rol stackbase+4,x

  lda stackbase+3,x ; make a copy in the other temporary slot
  sta stackbase+1,x
  lda stackbase+4,x
  sta stackbase+2,x
  asl stackbase+1,x ; shift the copy left twice more, so x8 in total
  rol stackbase+2,x
  asl stackbase+1,x
  rol stackbase+2,x

  clc               ; add them (8x + 2x = 10x)
  lda stackbase+1,x
  adc stackbase+3,x
  sta stackbase+3,x
  lda stackbase+2,x
  adc stackbase+4,x
  sta stackbase+4,x

  bra nextdigit
donelastdigit
  ;; if we began with a minus, then calculate the two's complement
  ;; of the number we have read.
  lda SCRATCH
  beq finish        ; no minus flag set

  ;; first, calculate 1's complement -- flip all bits
  lda stackbase+3,x
  eor #$ff
  sta stackbase+3,x
  lda stackbase+4,x
  eor #$ff
  sta stackbase+4,x

  ;; now add 1 to generate the two's complement
  clc
  lda stackbase+3,x
  adc #1
  sta stackbase+3,x
  lda stackbase+4,x
  adc #0
  sta stackbase+4,x

finish
  inx               ; drop one of the temporary variables
  inx               ; but leave the other, which is our result
  ply               ; restore y
.)
  rts


;;; Print a 16-bit number, interpreted as signed, right-aligned in
;;; a field that is as wide as specified on the stack.
rprint16s
  ;; Initialize the PADPTR. We will assemble the string on the
  ;; pad. Leave one space for a count.
  lda #<PAD
  inc               ; space for the count
  sta PADPTR
  lda #>PAD         ; no carry; presume no page boundary
  sta PADPTR+1

.(
  ;; next, check the most significant bit of the number
  ;; to see if it's negative
  lda stackbase+2,x
  bit #%10000000
  beq nominus

  lda #$2d          ; minus sign
  sta (PADPTR)      ; add it to the string we're assembling
  inc PADPTR

  ;; now calculate the two's complement of the number we have.
  ;; flip all the bits and add one.
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
nominus
.)
  jsr assemble16    ; assemble a 16-bit number on the pad
  jsr pop16         ; pull the field width (presume < 256)
  phy
  sec
.(
  lda stackaccess   ; load field width
  sbc PAD           ; subtract the the string length
  bmi printnum      ; skip spaces if number longer than field
  tay
  lda #$20
  cpy #0
  beq printnum
space
  jsr puta
  dey
  bne space
printnum
.)
  jsr prpadnum
  ply               ; restore Y
  rts

;;; Print a 16-bit number, bearing in mind that it might be negative.
;;; After the initial test for sign, this shares code with the
;;; unsigned print routine and with the right-aligned printing.
;;;
print16s
  ;; Initialize the PADPTR. We will assemble the string on the
  ;; pad. Leave one space for a count.
  lda #<PAD
  inc               ; space for the count
  sta PADPTR
  lda #>PAD         ; no carry; presume no page boundary
  sta PADPTR+1

.(
  ;; next, check the most significant bit of the number
  ;; to see if it's negative
  lda stackbase+2,x
  bit #%10000000
  beq nominus

  lda #$2d          ; minus sign
  sta (PADPTR)      ; add it to the string we're assembling
  inc PADPTR

  ;; now calculate the two's complement of the number we have.
  ;; flip all the bits and add one.
  clc
  lda stackbase+1,x
  eor #$ff
  adc #1
  sta stackbase+1,x
  lda stackbase+2,x
  eor #$ff
  adc #0
  sta stackbase+2,x
nominus
.)
  jsr assemble16    ; assemble a 16-bit number on the pad
  lda #$20
  jsr puta
  jsr prpadnum      ; print it
  rts


;;; Print a 16-bit quantity interpreted as an unsigned number.
;;; Most of the code here is shared with the signed printing
;;; routine too.
print16u
  ;; Initialize the PADPTR. We will assemble the string on the
  ;; pad. Leave one space for a count.
  lda #<PAD
  inc               ; space for the count
  sta PADPTR
  lda #>PAD         ; no carry; presume no page boundary
  sta PADPTR+1

  ; jmp pr16       ; commented out because we can just fall through
  jsr assemble16    ; assemble a 16-bit number on the pad
  lda #$20
  jsr puta
  jsr prpadnum      ; print it
  rts


;;; print16 is shared by both the signed and unsigned printing
;;; routine. By the time we get here, we should already have
;;; printed a space and potentially a minus sign.
assemble16
  dex               ; make working space on the stack
  dex
  dex
  
  ;; that leaves the data to be read at stackbase+4,x and stackbase+5,x
  
  stz stackbase+1,x ; These are the bytes in which we'll assemble
  stz stackbase+2,x ; up to five BCD digits. Initialize them to
  stz stackbase+3,x ; zero.

  phy               ; preserve Y
  lda #0
  sed
  ldy #16           ; count of bits we are processing

.(
loop
  asl stackbase+4,x
  rol stackbase+5,x
  lda stackbase+1,x
  adc stackbase+1,x
  sta stackbase+1,x
  lda stackbase+2,x
  adc stackbase+2,x
  sta stackbase+2,x
  rol stackbase+3,x
  dey
  bne loop
.)
  cld

  ;; we have the result in the temporary storage, as BCD. now print that as
  ;; a five-character string (since max is 65535).

  ;; first set a flag to signal whether we've printed anything non-zero
  stz SCRATCH

  txa               ; calculate base address we'll be using
  adc #<stackbase
  sta SCRATCH+2
  lda #>stackbase
  sta SCRATCH+3
  ldy #3

.(
nextbcd             ; go through this loop for each BCD digit
  ;; first, upper four bits
  lda (SCRATCH+2),y
  and #%11110000
  bne prupper       ; not zero, so we definitely print it
  cmp SCRATCH       ; check if we are still suppressing zeros
  beq lower         ; yes, we are. move on.
prupper
  clc
  ror
  ror
  ror
  ror
  clc
  adc #'0
;  jsr puta          ; print the digit
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

lower
  lda (SCRATCH+2),y
  and #%00001111
  bne prlower       ; non-zero so we definitely print it
  cmp SCRATCH       ; test for suppressing leading zeros
  beq skip
prlower
  clc
  adc #'0
;  jsr puta          ; print the digit
  sta (PADPTR)
  inc PADPTR
  lda #$ff          ; note that printing has begun (no more leading zeros)
  sta SCRATCH

skip
  dey
  bne nextbcd
.)

.(
  lda SCRATCH      ; did we not print anything?
  bne finalize
  lda #$30         ; print a zero
  ;jsr puta
  sta (PADPTR)
  inc PADPTR

finalize
  sec               ; finalize the string count
  lda PADPTR
  sbc #<PAD
  dec               ; remove one
  sta PAD           ; that's the count
  ply               ; restore y

  txa               ; clear five bytes off the stack (three for
  clc               ; working space and two for the parameter)
  adc #5
  tax
.)
  rts

;; print the counted string on the pad and clean up the stack after print
prpadnum
.(
  phy               ; preserve Y

  ldy #1
printnext
  lda PAD,y
  jsr puta
  cpy PAD
  beq cleanup
  iny
  bra printnext
  
cleanup
  ;; clean up -- reclaim our temporary space and also pop item from stack
  ply              ; restore Y
.)
  rts

;;; this is just here because the stack code needs it... should
;;; reoganize my files...
putax
  rts

;;; STRING CONSTANTS
;;;


greeting	 .byte "SECND 6502 Forth v07 (Paul Dourish, 2017-12)", $00
ok:		 .byte "  OK", $0d, $0a, $00
dots:		 .byte "   ...", $0d, $0a, $00
cantinterpret:   .byte ": not defined", $00
nesting:	 .byte "  nesting mismatch", $00
compileerr:      .byte "  compile-only word encountered", $00
exitmsg:	 .byte $0d, $0a, $0d, $0a, "Exiting.", $0d, $0a, $00
inityesmsg:      .byte " initialized", $0d, $0a, $00
initnosmsg:      .byte " initialization failed", $0d, $0a, $00
timeoutmsg:      .byte " timeout", $0d, $0a, $00
cardfailmsg:     .byte " couldn't initialize card", $0d, $0a, $00
initializedmsg:  .byte " initialized ", $00
diskerrormsg:    .byte " disk error", $0d, $0a, $00
dirofmsg:        .byte "Directory of ", $00
