
;;;
;;; SECND - A FORTH FOR 6502
;;;
;;; Since "FORTH" is actually an abbreviation of "FOURTH", "SECND"
;;; is an abbreviation of "SECOND", it being my second FORTH
;;; implementation. The last one was over 30 years ago, but let's
;;; not worry about that now. This time, I'm sticking closer to
;;; standards, albeit outdated ones; the starting point for this
;;; is FigFORTH although it may get ANSIfied along the way.
;;;
;;; I'm building this for my single-board 6502 computer, the Mite.
;;; For now at least, this is written to be loaded in RAM.
;;;
;;; Paul Dourish, December 2017
;;;
;;; Version history:
;;; v01  first basic version of interpreter up and running
;;; v02  adding R-stack operators, variables, arrays, allot.
;;; v03  first steps for compiler, basic lists, strings.


  * = $0300

;;;
;;; Variables/space setup
;;;

SCRATCH    = $0010  ; through to $001F (adopted from monitor)

;;; MEMORY MAP
;;;
;;; 0000 through 004F is reserved for the monitor (reusing SCRATCH)
;;; 0050 through 007F is available for variables (below)
;;; 0080 through 00FF is operand stack
;;; 0100 through 01FF is the hardware stack as usual
;;; 0200 through 02FF is the return stack (more space than needed)
;;; 0300 through 0FFF is the interpreter and compiler code (this file)
;;; 1000 through 77FF is user dictionary space
;;; 7800 through 7DFF is CURRENTLY UNASSIGNED
;;; 7E00 through 7EBF is the PAD (string assembly area)
;;; 7EC0 through 7EFF is temporary string processing space
;;; 7F00 through 7FFF is the input buffer (TIB)

;;; 
;;; KEY SYSTEM VARIABLES
;;;
;;; IP is the instruction pointer
;;; DT (dictionary top) pointer to start (actually, end) of dictionary
;;; RP is return stack pointer
;;; XT holds execution token of currently executing word
;;; CODEVEC holds the location of the code for the next instruction
;;; DP holds pointer to the next available dictionary space
;;; TPTR holds the offset of the most recently processed input character
;;; TCNT holds the number of characters held in the buffer
;;; DPTR is an internal variable for traversing the dictionary
;;; STATUS is the system status flags (e.g. compilation flag)
;;; CWORD holds a pointer to the word currently being compiled
;;; INPUT points to the input buffer
;;; WORD points to the temporary string processing space
;;; 
;;;
IP=$0050            ; and 0051
RP=$0052            ; and 0053
DT=$0054            ; and 0055
XT=$0056            ; and 0057
CODEVEC=$0058       ; and 0059
TPTR=$005A
TCNT=$005B
DPTR=$005C          ; and 005D
DP=$005E            ; and 005F
STATUS=$0060        ; status word
CWORD=$0061         ; and 0062
PADPTR=$0063        ; and 0064
PAD=$7E00           ; PAD (string assembly area)
WORD=$7EC0          ; temporary space for parsing words (max 63 chars)
INPUT=$7F00         ; input space

COMPILE=%00000001   ; status flags

IMM=%00100000       ; flag for IMMEDIATE word (ie executed in compile mode)

  jmp coldstart     ; jump past code defined in stack routines

#include "../mitemon/decl.a65"
#include "../mitemon/stack.a65"


;;;
;;; initialization and configuration
;;;
coldstart
  ;; initialize stack...
  jsr initstack

  ;; initialize variables...

  ;; IP is the Forth instruction pointer
  stz IP
  stz IP+1

  stz STATUS        ; turn of compilation

  ;; Initialize the return stack. I'm just putting that on page 2, 
  ;; growing upwards, until I have a better idea.
  stz RP
  lda #$02
  sta RP+1

  ;; Initialize DT to the last entry on the dictionary (below)
  lda #<dtop
  sta DT
  lda #>dtop
  sta DT+1  

  ;; Initialize DP to the first available dictionary space ($1000)
  lda #$00
  sta DP
  lda #$10
  sta DP+1

  ;; jump to text interpreter
  jmp startinterp



;;;
;;; DICTIONARY
;;;
;;; Each entry in the dictionary comprises:
;;; - one byte that is both tags (three upper bits) and word length
;;;   five lower bits)
;;; - the characters making up the word definition name
;;; - pointer to next entry
;;; - the "code word" (address of code handling this instruction, which
;;;   will often be DOLIST for compiled words)
;;; - the parameter space (often the list of addresses for executing
;;;   this word, and often ending with EXIT)
;;;

d0entry
  .byte 4
  .byte "exit"
d0link
  .word $0000
exitcode
d0code
  .word exit

d1entry
  .byte 1
  .byte "+"
d1link
  .word d0entry
d1code
  .word doplus

d2entry
  .byte 1
  .byte "*"
d2link
  .word d1entry
d2code
  .word dotimes

d3entry
  .byte 7
  .byte "0branch"
d3link
  .word d2entry
zerobracode
d3code
  .word dozerobra

d4entry
  .byte 4
  .byte "test"
d4link
  .word d3entry
d4code
  .word dolist
d4param
  .word zerobracode
  .word $0008
  .word dotquotecode
  .byte 3
  .byte "yes"
  .word d0code

d5entry
  .byte 5
  .byte "dolit"
d5link
  .word d4entry
dolitcode
d5code
  .word dolit

d6entry
  .byte 1
  .byte "."
d6link
  .word d5entry
d6code
  .word doprint

d7entry
  .byte 5
  .byte "twice"
d7link
  .word d6entry
d7code
  .word dolist
d7param
  .word d5code      ; code for dolit
  .word 0002
  .word d2code
  .word d0code

d8entry
  .byte 5
  .byte "meta2"
d8link
  .word d7entry
d8code
  .word dolist
d8param
  .word d7code
  .word d6code
  .word d0code

d9entry
  .byte 3
  .byte "dup"
d9link
  .word d8entry
d9code
  .word dodup

d10entry
  .byte 4
  .byte "swap"
d10link
  .word d9entry
d10code
  .word doswap

d11entry
  .byte 4
  .byte "drop"
d11link
  .word d10entry
d11code
  .word dodrop

d12entry
  .byte 1
  .byte "/"
d12link
  .word d11entry
d12code
  .word dodiv

d13entry
  .byte 3
  .byte "mod"
d13link
  .word d12entry
d13code
  .word domod

d14entry
  .byte 1
  .byte "="
d14link
  .word d13entry
d14code
  .word doequal

d15entry
  .byte 5
  .byte "depth"
d15link
  .word d14entry
d15code
  .word dodepth

d16entry
  .byte 1
  .byte ">"
d16link
  .word d15entry
d16code
  .word dogreater

d17entry
  .byte 1
  .byte "<"
d17link
  .word d16entry
d17code
  .word doless

d18entry
  .byte 2
  .byte "cr"
d18link
  .word d17entry
d18code
  .word docr

d19entry
  .byte 4
  .byte "emit"
d19link
  .word d18entry
d19code
  .word doemit

d20entry
  .byte 4
  .byte "over"
d20link
  .word d19entry
d20code
  .word doover

d21entry
  .byte 3
  .byte "rot"
d21link
  .word d20entry
d21code
  .word dorot

d22entry
  .byte 7
  .byte "testvar"
d22link
  .word d21entry
d22code
  .word dovaddr
d22param
  .word $1234

d23entry
  .byte 1
  .byte "@"
d23link
  .word d22entry
d23code
  .word dofetch

d24entry
  .byte 2
  .byte "c@"
d24link
  .word d23entry
d24code
  .word docfetch

d25entry
  .byte 1
  .byte "!"
d25link
  .word d24entry
d25code
  .word dostore

d26entry
  .byte 2
  .byte "c!"
d26link
  .word d25entry
d26code
  .word docstore

d27entry
  .byte 5
  .byte "cells"
d27link
  .word d26entry
d27code
  .word docells

d28entry
  .byte 8
  .byte "variable"
d28link
  .word d27entry
d28code
  .word dovariable

d29entry
  .byte 1
  .byte "-"
d29link
  .word d28entry
d29code
  .word dominus

d30entry
  .byte 4
  .byte "here"
d30link
  .word d29entry
d30code
  .word dohere

d31entry
  .byte 5
  .byte "allot"
d31link
  .word d30entry
d31code
  .word doallot

d32entry
  .byte 3
  .byte "bye"
d32link
  .word d31entry
d32code
  .word dobye

d33entry
  .byte 1
  .byte ":"
d33link
  .word d32entry
d33code
  .word docolon

d34entry
  .byte %00100001   ; set the immediate bit plus count of 1
  .byte ";"
d34link
  .word d33entry
d34code
  .word dosemic

d35entry
  .byte 2
  .byte ">r"
d35link
  .word d34entry
d35code
  .word dotor

d36entry
  .byte 2
  .byte "r>"
d36link
  .word d35entry
d36code
  .word dofromr

d37entry
  .byte 2
  .byte "r@"
d37link
  .word d36entry
d37code
  .word dorcopy

d38entry
  .byte 1
  .byte "i"
d38link
  .word d37entry
d38code
  .word dorcopy

d39entry
  .byte %00100010   ; IMM flag plus count of two
  .byte $2e, $22    ; dot, quote (.")
d39link
  .word d38entry
dotquotecode
d39code
  .word dodotqu

d40entry
  .byte %00100010   ; IMM flag plus count of two
  .byte "if"
d40link
  .word d39entry
d40code
  .word doif

dtop
d41entry
  .byte %00100100   ; IMM flag plus count of four
  .byte "then"
d41link
  .word d40entry
d41code
  .word dothen


;; TOP OF DICTIONARY


;;;
;;; The words below are my experiment on calling things and getting
;;; back to the interpreter. Dummy is the word we'll enter in order to
;;; execute something; the point of it is to make sure that after we've
;;; executed what we want, we run "doquitword", which should take us
;;; back into the interpreter loop
;;;


doquitword
  .byte 0
doquitlink
  .word $0000
doquitcode
  .word interploop

dummy
  .byte 0
dummylink
  .word $0000
dummycode
  .word dolist      ; won't actually run this, start with NEXT instead
dummyparam
  .word $0000       ; will write in the actual code link word here
dummyexit
  .word doquitcode





;;;
;;; INNER INTERPRETER
;;;
;;; The three routines below -- NEXT, DOLIST, and EXIT -- are the core
;;; of the inner interpreter, which executes stored words.
;;;
;;; NEXT moves from one instruction to the next inside a defined word.
;;; This code is included at the end of each assembly language routine
;;; (or rather, we jump to it).
;;;
;;; DOLIST begins the execution of a compiled word. It stores the IP
;;; on the return stack, resets the IP to the new word, and then calls
;;; NEXT to start on it.
;;;
;;; EXIT is compiled in as the last address of each compiled word. It
;;; undoes what DOLIST has done, and moves back to the earlier execution
;;; context.
;;;
;;; Note that none of these are subroutines -- everything is connected
;;; as direct jumps (actually, indirect jumps!) with the RSTACK used
;;; to keep track of what's going on.



;;; DOLIST is the executing code for a colon-defined word.
dolist
  ;; first, push the current instruction pointer onto the
  ;; return stack
  ;; NB-- this was previously done via jsr rpush but I unrolled it
  ;; here to save some loads/stores and a JSR. Old code is left in
  ;; comments as documentation.
  lda IP
  sta (RP)
  inc RP
  lda IP+1
  sta (RP)
  inc RP

  ;; next, grab the first address in the parameter block for this
  ;; colon-defined word. We know that XT points to the code word.
  ;; so we grab that address and then add one cell (two bytes)
  ;; store this in IP.

  clc
  lda XT
  adc #$2
  sta IP
  lda XT+1
  adc #0
  sta IP+1

; DELETE THIS LATER
;  lda (IP)
;  sta SCRATCH
;  ldy #1
;  lda (IP),y
;  sta IP+1
;  lda SCRATCH
;  sta IP

  ;; IP now points to the next isntruction we want to execute, in
  ;; this word. Proceed to execute it.
  ;jmp next         ; commented out because we can just fall through

;;; ** PUT NOTHING HERE... depending on fall-through from DOLIST to NEXT!

;;; NEXT executes the next word. Before it does the jump, it increments
;;; IP so that IP always designates the next word to be executed.
next
  ldy #0            ; IP points to the location storing the next
  lda (IP),y        ; word we need to execute. fetch that location,
  sta XT            ; and store it in XT.
  iny
  lda (IP),y
  sta XT+1

  lda (XT),y        ; TMP contains a pointer to a code word. Load
  sta CODEVEC+1     ; the code address stored there into CODEVEC.
  dey
  lda (XT)
  sta CODEVEC

  ;; increment IP before we move on
.(
  inc IP            ; lower byte first
  bne continue      ; skip upper byte if we haven't rolled over
  inc IP+1
continue
.)
.(
  inc IP            ; now same again, because we need to inc by 2
  bne continue
  inc IP+1
continue
.)

  jmp (CODEVEC)     ; execute the code for this instruction/word



;;; EXIT is the routine that is called at the end of each colon-defined
;;; word (it's compiled in as the last address to be called). It undoes
;;; DOLIST... it removes an address from the return stack, puts it back
;;; as the instruction pointer, and calls next.
exit
  ;; formerly, jsr rpull, now unrolled.
  dec RP            ; take two bytes off the return stack
  dec RP
  ldy #1            ; now take the value that was on the return stack
  lda (RP),y        ; and place it in the instruction pointer
  sta IP+1
  lda (RP)
  sta IP
  jmp next          ; go execute the next instruction


;;;
;;; PRIMITIVES
;;;

doplus
  jsr add16
  jmp next

dominus
  jsr sub16
  jmp next

dotimes
  jsr mult16
  jmp next

dodiv
  jsr div16
  jmp next

domod
  jsr mod16
  jmp next

doprint
  jsr print16dec
  jmp next

docr
  jsr crlf
  jmp next

dodup
  jsr dup16
  jmp next

dodrop
  jsr pop16
  jmp next

doswap
  jsr swap16
  jmp next

doequal
.(
  lda stackbase+1,x
  cmp stackbase+3,x
  bne notequal
  lda stackbase+2,x
  cmp stackbase+4,x
  bne notequal
equal
  inx
  inx
  lda #$01
  sta stackbase+1,x
  stz stackbase+2,x
  bra done
notequal
  inx
  inx
  stz stackbase+1,x
  stz stackbase+2,x
done
.)
  jmp next

;; on the 6502, there's no simple "greater than" instruction;
;; BCS is "greater than or equal to". So, use BCC for "less than"
;; and invert result. also need different tests for upper and
;; lower bytes. This is also confused by the fact that the item that's
;; "lower" on the stack is higher in memory.
dogreater
.(
  lda stackbase+4,x ; most significant byte
  cmp stackbase+2,x ; is "lower" on stack less than "upper"?
  beq testlsb       ; equal, so go to lower byte
  bmi notgreater    ; less than, so answer is "no"
  bra greater       ; greater than, so answer is "yes"
testlsb
  lda stackbase+3,x ; less signficant byte
  cmp stackbase+1,x ; is "higher" on stack less than "lower"?
  beq notgreater
  bmi notgreater
greater
  inx
  inx
  lda #$01
  sta stackbase+1,x
  stz stackbase+2,x
  bra done
notgreater
  inx
  inx
  stz stackbase+1,x
  stz stackbase+2,x
done
.)
  jmp next

doless
.(
  lda stackbase+4,x
  cmp stackbase+2,x
  bmi yes
  beq testlsb
  bra no
testlsb
  lda stackbase+3,x
  cmp stackbase+1,x
  beq no
  bpl no
yes
  inx
  inx
  lda #$01
  sta stackbase+1,x
  stz stackbase+2,x
  bra done
no
  inx
  inx
  stz stackbase+1,x
  stz stackbase+2,x
done
.)
  jmp next

dodepth
  stx SCRATCH
  lda #$ff
  sec
  sbc SCRATCH
  clc
  lsr
  stz stackbase,x
  dex
  sta stackbase,x
  dex
  jmp next

doemit
  lda stackbase+1,x
  jsr puta
  inx
  inx
  jmp next

doover
  dex
  dex
  lda stackbase+5,x
  sta stackbase+1,x
  lda stackbase+6,x
  lda stackbase+2,x
  jmp next

dorot
  dex               ; make some new space on the stack
  dex
  lda stackbase+7,x ; first, copy the item from three down on the stack
  sta stackbase+1,x ; into the new space
  lda stackbase+8,x ; so, 7/8 -> 1/2
  sta stackbase+2,x

  lda stackbase+5,x ; now move everything back
  sta stackbase+7,x ; first, 5/6 -> 7/8
  lda stackbase+6,x
  sta stackbase+8,x
  lda stackbase+3,x ; then 3/4 -> 5/6
  sta stackbase+5,x
  lda stackbase+4,x
  sta stackbase+6,x
  lda stackbase+1,x ; then 1/2 -> 3/4
  sta stackbase+3,x
  lda stackbase+2,x
  sta stackbase+4,x

  inx               ; clean up
  inx

  jmp next


;;; DOLIT is the run-time code for literal values. Read the contents of
;;; the next parameter as a value to be pushed onto the stack.
;;; We enter with IP indicating the literal value; we increment IP
;;; by two bytes (one cell) so that skips to the next instruction to be
;;; executed.
dolit
  ldy #0            ; load the value there
  lda (IP),y
  sta stackaccess   ; and store in stackaccess
  iny               ; (now the second byte)
  lda (IP),y
  sta stackaccess+1
  jsr push16        ; add to the data stack

.(
  inc IP            ; increment IP to next cell (which stores the value)
  bne continue
  inc IP+1
continue
.)
.(
  inc IP
  bne continue
  inc IP+1
continue
.)
  jmp next


;;; dovaddr is the internal code for variables... look up the current
;;; XT and use it to find the address reserved for the variable, and
;;; push that.
dovaddr
  lda XT
  sta stackaccess
  lda XT+1
  sta stackaccess+1
.(
  inc stackaccess
  bne continue
  inc stackaccess+1
continue
.)
.(
  inc stackaccess
  bne continue
  inc stackaccess+1
continue
.)
  jsr push16
  jmp next

;;; dofetch is the code for "@". Pull an address off the stack and
;;; look up the 16-bit data stored at that address
dofetch
  jsr pop16         ; pop value into stackaccess
  dex               ; make space on the stack
  dex
  ldy #1
  lda (stackaccess),y  ; load MSB and store on stack
  sta stackbase+2,x    ; store in the new space on the stack
  dey
  lda (stackaccess),y  ; then LSB
  sta stackbase+1,x
  jmp next

;;; docfetch is the same as dofetch except for just one byte
docfetch
  jsr pop16         ; pop value into stackaccess
  dex               ; make space on the stack
  dex
  stz stackbase+2,x ; set MSB to zero
  lda (stackaccess) ; grab single byte
  sta stackbase+1,x ; and store in LSB
  jmp next


;;; dostore is the code for "!". Pull an address of the stack as in
;;; dofetch; but store the address pointed to by the next stack
;;; location in it.
dostore
  jsr pop16         ; put address into stackaccess
  ldy #1
  lda stackbase+1,x  ; load LSB off stack and
  sta (stackaccess)    ; store at location we popped
  lda stackbase+2,x    ; then for MSB
  sta (stackaccess),y  ; with y=1
  inx               ; drop the value from the stack
  inx
  jmp next

;;; cstore is just like store except stores just one byte (LSB from stack)
docstore
  jsr pop16         ; put address into stackaccess
  lda stackbase+1,x ; load LSB off stack and
  sta (stackaccess) ; store at location we popped
  inx               ; drop the value from the stack
  inx
  jmp next


;;; Turn an integer count of cells into a count of bytes. Since
;;; my cells are two bytes, that means multiplying item on top of
;;; stack by two (shift left).
docells
  asl stackbase+1,x
  rol stackbase+2,x
  jmp next


;;; variable reads the next word from input and allocates space
;;; for it in the dictionary as a variable (ie with the "dovaddr"
;;; code).
dovariable
  ;; grab next word from the input buffer
  jsr readnext      ; next word from input buffer into WORD
 
  ;; copy word from WORD
  lda WORD          ; first, copy the count
  sta (DP)
  tay               ; store count in Y
.(
copynext            ; now copy the rest of the word, backwards
  lda WORD,y        ; copy Yth letter
  sta (DP),y        ; store it in dictionary space
  dey               ; count down to 0
  bne copynext
.)

  lda (DP)          ; set Y to next available byte
  tay
  iny

  ;; set link to location pointed to by DT
  lda DT
  sta (DP),y
  iny
  lda DT+1
  sta (DP),y
  iny

  ;; set code to dovaddr
  lda #<dovaddr
  sta (DP),y
  iny
  lda #>dovaddr
  sta (DP),y
  iny

  iny               ; bump twice more to allow parameter space
  iny               ; for storage

  ;; set DT to new top entry, the one we've just created here
  lda DP
  sta DT
  lda DP+1
  sta DT+1

  clc               ; update DP to next available space
  tya               ; by adding bytes consumed to DP
  adc DP
  sta DP
  lda DP+1
  adc #0
  sta DP+1
 
  jmp next


;;; dohere implements "HERE" and just returns the pointer to the next
;;; available dictionary spot.
dohere
  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16
  jmp next


;;; ALLOT takes a number of bytes and bumps DP, which makes that many
;;; bytes available to whatever is at the top of the dictionary. It's
;;; used to allocate array space to variables.
doallot
  jsr pop16
  clc
  lda DP
  adc stackaccess
  sta DP
  lda DP+1
  adc stackaccess+1
  sta DP+1
  jmp next


;;; Leave the system after printing a termination message. This
;;; just ends with an RTS, which should take us back to the monitor
;;; if we were called that way, or will crash things if we weren't,
;;; which has the same effect!
dobye
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda exitmsg,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
  rts
.)

;;; rcopy (for the Forth word "R") -- copy top of R stack onto data stack
;;;
dorcopy
  dec RP
  lda (RP)
  sta stackaccess+1
  dec RP
  lda (RP)
  sta stackaccess
  inc RP
  inc RP
  jsr push16
  jmp next

;; dotor (for the Forth word ">R" -- move from top of stack onto r-stack
;;;
dotor
  jsr pop16
  jsr rpush
  jmp next

;; dofromr (for Forth word "R>" -- move from r-stack to top of stack
;;;
dofromr
  jsr rpull
  jsr push16
  jmp next

;;; docolon implements the colon-word... basically, acts like
;;; variable in that it opens up a dictionary word, althogh this
;;; time for a dolist definition. Also, it sets the compile flag.
;;;
;;; NB things will go wrong if we enconter a colon inside a colon
;;; definition or start to process variables or something. We presume
;;; that nothing is going to mess with DP while compilation is in
;;; progress.
;;;
docolon
  ;; first, set the compiler flag
  lda STATUS
  ora #COMPILE
  sta STATUS

  ;; grab next word from the input buffer
  jsr readnext      ; next word from input buffer into WORD
 
  ;; copy word from WORD
  lda WORD          ; first, copy the count
  sta (DP)
  tay               ; store count in Y
.(
copynext            ; now copy the rest of the word, backwards
  lda WORD,y        ; copy Yth letter
  sta (DP),y        ; store it in dictionary space
  dey               ; count down to 0
  bne copynext
.)

  lda (DP)          ; set Y to next available byte
  tay
  iny

  ;; set link to location pointed to by DT
  lda DT
  sta (DP),y
  iny
  lda DT+1
  sta (DP),y
  iny

  ;; set code to dolist
  lda #<dolist
  sta (DP),y
  iny
  lda #>dolist
  sta (DP),y
  iny

  lda DP            ; cache the address of the word we're now compiling
  sta CWORD         ; we wait until we're done (dosemic) before we update
  lda DP+1          ; the top-of-dictionary pointer
  sta CWORD+1

  clc               ; update DP to next available space
  tya               ; by adding bytes consumed to DP
  adc DP
  sta DP
  lda DP+1
  adc #0
  sta DP+1
 
  jmp next           ; not sure which of these is right...
  ;jmp interploop    ; in the compiler, we don't execute NEXT


;;; do-semi-colon, ie, tidy up when we're finishing compiling a word
;;;
dosemic
  ;; turn off the compiler
  lda STATUS
  and #%11111110
  sta STATUS

  ;; add call to exit at the end of the entry
  ldy #0
  lda #<d0code
  sta (DP),y
  iny
  lda #>d0code
  sta (DP),y

  ;; update DP for those two last bytes
.(
  inc DP
  bne continue
  inc DP+1
continue
.)
.(
  inc DP
  bne continue
  inc DP+1
continue
.)

  ;; set DT to new top entry, the word we've just finished compiling
  lda CWORD
  sta DT
  lda CWORD+1
  sta DT+1

  jmp next


;;; Do dot-quote. I'm not entirely happy with my solution for this yet.
;;; This word has three different context-dependent behaviors:
;;; 1. when we are compiling (determined by compiler flag), assemble
;;;    string from the text stream and compile it into the word.
;;; 2. when we are called as part of a regular execution cycle, print
;;;    the word that's compiled in following this instruction.
;;; 3. when we are running in the interpreter, as determined by IP
;;;    pointing to the dummy word, assemble the string that follows
;;;    in the input buffer and print it.
dodotqu
.(
  ;; are we compiling?
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; Yes. compile it (case 1)
  ;; first, add in the execution word
  lda #<dotquotecode
  sta (DP)
  ldy #1
  lda #>dotquotecode
  sta (DP),y

  ;; then update DP by 2, to account for that word
.(
  inc DP
  bne skip
  inc DP+1
skip
.)
.(
  inc DP
  bne skip
  inc DP+1
skip
.)

  ;; next, assemble the string on the PAD
  jsr assemblestr

  ;; now we copy it into space where we are comping, pointed to by DP.
  lda PAD           ; first, copy the length
  sta (DP)

  tay               ; now copy the rest of the string (backwards)
charloop
  lda PAD,y
  sta (DP),y
  dey
  bne charloop

  ;; now update DP to account for the string
  clc
  lda PAD           ; that's the length count for the string
  inc               ; add one for the count byte
  adc DP            ; bump DP by that many bytes
  sta DP
  lda DP+1
  adc #$0
  sta DP+1

  jmp next          ; and proceed. we're done.

nocompile
  ;; are we interactive?
  ;; we can tell if IP points to dummyexit
  lda IP
  cmp #<dummyexit
  bne nointerp
  lda IP+1
  cmp #>dummyexit
  bne nointerp

  ;; Yes, so we need the interactive behaviour (case 3)

  ;; first. assemble the string to be printed
  jsr assemblestr

  ;; now print it
  ;; but first, write in a space over the length indicator,
  ;; which we don't need because it's null-terminated
  lda #$20
  sta PAD

  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda PAD,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
.)

  jmp next          ; we're done so proceed to next instruction

nointerp
  ;; Finally, this is the regular behavior (case 2). We're executing
  ;; from a compiled word. So IP points to a counted string. Print
  ;; it, and increment the instruction pointer appropriately.

.(
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda #$20          ; print a space to begin
  sta ACIA_DATA
.)

  phx               ; save X, since we're about to use it
  lda (IP)          ; load the string length
  tax               ; transfer to X. X counts down as Y counts up
  ldy #1

  ;; now print X characters 
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda (IP),y
  sta ACIA_DATA
  iny
  dex
  bne next_char
done
.)

  plx               ; restore X

  ;; finally, update the instruction pointer
  ;; Y is the number of characters plus one (because of the last iny)
  ;; so that's actually just the right number to add to the IP.
  tya               ; transfer Y to A and add it to IP
  clc
  adc IP            ; LSB
  sta IP
  lda IP+1
  adc #$0           ; MSB (for carry)
  sta IP+1
.)

  jmp next          ; continue to the next instruction


;;; Read text from the input buffer up until a single quote mark
;;; and assemble it onto the PAD. At the end, we'll have a string
;;; that is both counted and null-terminated. This is used in both
;;; compile mode and run mode of dotquote.
assemblestr

  ;; first, set up the PAD ptr
  lda #<PAD
  sta PADPTR
  lda #>PAD
  sta PADPTR+1

.(
  ;; read the next word into WORD
continue
  jsr readnext

  ;; is it a closing quote? count of 1, char is $22
  lda WORD
  cmp #$01          ; check the string length
  bne assemble
  lda WORD+1        ; we know it's a single-character string
  cmp #$22          ; check the single character
  beq finished

assemble
  ;; concatenate onto the string we're assembling at PAD
  lda #$20          ; space
  sta (PADPTR)
  ldy WORD          ; the character count
.(
nextchar
  lda WORD,y
  sta (PADPTR),y    ; Y is off-by-one but it's okay (leading space)
  dey
  bne nextchar
.)

  ;; update PADPTR
  lda WORD          ; length of this most recent word
  inc               ; plus leading space
  clc
  adc PADPTR
  sta PADPTR        ; update the pointer
  lda PADPTR+1
  adc #0            ; in case we generated a carry...
  sta PADPTR+1

  ;; update count
  sec               ; BUG this will stop working if PAD crosses word boundary
  lda PADPTR
  sbc #<PAD
  dec               ; subtract one (don't count the count byte itself)
  sta PAD

  bra continue
.)
finished
  ;; add a null at the end of the string
  lda #$00
  sta (PADPTR)

  rts


;;; 0branch is an internal word used for conditionals. Test top of stack,
;;; and if false, add the next parameter (ie instruction offset) to the
;;; IP.
dozerobra
  jsr pop16         ; pull value off the top of the stack
  lda stackaccess   ; test for zero
  bne nonzero
  lda stackaccess+1
  bne nonzero
zero
  lda (IP)          ; now load the offset and put it at SCRATCH+2
  sta SCRATCH+2
  ldy #1  
  lda (IP),y
  sta SCRATCH+3

  clc               ; now add the offset to the IP
  lda SCRATCH+2
  adc IP
  sta IP
  lda SCRATCH+3
  adc IP+1
  sta IP+1

  jmp next

nonzero

  ;; we will continue with processing, but first, increment IP
  ;; so as to skip the branch offset.
.(
  inc IP
  bne continue
  inc IP+1
continue
.)
.(
  inc IP
  bne continue
  inc IP+1
continue
.)

  jmp next          ; all done, proceed to next instruction


;;; doif is an immediate word that compiles IF.
;;; compile it into a 0bra, and put the address of the branch word
;;; onto the stack. Pesume that THEN will later come back
;;; and fix up the address
doif
.(
  lda STATUS
  bit #COMPILE
  beq nocompile

  lda #<zerobracode
  sta (DP)
  ldy #1
  lda #>zerobracode
  sta (DP),y

.(
  inc DP
  bne skip
  inc DP+1
skip
.)
.(
  inc DP
  bne skip
  inc DP+1
skip
.)

  lda DP
  sta stackaccess
  lda DP+1
  sta stackaccess+1
  jsr push16

.(
  inc DP
  bne skip
  inc DP+1
skip
.)
.(
  inc DP
  bne skip
  inc DP+1
skip
.)


nocompile
  jmp next
.)


dothen
  ;; take the current DP pointer, and subtract from it the value on
  ;; the stack. The result is the offset that should be stored in
  ;; the word pointed to by the item on the stack. Pop it from the stack.

  jsr pop16         ; pop branch address into stackaccess

  sec               ; calculate offset
  lda DP
  sbc stackaccess
  sta SCRATCH
  lda DP+1
  sbc stackaccess+1
  sta SCRATCH+1

  lda SCRATCH       ; write it into the branch instruction
  sta (stackaccess)
  ldy #1
  lda SCRATCH+1
  sta (stackaccess),y

  jsr next          ; done. proceed to next instruction.

  
;;;
;;; TEXT INTERPRETER
;;;
;;; For the moment, this is a basically a stopgap. The real FORTH
;;; text interpreter has many individual components that manifest
;;; themselves as words in the dictionary, and we'll get there.
;;; (The fact that the text interpreter is called QUIT in true Forth
;;; is the ultimate testement to Chuck Moore's twisted nature.)
;;; This is just something to get us going. Again, much borrowed here
;;; from the code of the monitor.
;;;


;;; initialize the interpreter
;;;
startinterp

  ;; set up buffer (nothing to do)

  ;; set up buffer pointer (current pointer within text buffer)
  stz TPTR

  ;; set up buffer counter (number of characters input)
  stz TCNT

  ;; print greeting
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda greeting,y
  beq interploop
  sta ACIA_DATA
  iny
  jmp next_char
.)


;;; This is the main loop of the interpreter -- which also includes
;;; hooks to the compiler, because in Forth those are deeply
;;; conjoined.
;;;
interploop

  ;; get the next input word into WORD, potentially refilling
  ;; the text buffer in the process
  jsr readnext

  ;; check for match

matchword
  ;; set up search by initializing dictionary pointer
  lda DT
  sta DPTR
  lda DT+1
  sta DPTR+1

nextentry
  ;; have we run out of dictionary entries? (when DPTR is $0000)
  lda DPTR
  bne compareentry
  lda DPTR+1
  beq nomatch

compareentry
  ;; compare words. counted strings can be compared directly, will compare
  ;; counts first. But we need to mask out the tags in the count.

  ldy #0
  lda (DPTR),y
  and #%00011111    ; mask off the tags
  cmp WORD,y        ; compare word lengths
  bne trynext       ; no match

  ;; now compare words. do this from the end (for easier testing)
  ldy WORD
.(
nextchar
  lda (DPTR),y
  cmp WORD,y
  bne trynext
  dey
  bne nextchar
.)
  ;; successful match!
  bra gotmatch
  
  ;; loop to next entry
trynext
  lda (DPTR)        ; get word length...
  and #%00011111    ; mask off the tags
  tay               ; store in Y, and add one...
  iny               ; for the pointer to the next entry
  lda (DPTR),y      ; update DPTR to point to next entry
  sta SCRATCH
  iny
  lda (DPTR),y  
  sta DPTR+1
  lda SCRATCH
  sta DPTR
  bra nextentry

  ;; we found a match for a word to execute. Set up the context
  ;; and call NEXT to get started.
gotmatch

  ;; first, check if we're compiling. if we are not, then we can continue
  lda STATUS
  bit #COMPILE
  beq nocompile

  ;; now check if the word is immediate... because if it is, we should
  ;; go ahead and execute
  lda (DPTR)
  bit #IMM
  bne nocompile

  ;; compile this into the currently-compiling word. that means we
  ;; should add the address of the code word into the location
  ;; pointed to by DP and increment DP.
  ;; DPTR stores the start of the entry for the word to execute.
  ;; So its code word is at (DPTR) + wordlength + 1 (len) + 2 (link)
  ldy #1
  lda (DPTR)        ; word length
  and #%00011111    ; mask off tag bits
  inc 		    ; +1 for the length byte
  inc
  inc               ; + 2 more for the link word
  clc
  adc DPTR          ; add to address and store in dummy word entry
  sta (DP)
  lda DPTR+1
  adc #$0
  sta (DP),y

  ;; increment DP by 2
  inc DP
.(
  bne continue
  inc DP+1
continue
.)
.(
  inc DP
  bne continue
  inc DP+1
continue
.)
  ;; proceed with the interpreter loop
  jmp interploop

nocompile
  ;; DPTR stores the start of the entry for the word to execute.
  ;; So its code word is at (DPTR) + wordlength + 1 (len) + 2 (link)
  lda (DPTR)        ; word length
  and #%00011111    ; mask off tag bits
  inc 		    ; +1 for the length byte
  inc
  inc               ; + 2 more for the link word
  clc
  adc DPTR          ; add to address and store in dummy word entry
  sta dummyparam
  lda DPTR+1
  adc #$0
  sta dummyparam+1

  ;; put the dummy parameter address into IP.
  lda #<dummyparam
  sta IP
  lda #>dummyparam
  sta IP+1

  ;; jump to NEXT to start running it
  jmp next

  ;; we didn't find a match in the dictionary, so see if we can parse
  ;; it as a number.
nomatch
  ;; before we do the conversion, check that all the letters are digits

  ldy WORD
numcheck
  lda WORD,y
  cmp #$30
  bcc nointerpret   ; BCC = branch if less than
  cmp #$40
  bcs nointerpret   ; BCS = branch if greater or equal
  dey
  bne numcheck

  ;; convert number and put it on the stack
  ;; my routines for this us a null-terminated string, so add a null
  ldy WORD
  iny
  lda #0
  sta WORD,y        ; add a null
  lda #<WORD        ; put address on the stack threshold
  sta stackaccess
  lda #>WORD
  sta stackaccess+1
.(
  inc stackaccess   ; bump it by one to avoid the count
  bne done
  inc stackaccess+1
done
.)
  jsr push16
  jsr readdec16     ; convert it, leave it on the stack


  ;; if we are compiling, we need to take it off the stack again
  ;; and compile it into the word.
  lda STATUS
  bit #COMPILE
  beq normal

  ;; we are compiling. so we need to add this to the current
  ;; word as a literal. that means adding the code for DOLIT
  ;; and then the number.
  jsr pop16
  ldy #0
  lda #<dolitcode
  sta (DP),y
  iny
  lda #>dolitcode
  sta (DP),y
  iny
  lda stackaccess
  sta (DP),y
  iny
  lda stackaccess+1
  sta (DP),y
  iny

  ;; add Y to DP
  clc
  tya
  adc DP
  sta DP
  lda DP+1
  adc #0
  sta DP+1

normal
  jmp interploop
  
  ;; if we get here, we couldn't find a match, nor could we read it as
  ;; a number. there's no interpretation, so issue an error, flush
  ;; the input, and loop
nointerpret  

  ;; turn off the compiler, if we were compiling
  stz STATUS

  ;; print an error, in three stages. first, a space; then, the
  ;; undefined word; finally, the error message.

.(
wait_txd_empty3
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty3
  lda #$20
  sta ACIA_DATA
.)

  ldy #1
.(
next_char
wait_txd_empty3
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty3
  lda WORD,y
  sta ACIA_DATA
  iny
  cpy WORD
  bcc next_char
  beq next_char
.)

  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda cantinterpret,y
  beq nextstr
  sta ACIA_DATA
  iny
  bra next_char
nextstr
.)

  ;; flush input.
  lda TCNT
  sta TPTR          ; wait... off by one?
  jmp interploop


;;; readnext
;;; read the next word into the area at WORD, potentially refilling
;;; the entire buffer in the process.
;;; this is a subroutine so that I can also use it in dovariable,
;;; although it is mainly used by the text interpreter.
readnext
  ;; if no more input, ->nomoreinput

  lda TPTR          ; current pointer
  cmp TCNT          ; is that as much text as was read?
  beq nomoreinput   ; if yes, print prompt and get more

  tay               ; put TPTR into Y
interpword
  ;; begin loop

.(
  ;; look for next word
  lda INPUT,y
  cmp #$20          ; space
  beq nextchar
  cmp #$09          ; tab
  beq nextchar
  bne readword      ; not white space, so go and read a word

  ;; continue skipping past space
nextchar
  iny
  cpy TCNT
  beq nomoreinput
  bra interpword
.)

  ;; no more input -- we have exhausted the text buffer. refill.
nomoreinput
  ;; are we compiling?
  lda STATUS
  beq usualprompt   ; not compiling so say "OK" as usual
  jsr cprompt       ; different prompt to say we're still compiling
  bra refill
usualprompt
  jsr okcrlf        ; signal completion
refill
  jsr readline      ; read another line of text
  stz TPTR          ; reset the pointer
  bra readnext      ; loop around

  ;; we have detected the start of a non-space sequence. read a word
  ;; into a counted string at WORD.
readword
.(
  stz WORD
  phx
  ldx #1            ; X starts at 1 because 0 is the count
nextchar
  lda INPUT,y
  beq doneword      ; done if we hit NULL
  cmp #$20
  beq doneword      ; done if we hit space
  cmp #$09
  beq doneword      ; done if we hit tab
  sta WORD,x        ; X starts at 1 because 0 is the count
  stx WORD
  iny
  cpy TCNT          ; run off the end of the buffer?
  beq doneword
  inx
  bra nextchar
doneword
  plx
  sty TPTR          ; update the pointer (and free up Y)
.)
  rts




;;; Read a new line into the INPUT buffer
;;;
readline
  ldy #0
  stz TCNT          ; reset the counter
readchar
.(
wait_rxd_full    
  lda ACIA_STATUS
  and #$08
  beq wait_rxd_full
.)
  lda ACIA_DATA
  cmp #$08           ; check for backspace
  beq backspace
  cmp #$0D           ; check for newline
  beq doneline
  sta INPUT,y        ; track the input
  iny
  jsr puta           ; echo the typed character
  jmp readchar       ; loop to repeat
backspace
  cpy #0             ; beginning of line?
  beq readchar
  dey                ; if not, go back one character
  jsr puta           ; move cursor back
  jmp readchar

  ;; this is where we land if the line input has finished
  ;;
doneline
  lda #0
  sta INPUT,y       ; add a null terminator
  sty TCNT          ; update character count
  rts





;;;
;;; support routines
;;;

rpush
  lda stackaccess
  sta (RP)
  inc RP
  lda stackaccess+1
  sta (RP)
  inc RP            ; BUG presumes that RP doesn't roll over page boundary
  rts


rpull
  dec RP
  dec RP
  ldy #1
  lda (RP),y
  sta stackaccess+1
  lda (RP)
  sta stackaccess
  rts



;;;
;;; I/O SUPPORT ROUTINES
;;; These have been "borrowed" from mitemon
;;;

putax
.(
  phy

  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  pha             ; put a copy back
  clc
  and #$f0
  ror
  ror
  ror
  ror
  tay
  lda hextable,y
  sta ACIA_DATA
wait_txd_empty2
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty2
  pla
  clc
  and #$0f
  tay
  lda hextable,y
  sta ACIA_DATA
.)
  ply
  rts


puta
.(
  pha
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  pla
  sta ACIA_DATA
.)
  rts

okcrlf
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda ok,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
  rts
.)

cprompt
  ldy #0
.(
next_char
wait_txd_empty  
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
  lda dots,y
  beq done
  sta ACIA_DATA
  iny
  jmp next_char
done
  rts
.)


crlf
  pha
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0d
  sta ACIA_DATA
.(
wait_txd_empty
  lda ACIA_STATUS
  and #$10
  beq wait_txd_empty
.)
  lda #$0a
  sta ACIA_DATA
  pla
  rts


hextable:        .byte "0123456789ABCDEF"
greeting	 .byte "SECND 6502 Forth v03 (Paul Dourish, 2017-12)", $00
ok:		 .byte "  OK", $0d, $0a, $00
dots:		 .byte "   ...", $0d, $0a, $00
cantinterpret:   .byte ": not defined", $0d, $0a, $00
match:		 .byte " match!", $00
exitmsg:	 .byte $0d, $0a, $0d, $0a, "Exiting.", $0d, $0a, $00
